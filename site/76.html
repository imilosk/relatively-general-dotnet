
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 76 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-751">
            <a href="https://www.meziantou.net/deleting-github-actions-artifacts-using-the-github-rest-api.htm" target="_blank">
                <h2 class="title mb-6" id="article-751">Deleting GitHub Actions artifacts using the GitHub REST API</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 17, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">GitHub Actions supports sharing data between jobs in any workflow as artifacts. This is very convenient but the storage is limited (or you have to pay for it). If you use too much storage, you may get one of those notifications:You&#x27;ve used 75% of included services for GitHub Storage (GitHub Actions</p>
        </article>
        <article id="article-752">
            <a href="https://ayende.com/blog/196161-C/re-are-you-sure-you-want-to-use-mmap-in-your-database-management-system" target="_blank">
                <h2 class="title mb-6" id="article-752">re</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 14, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I was pointed to this paper on twitter: Are You Sure You Want to Use MMAP in Your Database Management System?&#xA;As you can imagine, this is a topic near and dear to my heart. This is especially the case since I am currently writing the Implementing a file pager in Zig posts series. I implemented the same low level mechanics using mmap, using mmap, I have &lt; 100 lines of code and can start building higher level concepts almost immediately. Writing my own pager is currently a 10 posts series and the end doesn&#x2019;t seem to be in sight.&#xA;I&#x2019;m going to use this post to respond to the article. As a reminder, I&#x2019;m the founder of RavenDB and I wrote Voron, a mmap based storage engine, and has been running that across hundreds of clients and literally tens of millions of instances in production. I am also writing a book about building a storage engine that uses mmap internally.&#xA;The paper itself does a great job of outlining the issue of using mmap as the buffer pool in DBMS. What it doesn&#x2019;t cover, however, is the alternative. I will touch on specific points from the paper shortly, but I want to point out that the article compares apples to camels in the benchmarks and conclusions. Note that I don&#x2019;t necessarily disagree with some of the statements, mmap certainly has challenges that you need to deal with, but if you avoid that, you can&#x2019;t have wave everything that it brings to the table.&#xA;When building a database, using mmap has the following advantages, the OS will take care of:&#xA;&#xA;Reading the data from disk&#xA;Concurrency between different threads reading the same data&#xA;Caching and buffer management&#xA;Eviction of pages from memory&#xA;Playing nice with other processes in the machine&#xA;Tracking dirty pages and writing to disk*&#xA;&#xA;I put an asterisk on the last one because it probably requires your attention as well.&#xA;If you aren&#x2019;t using mmap, on the other hand, you still need to handle all those issues. That is a key point that I believe isn&#x2019;t addressed in the paper. Solving those issues properly (and efficiently) is a seriously challenging task. Given that you are building a specialized solution, you can probably do better than the generic mmap, but it will absolutely have a cost. That cost is both in terms of runtime overhead as well as increased development time.&#xA;The comparison that was made by the paper was done using fio benchmark tool, which is great if you want to test your storage system, but is pretty much irrelevant if you are trying to benchmark a buffer pool. Consider the following:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // pool.h&#xA;        &#xA;        &#xA;          &#xA;          void* getPage(pool* p, long id);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // mmap_pool.c&#xA;        &#xA;        &#xA;          &#xA;          void* getPage(pool* p, long id){&#xA;        &#xA;        &#xA;          &#xA;             return p-&gt;base_ptr &#x2B; (id * PAGE_SIZE); &#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // fio_pool.c&#xA;        &#xA;        &#xA;          &#xA;          void* getPage(pool* p, long id) {&#xA;        &#xA;        &#xA;          &#xA;            // * lookup if the page is in memory&#xA;        &#xA;        &#xA;          &#xA;            // * if not, schedule its load&#xA;        &#xA;        &#xA;          &#xA;            // *** block the current thread? return an error and have it try later?&#xA;        &#xA;        &#xA;          &#xA;            // *** other threads that need this page should not initiate another load&#xA;        &#xA;        &#xA;          &#xA;            // * record that the page is used (to handle evictions later)&#xA;        &#xA;        &#xA;          &#xA;            // * record that this page is in use (to avoid evicting a page while it is in use)&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          buffer_pool.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For the mmap version, we need to compute the address of the page and that is pretty much it. For the manual buffer pool, the list of tasks that we need to handle is long. And some of them require us to be thread safe. For example, if we handed a page to a transaction, we need to keep track of that page status as being in use. We cannot evict this page until the transaction is done with it. That means that we probably need to do atomic reference counting, which can have very high costs. There are other alternatives, of course, but they all have even higher degrees of complexity.&#xA;In practice, data access within a database isn&#x2019;t actually random, even if you are doing random reads. There are pages that are going to almost always be referenced. The root page in the B&#x2B;Tree is a good example. It is always going to be used. Under atomic reference counting, that page is going to be a bottleneck.&#xA;Ignoring such overhead of the buffer pool management means that you aren&#x2019;t actually comparing equivalent structures. I should also point out that I&#x2019;m probably forgetting a few other tasks that the buffer pool needs to manage as well, which complicate its life significantly. Here is an example of such a buffer pool implementation from what is effectively a random GitHub repository. You can see what the code is trying to do here. The reason I point to this is that there is a mutex there (and I/O under the lock), which is fairly typical for many buffer pools. And not accounting for the overhead of buffer pool management is seriously skewing the results of the paper.&#xA;All of this said, I absolutely agree that mmap can be challenging. The paper outlines 4 different problems, which I want to address.&#xA;Problem #1 &#x2013; Transactional safety&#xA;A database needs to know when the data is persisted to disk. When using mmap, we explicitly give up that knowledge. That can be a challenge, but I don&#x2019;t see that as a seriously different one from not using mmap. Let&#x2019;s consider the manner in which Postgres is working. It has its own buffer pool, and may modify the pages as a result of a write. Postgres may need to evict modified pages to disk before the transaction that modified them is committed. The overhead of managing that is just&#x2026; part of the challenge that we need to deal with.&#xA;For RavenDB, as the paper points out, we modify the pages outside of the mmap memory. This is actually not done for the reason the paper describes. I don&#x2019;t actually care if the data is written to memory behind my back. What I care about is MVCC (a totally separate concern than buffer management). The fact that I&#x2019;m copying the modified data to the side means that I Can support concurrent transactions with far greater ease. In a similar fashion, Postgres handles MVCC using multiple entries for the same row in the same page.&#xA;When the transaction commits and older transactions no longer need the old version of the data, I can push the data from the modified buffers to the mmap region. That tends to be fairly fast (given that I&#x2019;m basically doing memcpy(), which runs at memory speed) unless I have to page data in, more on that later.&#xA;The paper mentions the issue of single writer in LMDB, and I wanted to point out that a single writer model is actually far more common (and again, not really related to the buffer pool issue). Off the top of my head, most embedded databases implement a single writer model.&#xA;&#xA;LMDB&#xA;Voron (RavenDB&#x2019;s storage engine)&#xA;LevelDB&#xA;Lucene&#xA;&#xA;The one that I can think that doesn&#x2019;t have a single writer is RocksDB(where allow_concurrent_memtable_write is for writes to the memtable, not related to file I/O).&#xA;The reason this matters is that embedded systems can typically assume that all operations in a transaction will complete as a unit. Compare to Postgres, where we may have a transaction spanning multiple network calls, interleaving writes is a must. If we could avoid such concurrency, that would be far preferable. You can get additional concurrency by having sharding writes, but that is usually not needed.&#xA;Problem #2 &#x2013; I/O Stalls&#xA;The paper points out, quite correctly, that not having control over the I/O means that you may incur a page fault at any time. In particular, you may end up blocked on I/O without really noticing. This can be a killer especially if you are currently holding a lock and blocked on page fault. Indeed, I consider this to be the most serious issue that you have to deal with mmap based systems.&#xA;In practice, however, the situation isn&#x2019;t so clear cut. Until quite recently, the state of asynchronous I/O on Linux was quite iffy. Until the arrival of io_uring, certain operations that you expected to be async would block occasionally, ruining your day. The paper mentions that you can use async I/O to issue I/O requests to load the next pages (non sequentially) from the disk when you are performing certain operations. You can do the same with mmap as well, and RavenDB does just that. When you start a scan on a B&#x2B;Tree, RavenDB will ask the OS to ensure that the memory we are interested in is in memory before we actually get to it. On Linux, this is done with madvise(WILL_NEED) call. That call may be blocking, so we actually have a dedicated thread that is meant to handle such a scenario.&#xA0; In practice, this isn&#x2019;t really that different from how you&#x2019;ll handle it with async I/O.&#xA;Another consideration to deal with is the cost of mapping at the kernel level. I&#x2019;m not talking about the I/O cost, but if you have many threads that are faulting pages, you&#x2019;ll run into problems with the page table lock. We have run into that before, this is considered an OS level bug, but it obviously has an impact on the database. In practice, however, the overhead of memory management is the same in most cases. If you are reading via mmap or allocating directly, you&#x2019;ll need to orchestrate things. Note that the same page table lock is also in effect if you are heavily allocating / freeing, since you&#x2019;re also modifying the process page table.&#xA;Problem #3 &#x2013; Error Handling&#xA;Error handling is a serious concern for a database. The paper points out that databases such as SQL Server may run a checksum when reading data from disk. When you use a buffer pool, the boundary of reading from the disk is obvious and you can easily validate the read from the disk. Voron is using mmap exclusively, and we do have checksums. We validate the page from the disk the first time that we access it (there is an internal bitmap that is used for that).&#xA0; There isn&#x2019;t a big difference between the two anyway. We only check a given page once per run, because to do otherwise is meaningless. When you use read() to get data from the disk, you have no guarantees that the data wasn&#x2019;t fetched from a cache along the way. So you may validate the data you read is &#x201C;correct&#x201D;, while the on disk representation is broken. For that reason, we only do the check once, instead of each time.&#xA;A far greater issue to deal with is I/O errors. What do you do when a read or a write fails? If you are using system calls to manage that, you get a return code and can react accordingly. If you are using mmap, the system will generate a SIGBUS that you&#x2019;ll have to (somehow) handle.&#xA;For a database, dealing with I/O errors has a single correct answer. Crash and then run recovery from scratch. If the I/O system has returned an error, there is no longer any way to know what the state of that is. See: fsync-gate. The only way to recover is to stop, reload everything (apply the WAL, run recovery, etc) and get back into a stable state. SIGBUS isn&#x2019;t my cup of tea with regards to handling this, but error handling for I/O error isn&#x2019;t actually something that you do, so just restarting the process ends up more acceptable than you might initially think.&#xA;Problem #4 &#x2013; Performance issues&#xA;The paper points out three common reasons for performance issues with mmap usage:&#xA;&#xA;page table contention&#xA;single threaded page eviction&#xA;TLB shootdowns&#xA;&#xA;The first issue is something that I have run into in the past. It was a bug in the operating system which was fixed. There is no longer a single page table in both Windows and Linux.&#xA;The single threaded eviction, on the other hand, is something that we never run into. When using Voron, we map the memory using MAP_SHARED, and most of the time, the memory isn&#x2019;t dirty. If the system needs memory, it can do that when it assigns a page by just discarding the memory of an unmodified shared page. In this model, we typically see most of the memory as shared, clean. So there isn&#x2019;t a lot of pressure to evict things, and it can be done on as needed basis.&#xA;The TLB shootdown issue is not something that we ever run into as a problem. We have run TB range databases on Raspberry PI with 4GB of RAM and hammered that in benchmarks (far exceeding the memory capacity). The interesting thing here is that the B&#x2B;Tree nature means that the upper tiers of the tree were already in memory, so we mostly ended up with a single page fault per request. In order to actually observe the cost of TLS Shootdown in a significant manner, you need to have:&#xA;&#xA;really fast I/O&#xA;working set that significantly exceeds memory&#xA;no other work that needs to be done for processing a request&#xA;&#xA;In practice, if you have really fast I/O, you spent money on that, you&#x2019;ll more likely get more RAM as well. And you typically need to do something with the data you read, which means that you won&#x2019;t notice the TLB shootdown as much.&#xA;Finally, going back to how I started this post. This assumes that there are no other costs of not using mmap and using direct IO. The benchmark doesn&#x2019;t account for those extra costs. For example, without mmap, who is doing evictions? In practice, that will lead to the same sort of considerations that you&#x2019;ll have when dealing with mmap. This is especially the case with TLS shootdown when we start talking about high memory traffic (which likely modifies page allocations for the process, leading to the same scenario).&#xA;The paper has been quite interesting to read and it has presented a number of real problems that occur with mmap based systems, but I&#x2019;m afraid that it doesn&#x2019;t present the alternatives properly and vastly underestimates both costs and complexity of not using mmap and writing your own buffer pool.</p>
        </article>
        <article id="article-753">
            <a href="https://ayende.com/blog/196129-C/working-with-market-data-using-time-series-in-ravendb" target="_blank">
                <h2 class="title mb-6" id="article-753">Working With Market Data Using Time Series in RavenDB</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 13, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Kamran Ayub has another great article discussing how to utilize RavenDB to analyze crypto markets data.&#xA;In addition to the article, you can see the full source code for the sample application. There is even a really cool intro video for the application and article:</p>
        </article>
        <article id="article-754">
            <a href="https://ayende.com/blog/196097-C/implementing-a-file-pager-in-zig-reclaiming-memory" target="_blank">
                <h2 class="title mb-6" id="article-754">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 12, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Up to this point, we focused on reading data from the disk, we can do that up to a point. Eventually we&#x2019;ll run out of memory (assuming that the database is bigger than memory, which is a pretty safe assumption). That means that we need to decide what to remove from memory. When we use mmap(), the OS gets to decide that for us. In fact, that is probably the best argument against using mmap(). The additional control we get from knowing how to manage the memory is the chief reason to take the plunge and manage our own memory.&#xA;There are a lot of algorithms around managing memory, I really like this one, because it is quite elegant. However, that requires quite a lot of states to be dealt with, especially when working with highly concurrent systems. Instead, I chose to look at the clock sweep algorithm. This is also implemented by PostgreSQL, and it is actually far simpler to work with. The idea is that for each page, we maintain a usage count. Each time that we need to get a page, we&#x2019;ll increment its usage count (up to a small limit). Each time we need to evict a page, we&#x2019;ll search for a page that can be evicted and has no recent usage. If it has usages, we&#x2019;ll decrement that value and repeat until we find something.&#xA;Our buffer management isn&#x2019;t actually dealing with pages, however. We are working with 2MB chunks, instead. The principal is the same, but using bigger aggregates is advantageous given typical memory sizes these days. The first thing that we need to do is to modify the ChunkMetadata. I&#x2019;m showing only the relevant changes.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;           pub const ChunkMetadata = packed union {&#xA;        &#xA;        &#xA;          &#xA;                  raw: u64,&#xA;        &#xA;        &#xA;          &#xA;                  v: packed struct {&#xA;        &#xA;        &#xA;          &#xA;                      version: u30,&#xA;        &#xA;        &#xA;          &#xA;                      tag: Tag,&#xA;        &#xA;        &#xA;          &#xA;                      references: u29,&#xA;        &#xA;        &#xA;          &#xA;                      usages: u3,      &#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ChunkMetadata.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The major change here is the introduction of the usages field. That is a 3 bits field (0 .. 8 in range) and we reduced the number of references a chunk can have to about 500 million (should be sufficient, I believe). The idea here is that each time that we call addRef(), we&#x2019;ll increment the usages count, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn addRef(self: *ChunkMetadata) !void {&#xA;        &#xA;        &#xA;          &#xA;              comptime var maxReferences = std.math.maxInt(@TypeOf(self.v.references));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (@intCast(u64, self.v.references) &#x2B; 1 &gt; maxReferences) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.ChunkReferenceCountOverflow;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.v.references &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;              self.v.version &#x2B;%= 1;&#xA;        &#xA;        &#xA;          &#xA;              self.v.usages &#x2B;|= 1; // saturating addition&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          addRef.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Zig has a nice feature that I&#x2019;m using here, saturating addition. In other words, if the value is incremented beyond its limit, it is clamped to the limit. That means that I don&#x2019;t have to worry about overflows, etc. I took a look at how this is implemented, and the compiler generates the following assembly for this code (x &#x2B;| 100) :&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;            add     eax, 100&#xA;        &#xA;        &#xA;          &#xA;            mov     ecx, -1&#xA;        &#xA;        &#xA;          &#xA;            cmovb   eax, ecx&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          saturating.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This may look daunting, but I&#x2019;ll break it down. First, we add the 100 to the value, as you can expect (the value is currently in the EAX register). Then we store &#x2013;1 (value of 0xFFFFFFFF) in the ECX register. Finally, we use the CMOV instruction (the CMOVB in the snipper is a variant of CMOV), telling it to store ECX in EAX if the carry flag is set on the last addition instruction. For fun, this also avoids a branch in the code, which is great for performance.&#xA;One of the critical functions that we need to consider here is the behavior of the pager when we are accessing rare pages once, and then never again. A really common scenario is when we are doing a scan of some data for a rare query. For that reason, the usages behavior is a bit more complex than one might imagine. Let&#x2019;s explore this for a bit before moving on. Look at the following code, I marked the important lines with stars:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn markLoaded(self: *FileChunks, chunk: u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; return error.ValueAlreadyExists,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return error.ValueInErrorState,&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; return error.ValueIsNotLoading,&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  copy.setTag(.Value);&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef(); // ownership by the pager&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef(); // ownership by the caller&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;                  // ***********************&#xA;        &#xA;        &#xA;          &#xA;                  copy.setUsagesFrom(origin);&#xA;        &#xA;        &#xA;          &#xA;                  // ***********************&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      return self.getLoadedChunk(chunk);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn trySetToEmpty(self: *FileChunks, index: u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var modified = self.chunks[index];&#xA;        &#xA;        &#xA;          &#xA;                  if (modified.getTag() != .Loading) {&#xA;        &#xA;        &#xA;          &#xA;                      // someone else modified it while we where releasing the memory&#xA;        &#xA;        &#xA;          &#xA;                      return error.ValueIsNotLoading;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var released = modified.reset(.Empty);&#xA;        &#xA;        &#xA;          &#xA;                  // ***********************&#xA;        &#xA;        &#xA;          &#xA;                  released.setUsages(1); // next time we load the chunk, we&#x27;ll know to keep it around&#xA;        &#xA;        &#xA;          &#xA;                  // ***********************&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[index].tryUpdate(modified, released))&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usages.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;When we mark a chunk as loaded, we copy the usages from the current record. That starts out as zero, so for the scenario of accessing rare pages, we&#x2019;ll have a good reason to evict them soon. However, there is a twist, when we remove a chunk from memory, we also set its usage count to 1. That is an interesting issue. The chunk is not loaded, why does it have a usage count? That is because if we removed it from memory, and we load it again, we want it to start with a higher usage count (and less chance to be evicted). In this manner, we are somewhat simulating the 2Q algorithm.&#xA;Now, let&#x2019;s take a look at the actual reclaiming portion, shall we? In the chunk metadata, we have the following behavior:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const RelciamOptions = enum {&#xA;        &#xA;        &#xA;          &#xA;              None,&#xA;        &#xA;        &#xA;          &#xA;              ReduceUsages,&#xA;        &#xA;        &#xA;          &#xA;              Reclaim,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn reclaim(self: *ChunkMetadata) RelciamOptions {&#xA;        &#xA;        &#xA;          &#xA;              switch (self.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                  .Value =&gt; {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.v.references == 1) {&#xA;        &#xA;        &#xA;          &#xA;                          return .Reclaim;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;                  .Empty =&gt; {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.v.usages &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return .ReduceUsages;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;                  else =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return .None;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn reduceUsages(self: *ChunkMetadata) ChunkMetadata {&#xA;        &#xA;        &#xA;          &#xA;              return ChunkMetadata{ .v = .{&#xA;        &#xA;        &#xA;          &#xA;                  .tag = self.v.tag,&#xA;        &#xA;        &#xA;          &#xA;                  .version = self.v.version &#x2B;% 1,&#xA;        &#xA;        &#xA;          &#xA;                  .references = self.v.references,&#xA;        &#xA;        &#xA;          &#xA;                  .usages = self.v.usages -| 1,&#xA;        &#xA;        &#xA;          &#xA;              } };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ChunkMetadata.usages.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;If we have a value and no outstanding references, we can reclaim it, if we don&#x2019;t have a value, we&#x2019;ll reduce the usage count anyway. The idea is that when we unload a page, we&#x2019;ll set the usages count to 1. The usage counter of an unloaded page will reset this as time goes by, so if there has been a sweep on an empty chunk that has a usage count, we&#x2019;ll not count that for the next time we load it. Basically, after unloading a chunk, if we reload it soonish, we&#x2019;ll keep it around longer the next time. But if it is only rarely loaded, we don&#x2019;t care and will forget that it was loaded previously.&#xA;The process for actually reclaiming a chunk is shown here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn tryReclaimChunk(self: *FileChunks, result: *ReclaimResult) bool {&#xA;        &#xA;        &#xA;          &#xA;              var index = result.lastScannedIndex;&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[index];&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.reclaim()) {&#xA;        &#xA;        &#xA;          &#xA;                      .None =&gt; return false,&#xA;        &#xA;        &#xA;          &#xA;                      .ReduceUsages =&gt; {&#xA;        &#xA;        &#xA;          &#xA;                          var modified = copy.reduceUsages();&#xA;        &#xA;        &#xA;          &#xA;                          if (self.chunks[index].tryUpdate(copy, modified))&#xA;        &#xA;        &#xA;          &#xA;                              return false;&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      },&#xA;        &#xA;        &#xA;          &#xA;                      .Reclaim =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  result.hasCandidates = true;&#xA;        &#xA;        &#xA;          &#xA;                  var modified = copy.reduceUsages();&#xA;        &#xA;        &#xA;          &#xA;                  if (modified.hasUsages()) {&#xA;        &#xA;        &#xA;          &#xA;                      // update the reduced usage&#xA;        &#xA;        &#xA;          &#xA;                      if (self.chunks[index].tryUpdate(copy, modified))&#xA;        &#xA;        &#xA;          &#xA;                          return false;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  modified = copy.reset(.Loading); // means that we own it for the duration...&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[index].tryUpdate(copy, modified))&#xA;        &#xA;        &#xA;          &#xA;                      return true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          tryReclaimChunk.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We look at a particular index in the chunks, and check if we can claim that. Following out previous behavior, there are a bunch of options here. We can either have an empty chunk that remembers the previous usage, which we can reduce, or we can actually try to reclaim the chunk. Of course, that isn&#x2019;t that simple, because even if we found a candidate for reclaiming, we still need to reduce its usages count. Only if it has no usages will we be able to actually start the removal process. Finally, we have the actual scanning of the chunks in the file, shown here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const ReclaimResult = struct {&#xA;        &#xA;        &#xA;          &#xA;              lastScannedIndex: u64 = 0,&#xA;        &#xA;        &#xA;          &#xA;              reclaimed: bool = false,&#xA;        &#xA;        &#xA;          &#xA;              hasCandidates: bool = false,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn reclaim(&#xA;        &#xA;        &#xA;          &#xA;              self: *FileChunks,&#xA;        &#xA;        &#xA;          &#xA;              startIndex: u64,&#xA;        &#xA;        &#xA;          &#xA;          ) !ReclaimResult {&#xA;        &#xA;        &#xA;          &#xA;              var result = ReclaimResult{ .lastScannedIndex = if (startIndex &lt; self.chunks.len) startIndex else 0 };&#xA;        &#xA;        &#xA;          &#xA;              while (result.lastScannedIndex &lt; self.chunks.len) : (result.lastScannedIndex &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  if (self.tryReclaimChunk(&amp;result) == false)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  // at this point, the current chunk is owned by us, and no one else can use it...&#xA;        &#xA;        &#xA;          &#xA;                  result.reclaimedBytes &#x2B;= ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                  _ = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;                      self.getLoadedChunk(result.lastScannedIndex).ptr,&#xA;        &#xA;        &#xA;          &#xA;                      ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                      os.PROT.NONE,&#xA;        &#xA;        &#xA;          &#xA;                      os.MAP.ANONYMOUS | os.MAP.PRIVATE | os.MAP.FIXED,&#xA;        &#xA;        &#xA;          &#xA;                      -1,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.trySetToEmpty(result.lastScannedIndex);&#xA;        &#xA;        &#xA;          &#xA;                  result.reclaimed = true;&#xA;        &#xA;        &#xA;          &#xA;                  result.lastScannedIndex &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return result;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          reclaim.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We scan the file from the provided start index and try to reclaim each chunk in turn. That may reduce the usages count, as we previously discussed. The actual process will continue until we have found a chunk to reclaim. Note that we are always claiming just a single chunk and return. This is because the process is repeatable. We start from a given index and we return the last index that we scanned. If the caller needs to free more than a single chunk, they can call us again, passing the last index that we scanned.&#xA;That is why this is called the clock sweep algorithm. We are sweeping through the chunks that we have in the system, reaping them as needed. The code so far is all in the same FileChunks instance, but the Pager actually deals with multiple files. How would that work? We start by adding some configuration options to the pager, telling us how much memory we are allowed to use:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const Options = struct {&#xA;        &#xA;        &#xA;          &#xA;              capacity: usize = 0,&#xA;        &#xA;        &#xA;          &#xA;              hardMemoryLimit: usize = 0,&#xA;        &#xA;        &#xA;          &#xA;              softMemoryLimit: usize = 0,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Options.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We have both soft and hard limits here, because we want to give the users the ability to say &#x201C;don&#x2019;t use too much memory, unless you really have to&#x201D;.&#xA0; The problem is that otherwise, users get nervous when they see 99% memory being used and want to keep some free. The point of soft and hard limits is that this gives us more flexibility, rather than setting a lower than needed limit and getting memory errors with GBs of RAM to spare.&#xA;In the Pager, we have the loadChunksToTransaction() that we looked at in the previous post. That is where we read the chunk from the file. We are going to modify this method so will reserve the memory budget before we actually allocate it, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              try self.reserveMemoryBudgetForChunk();&#xA;        &#xA;        &#xA;          &#xA;              errdefer self.releaseChunkMemoryBudget();&#xA;        &#xA;        &#xA;          &#xA;              // if null, someone else is loading...&#xA;        &#xA;        &#xA;          &#xA;              maybeBuffer = file.chunks.markLoading(chunkInFile) catch |err| switch (err) {&#xA;        &#xA;        &#xA;          &#xA;                  error.ValueAlreadyExists =&gt; continue, // someone else is loading...&#xA;        &#xA;        &#xA;          &#xA;                  else =&gt; return err,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          loadChunksToTransaction.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we reserve the memory budget, then actually allocate the memory (inside markLoading()). If there is a failure, we release the budget allocation and report the error. To manage the memory budget, we need to add a few fields to the Pager:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          options: Options,&#xA;        &#xA;        &#xA;          &#xA;          usedMemory: std.atomic.Atomic(u64),&#xA;        &#xA;        &#xA;          &#xA;          filesRelcaimSweeps: [8]std.atomic.Atomic(u64),&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn releaseChunkMemoryBudget(self: *Pager) void {&#xA;        &#xA;        &#xA;          &#xA;               _ = self.usedMemory.fetchSub(FileChunks.ChunkSize, .Release);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Pager.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;You can see that releaseChunkMemoryBudget() is pretty trivial. Simply release the memory budget and move on. Things are a lot more complex when we need to reserve memory budget, however. Before we dive into this, I want to talk a bit about the filesRelcaimSweeps field. That is an interesting one. This is where we&#x2019;ll keep the last position that we scanned in the Pager (across all pages). However, why is that an array?&#xA;The answer is simple. The Pager struct is meant to be used from multiple threads at the same time. Under memory pressure, we are likely to need to evict multiple chunks at once. In order to avoid multiple threads scanning the same range of the Pager to find chunks to remove, I decided that we&#x2019;ll instead have several sweeps at the same time. On startup, we&#x2019;ll initialize them to a random initial value, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var rnd = std.rand.DefaultPrng.init(@bitCast(u64, std.time.timestamp()));&#xA;        &#xA;        &#xA;          &#xA;          for (self.filesRelcaimSweeps) |*it| {&#xA;        &#xA;        &#xA;          &#xA;              rnd.fill(std.mem.asBytes(it));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In this manner, under load, each thread is likely to scan an independent portion of the Pager&#x2019;s memory, which should avoiding competing on the same memory to evict. And with that behind us, let&#x2019;s see how we can actually use this to evict memory:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn reserveMemoryBudgetForChunk(self: *Pager) !void {&#xA;        &#xA;        &#xA;          &#xA;              // optimistically increment...&#xA;        &#xA;        &#xA;          &#xA;              if (self.usedMemory.fetchAdd(FileChunks.ChunkSize, .Release) &lt; self.options.softMemoryLimit) {&#xA;        &#xA;        &#xA;          &#xA;                  // simplest scenario&#xA;        &#xA;        &#xA;          &#xA;                  return;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // we are *too* high, reduce the optimistic increment...&#xA;        &#xA;        &#xA;          &#xA;              _ = self.usedMemory.fetchSub(FileChunks.ChunkSize, .Release);&#xA;        &#xA;        &#xA;          &#xA;              // we need to release some memory...&#xA;        &#xA;        &#xA;          &#xA;              var pos = std.Thread.getCurrentId() % self.filesRelcaimSweeps.len;&#xA;        &#xA;        &#xA;          &#xA;              var scanStartIndex = self.filesRelcaimSweeps[pos].load(.Acquire) % (self.files.len * FileChunks.ChunksInFile);&#xA;        &#xA;        &#xA;          &#xA;              var hasCandidates = true;&#xA;        &#xA;        &#xA;          &#xA;              while (hasCandidates) {&#xA;        &#xA;        &#xA;          &#xA;                  hasCandidates = false;&#xA;        &#xA;        &#xA;          &#xA;                  var fileIdx = scanStartIndex / FileChunks.ChunksInFile;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.files[fileIdx]) |file| {&#xA;        &#xA;        &#xA;          &#xA;                      var chunkInFile = scanStartIndex % FileChunks.ChunksInFile;&#xA;        &#xA;        &#xA;          &#xA;                      var result = try file.chunks.reclaim(chunkInFile);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      _ = self.filesRelcaimSweeps[pos].fetchAdd(&#xA;        &#xA;        &#xA;          &#xA;                          // update the location of the _next_ scan&#xA;        &#xA;        &#xA;          &#xA;                          (result.lastScannedIndex - chunkInFile) &#x2B; 1,&#xA;        &#xA;        &#xA;          &#xA;                          .Release,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (result.reclaimed) {&#xA;        &#xA;        &#xA;          &#xA;                          // we released a chunk (and reserved it too, so usedMemory remains the same)&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (result.hasCandidates)&#xA;        &#xA;        &#xA;          &#xA;                          hasCandidates = true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  // still searching, move to the next file&#xA;        &#xA;        &#xA;          &#xA;                  scanStartIndex = (scanStartIndex / FileChunks.ChunksInFile) * FileChunks.ChunksInFile &#x2B; FileChunks.ChunksInFile;&#xA;        &#xA;        &#xA;          &#xA;                  _ = self.filesRelcaimSweeps[pos].fetchAdd(&#xA;        &#xA;        &#xA;          &#xA;                      FileChunks.ChunksInFile - (scanStartIndex % FileChunks.ChunksInFile), // move to next file...&#xA;        &#xA;        &#xA;          &#xA;                      .Release,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // if we are here, we couldn&#x27;t release any chunks&#xA;        &#xA;        &#xA;          &#xA;              var currentMem = self.usedMemory.load(.Acquire) &#x2B; FileChunks.ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;              if (currentMem &gt; self.options.hardMemoryLimit) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.OutOfMemoryBudget;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // we are higher than the soft limit, but still okay...&#xA;        &#xA;        &#xA;          &#xA;              _ = self.usedMemory.fetchAdd(FileChunks.ChunkSize, .Release);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          reserveMemoryBudgetForChunk.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is a lot of code here, and quite a few comments, because this is choke-full of behavior. Let&#x2019;s dissect this in detail:&#xA;We start by checking the memory budget and see if we are below the soft memory limits. We are doing this optimistically, but if we fail, we reset the state and then start to scan the Pager for chunks we can release. We do that by accessing one of the filesRelcaimSweeps values using the current thread id. In this way, different threads are likely to use different values and move them independently.&#xA;We find the relevant file for the index and start scanning for chunks to release. We&#x2019;ll stop the process when one of the following will happen:&#xA;&#xA;We released a chunk, in which case we are successful and can return with glory.&#xA;We didn&#x2019;t find a chunk, but found candidates (whose usage count is too high to discard).&#xA;&#xA;In the case of the second option, we&#x2019;ll look for better options before getting back to them and discarding them.&#xA;If we are completely unable to find anything to release, we&#x2019;ll check if we exceed the hard memory limit and error, or just accept the soft limit as, well&#x2026; soft limit and allocate the budget anyway.&#xA;This happens as part of the process for loading chunks in the pager, so we&#x2019;ll only need to release a single chunk at a time. For that reason, we remember the state so the next operation will start from where we left off. You can think about this as a giant set of hands that are scanning the range of chunks in memory as needed.&#xA;There are actually a few things that we can implement that would make this faster. For example, we always scan through all the chunks in a file. We could try to maintain some data structure that will tell us which pages have usage count to consider, but that is actually complex (remember, we are concurrent). There is also another factor to consider. The ChunkMetdata is 64 bits in size, and a FilesChunk struct contains an array of 4096 such values, totaling 32KB in size. It is actually cheaper to scan through the entire array and do the relevant computation on each candidate than try to be smart about it.&#xA;I think that this is it for now, this post has certainly gone for quite a while. In the next post in the series, I want to tackle writes. So far we only looked at reads, but I think we have all the relevant infrastructure at hand already, so this should be simpler.</p>
        </article>
        <article id="article-755">
            <a href="https://ardalis.com/datetime-as-a-value-object/" target="_blank">
                <h2 class="title mb-6" id="article-755">DateTime as a Value Object</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 12, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Value Objects are a key part of Domain-Driven Design and domain models created by this process. However, they&#x27;re not used nearly as often by&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-756">
            <a href="https://ayende.com/blog/196066-C/implementing-a-file-pager-in-zig-reading-from-the-disk" target="_blank">
                <h2 class="title mb-6" id="article-756">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 11, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We have finally gotten to the point where we can ask the pager for a page of data (reminder, a page in this case is 8KB of data) and get it back. Here is what this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var page = try pager.getPage(&amp;tx.loadedChuncks, 2, 1, tx.timeout);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There are a few things to note here. There is a new concept here, the transaction. We don&#x2019;t want to have that concept at the pager level, so we just pass the relevant state to the pager to deal with. Basically, any transaction we&#x2019;ll have will need to have a bit of state for the pager to deal with it. The state we need at this point is minimal, just the list of chunks that are referenced by the pager. You can also see that we provide a timeout for the getPage() call. What is that about?&#xA;This leads to the second concern we need to consider. How are we expected to run this? If we call getPage() on a page (actually, a chunk containing this page) that isn&#x2019;t resident in memory, we&#x2019;ll need to go to the disk to read it. That can take a while, sometimes a long while. At a glance, that is one of those things that async/await was meant for. Since Zig supports async functions, that is certainly something that we can do, but it is something that I want to be cautious about. Having explicit blocking is far easier to understand and debug, at least for now. This is especially true if we&#x2019;ll want to consume the pager API from a non Zig target.&#xA;That leads to an interesting issue, however. If a call to getPage() can block, how can we avoid blocking the thread. In most cases, we would like to avoid blocking, after all. It would be simple to have tryGetPage() method, which will not block (but schedule the load of the page from disk), and then maybe register for a notification for that. If that sounds like async to you, that is because it is. The problem with this sort of approach is that you need to suspend execution somewhere in the middle of a transaction operation and continue when the data is loaded. Without async/await, you can&#x2019;t really do that. Well, I mean, you could try, but we have a lot of experience with trying to manage state via callbacks, that isn&#x2019;t really going to work for anything beyond the simplest systems (see: node.js without async/await).&#xA;There is one thing that we can do that would be both simple and effective, however: we can error if the page isn&#x2019;t in memory. That sounds like a pretty bad idea, no? How would that help us?&#xA;Well, the concept is simple. If a transaction attempts to access a page that isn&#x2019;t resident in memory, we&#x2019;ll do the following operations:&#xA;&#xA;Schedule the chunk the page resides on to load into memory.&#xA;Return an error from the pager&#xA;Rollback the transaction&#xA;Keep the loadedChunks for that transaction active and wait for the chunk to be loaded&#xA;Re-run the transaction again, now the chunk is in memory and we can proceed further&#xA;&#xA;Each time that we re-run the transaction, we make sure that the chunks it needs are in memory, eventually ensuring that all the required chunks are resident and we don&#x2019;t need to block.&#xA;At the same time, the code to work with the transactions is not going to care about blocking, etc. We need to do the usual error handling, but that is required anyway. There is a single location where we need to deal with callbacks from the pager, so there is a limited blast radius of complexity. For write transactions, for example, this is a very reasonable strategy. We assume that there is only a single thread writing at a given time. A transaction being blocked because it needs to read a page from the disk can stall other pending transactions. By having it abort and retry later, we can keep the line moving. For read operations, on the other hand, that is likely not something that you want to do. If I&#x2019;m already streaming results to the caller, I can&#x2019;t just repeat the transaction.&#xA;I&#x2019;m not making any decisions at this point, just considering the various options and implications that we have to deal with at this early level.&#xA;Now, let&#x2019;s look at how the getPage() is actually implemented, shall we?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn getPage(self: *Pager, loadedChunks: *ChunksSet, page: u64, count: u32, timeout: ?u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              var chunk = page / FileChunks.PagesInChunk;&#xA;        &#xA;        &#xA;          &#xA;              var end = (page &#x2B; count) / FileChunks.PagesInChunk;&#xA;        &#xA;        &#xA;          &#xA;              // we ensure that any range is always within a single file...&#xA;        &#xA;        &#xA;          &#xA;              // we ensure that any range is always within a single file...&#xA;        &#xA;        &#xA;          &#xA;              var fileNum = page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              var file = self.files[fileNum] orelse return error.FileIsNotLoaded;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.loadChunksToTransaction(loadedChunks, file, chunk, end, timeout);&#xA;        &#xA;        &#xA;          &#xA;              if (loadedChunks.get(chunk) != null) {&#xA;        &#xA;        &#xA;          &#xA;                  // explicitly go beyond the scope of the chunk, because we know the proper memory layout&#xA;        &#xA;        &#xA;          &#xA;                  // and if the size exceed a single chunk, we already loaded the next one(s)&#xA;        &#xA;        &#xA;          &#xA;                  var ptr = file.chunks.ptr.ptr;&#xA;        &#xA;        &#xA;          &#xA;                  var pageInFile = page % FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (@ptrToInt(ptr &#x2B; ((pageInFile &#x2B; count) * FileChunks.PageSize)) &gt; file.chunks.ptrEnd) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.PageRequestIsOutOfBand;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var slice = ptr[(pageInFile * FileChunks.PageSize)..((pageInFile &#x2B; count) * FileChunks.PageSize)];&#xA;        &#xA;        &#xA;          &#xA;                  return slice;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return error.ChunkWasNotLoaded;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getPage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is a lot that is going on here, I know. We start by defining a set (a hash map using a 64 bits unsigned integer to a zero-sized value). The way this works with Zig is quite elegant, since we pay no memory cost for the values here.&#xA;The majority of the work is done in the loadChunksToTransaction() function, which we&#x2019;ll examine shortly, but you can see some interesting details already in getPage(). We assume that we have a page loaded, and any range of pages that we ask is always within a single page.&#xA;The call to load the chunks actually puts them in the loadedChuncks argument. We verify that we loaded the chunk properly and then we create a slice to return for the caller. Note that we may request more than a single page and it is valid to ask for a range that contains multiple chunks. We validate that the range we return is within the memory range for the current file, we ensured that the chunks for a specific file are consecutive in memory, so we can safely return this pointer across multiple chunks without needing to think about it.&#xA;There is another aspect of loadedChunks that we need to discuss. A transaction may use multiple pages from the same chunk, but we only need to load the chunk once. At the same time, we can avoid adding a reference to the chunk multiple times for each loaded page. When we close the transaction, we need to release the reference for these chunks, so we need to keep track of those. With that in mind, let&#x2019;s see how we actually load the chunks to memory.&#xA;As a reminder, we have two actors working together here. The FileChunks is used to store the chunks in memory and the PagerRing is used for parallel I/O.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn scheduleLoadingChunks(self: *Pager, loadedChunks: *ChunksSet, file: *PagerFile, start: u64, end: u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              while (start &lt;= end) : (start &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  if (loadedChunks.get(start) != null) {&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var chunkInFile = (start % FileChunks.ChunksInFile);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var maybeBuffer = file.chunks.tryGet(chunkInFile) catch |err| switch (err) {&#xA;        &#xA;        &#xA;          &#xA;                      error.ValueIsLoading =&gt; continue, // someone else is loading this, will get later&#xA;        &#xA;        &#xA;          &#xA;                      else =&gt; return err,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  if (maybeBuffer != null) {&#xA;        &#xA;        &#xA;          &#xA;                      // a buffer exists, and we own a ref to it now, record it...&#xA;        &#xA;        &#xA;          &#xA;                      try recordChunk(file, loadedChunks, start);&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      try self.reserveMemoryBudgetForChunk();&#xA;        &#xA;        &#xA;          &#xA;                      errdefer self.releaseChunkMemoryBudget();&#xA;        &#xA;        &#xA;          &#xA;                      // if null, someone else is loading...&#xA;        &#xA;        &#xA;          &#xA;                      maybeBuffer = file.chunks.markLoading(chunkInFile) catch |err| switch (err) {&#xA;        &#xA;        &#xA;          &#xA;                          error.ValueAlreadyExists =&gt; continue, // someone else is loading...&#xA;        &#xA;        &#xA;          &#xA;                          else =&gt; return err,&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (maybeBuffer) |buffer| {&#xA;        &#xA;        &#xA;          &#xA;                      // now need to load it...&#xA;        &#xA;        &#xA;          &#xA;                      var state = try self.allocator.create(AsyncLoadChunkState);&#xA;        &#xA;        &#xA;          &#xA;                      errdefer self.allocator.destroy(state);&#xA;        &#xA;        &#xA;          &#xA;                      state.* = .{ .chunk = chunkInFile, .file = file, .parent = self };&#xA;        &#xA;        &#xA;          &#xA;                      try self.ring.submit(.{&#xA;        &#xA;        &#xA;          &#xA;                          .tag = .Read,&#xA;        &#xA;        &#xA;          &#xA;                          .fd = file.fd,&#xA;        &#xA;        &#xA;          &#xA;                          .buffer = buffer,&#xA;        &#xA;        &#xA;          &#xA;                          .offset = chunkInFile * FileChunks.ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                          .context = @ptrToInt(state),&#xA;        &#xA;        &#xA;          &#xA;                          .result = .{ .bytes = 0, .err = null },&#xA;        &#xA;        &#xA;          &#xA;                          .callback = completeLoad,&#xA;        &#xA;        &#xA;          &#xA;                      });&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn loadChunksToTransaction(self: *Pager, loadedChunks: *ChunksSet, file: *PagerFile, start: u64, end: u64, timeout: ?u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              try self.scheduleLoadingChunks(loadedChunks, file, start, end);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // now we actually load the chunks to the transaction&#xA;        &#xA;        &#xA;          &#xA;              var currentGlobalChunk = start;&#xA;        &#xA;        &#xA;          &#xA;              while (currentGlobalChunk &lt;= end) : (currentGlobalChunk &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  if (loadedChunks.get(currentGlobalChunk) != null) {&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var chunkInFile = (currentGlobalChunk % FileChunks.ChunksInFile);&#xA;        &#xA;        &#xA;          &#xA;                  // we&#x27;ll wait until we have the buffer&#xA;        &#xA;        &#xA;          &#xA;                  _ = try file.chunks.getBlocking(chunkInFile, timeout);&#xA;        &#xA;        &#xA;          &#xA;                  try recordChunk(file, loadedChunks, currentGlobalChunk);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          loadChunksToTransaction.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;That is a lot of code to throw at you, I know, let&#x2019;s dissect it in detail. In this method, we are working on chunks, not pages, and we assume that we may have multiple chunks, that is why we have the while loops. We start by checking if the chunk is already loaded in the transactions&#x2019; loadedChunks. If it isn&#x2019;t, we compute the position of the chunk in the file (the chunk number we get from the caller is the global one, after all) and try to get it from the FileChunks. This is where things get interesting.&#xA0; When we call tryGet() for the current chunk, we may get an error because of two possible scenarios:&#xA;&#xA;The value is currently being loaded from the disk (some other transaction asked for it, probably). We don&#x2019;t need to do anything further other than wait for it to show up.&#xA;Another transaction tried to load it, but got an error. At this point we just return the error. We don&#x2019;t try to do anything special here. In general, there may be a lot of errors to consider here. We may have temporary I/O issue, or run out of memory or something that is transient. Or we may have an actual problem at hand (bad sector on disk, corrupted data, etc). Regardless of what we are doing, we aren&#x2019;t going to try to do any error handling here. We&#x2019;ll just record the error and any future attempt to access that chunk will also error. The proper way to recover at this point is to restart the pager. This is assuming we have the other components of a database at play here. So we&#x2019;ll re-run the journal files, apply recovery, etc. In short, any I/O issues like that are critical errors and require a restart of the system to come back to a known state.&#xA;&#xA;If the tryGet() method returned without an error, there are still two options to consider. The call may have returned a value (so we called addRef() on the chunk internally), we can simply add that to the chunks we own and move on. If there isn&#x2019;t a value in memory, things start to get interesting. At this point we call markLoading(). We are basically racing to be the owners for loading this chunk. If we are successful in this race, we&#x2019;ll get the buffer back from the FileChunks and can schedule reading the relevant chunk from the disk. You&#x2019;ll note that we are setting the callback to completeLoad, we&#x2019;ll look into that shortly. If we aren&#x2019;t successful (we didn&#x2019;t get a buffer back), then some other thread was able to get the buffer and will schedule the read for us, so we are done.&#xA;After we either ensured that all the chunks are loaded or scheduled them to be loaded, we use getBlocking() to wait for all the relevant chunks to be available. Once that is done, we can safely return and getPage() will complete the process, as we saw earlier.&#xA;The only thing that we have to look at is the completeLoad function, which is about as basic as you can get:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn completeLoad(work: *PagerRing.Work) void {&#xA;        &#xA;        &#xA;          &#xA;              var state = @intToPtr(*AsyncLoadChunkState, work.context);&#xA;        &#xA;        &#xA;          &#xA;              defer state.parent.allocator.destroy(state);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var err: ?anyerror = null;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (work.result.err) |e| {&#xA;        &#xA;        &#xA;          &#xA;                  state.file.chunks.markLoadError(state.chunk, e) catch |e2| {&#xA;        &#xA;        &#xA;          &#xA;                      err = e2;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              } else {&#xA;        &#xA;        &#xA;          &#xA;                  _ = state.file.chunks.markLoaded(state.chunk) catch |e3| {&#xA;        &#xA;        &#xA;          &#xA;                      err = e3;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (err) |e| {&#xA;        &#xA;        &#xA;          &#xA;                  std.log.err(&quot;Ownership violation for chunk: {}, file: {}.&quot; &#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                      &quot; Got error: {} when handling state {} &quot;, .{&#xA;        &#xA;        &#xA;          &#xA;                      state.chunk,&#xA;        &#xA;        &#xA;          &#xA;                      state.file,&#xA;        &#xA;        &#xA;          &#xA;                      e,&#xA;        &#xA;        &#xA;          &#xA;                      work.result.err,&#xA;        &#xA;        &#xA;          &#xA;                  });&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          completeLoad.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Most of the function is about error handling. We register either the fact that we got an error reading from the disk or that we completed the load process and maybe log something. In general, there isn&#x2019;t really much that we need to do here. The act of calling markLoaded() will release any threads waiting on getBlocking(), after all. So the whole thing comes together quite nicely.&#xA;With this done, we are mostly done on the reading side of the pager and this post as well. In my next post, I want to discuss how we should handle eviction of data. So far, we are just reading into memory, never releasing. We need to take care of that as well, of course. Once that is done, we can move to the wonderful topic of handling writes and durability&#x2026;</p>
        </article>
        <article id="article-757">
            <a href="https://ardalis.com/2021-year-in-review/" target="_blank">
                <h2 class="title mb-6" id="article-757">2021 Year in Review</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 11, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Time for a recap of stats and important (and not so important) milestones from 2021, the SECOND year of the COVID-19 pandemic (yeah we&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-758">
            <a href="https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/" target="_blank">
                <h2 class="title mb-6" id="article-758">Finding a type declaration&#x27;s namespace and type hierarchy</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 11, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 5</p>
        </article>
        <article id="article-759">
            <a href="https://ayende.com/blog/196065-C/implementing-a-file-pager-in-zig-managing-the-list-of-files" target="_blank">
                <h2 class="title mb-6" id="article-759">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 10, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This is my 7th post in this series, and we are now starting to get into the really interesting bits. So far we worked with the individual components, each of them doing just one thing, which makes it hard to see how they are all put together. In this post, we are going to start plugging things together.&#xA;As a reminder, the whole point of this series of posts is to explore what we need to do in order to ask for a page (8KB, in our case) from the data file and work with it in memory.&#xA0; We have most of everything ready, let&#x2019;s put them back together. The first thing that we need to do is actually tie a file to the FileChunks structure that we previously created. This is as simple as this structure:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const PagerFile = struct {&#xA;        &#xA;        &#xA;          &#xA;              chunks: *FileChunks,&#xA;        &#xA;        &#xA;          &#xA;              fd: std.os.fd_t,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn init(allocator: std.mem.Allocator, file: []const u8) !PagerFile {&#xA;        &#xA;        &#xA;          &#xA;                  var chunks = try FileChunks.init(allocator);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer chunks.deinit();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var fd = try std.os.open(&#xA;        &#xA;        &#xA;          &#xA;                      file,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.O.RDWR | std.os.O.CREAT | std.os.O.CLOEXEC | std.os.O.DIRECT | std.os.O.DSYNC,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.S.IRUSR | std.os.S.IWUSR,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return PagerFile{&#xA;        &#xA;        &#xA;          &#xA;                      .chunks = chunks,&#xA;        &#xA;        &#xA;          &#xA;                      .fd = fd,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn deinit(self: *PagerFile) void {&#xA;        &#xA;        &#xA;          &#xA;                  self.chunks.deinit();&#xA;        &#xA;        &#xA;          &#xA;                  std.os.close(self.fd);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PagerFile.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We are simply initializing the FileChunks and opening the file, nothing else. Remember that a single pager is going to be responsible for multiple files. Furthermore, all the data structures that we are dealing with now are meant for concurrent use. That means that we should be prepared for this type of code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // on thread #1&#xA;        &#xA;        &#xA;          &#xA;          try pager.addFile(&quot;/data/orders/data.003&quot;);&#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;          // on thread #2&#xA;        &#xA;        &#xA;          &#xA;          try pager.getPage(&amp;tx.owned,2034, 32, 15 * std.time.us_in_s);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          concurrent.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;When we use a managed language, that is actually fairly simple to work with. In an unmanaged language, those two lines of code are tough. Why is that? Let&#x2019;s look at the raw data members for the Pager structure, shall we?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const Pager = struct {&#xA;        &#xA;        &#xA;          &#xA;              allocator: std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;              ring: *PagerRing,&#xA;        &#xA;        &#xA;          &#xA;              files: []PagerFile,&#xA;        &#xA;        &#xA;          &#xA;              filesCapacity: usize,&#xA;        &#xA;        &#xA;          &#xA;              pendingFree: PagerFileList,&#xA;        &#xA;        &#xA;          &#xA;              const PagerFileList = std.ArrayListUnmanaged([]PagerFile);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Pager.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Of particular interest to us is the files member. This is the list of files that are being managed by the pager. Each one of them has a maximum size of 8GB in size. The problem is that we may have one thread accessing the list at the same time that another thread wants to increase its size. How would that work?&#xA;The simplest option is that we&#x2019;ll reallocate the array, but that will move it. What would the first thread be doing in that scenario? The good thing from our point of view is that we don&#x2019;t need to worry about concurrent modifications. There is only a single thread that is allowed to modify the Pager&#x2019;s state at any given point in time.&#xA;Trying to find solutions for this problem leads into a rabid rabbit&#x2019;s hole. You go into hazard pointers, epoch GC and other fun stuff. Also, the call to getPage() is one of the most important ones in a database, anything that we can do to reduce its cost will be done. As such, we can&#x2019;t typically use any form of locking. A reader/writer lock can be a killer. Here is a good example for how that can happen.&#xA;I thought about how to resolve this, and I decided against a generic solution, instead, let&#x2019;s look at the actual behavior that we need. The files array is going to be accessed a lot, it has an entry per 8GB of disk space that we take. That means that it isn&#x2019;t going to be experiencing any rapid growth. It is also only going to grow. We also need to worry only when we grow the physical backing store for this array, if we overprovision and use less than we need, that is perfectly fine. Each element in the array is 8 bytes in size, so if we allocate a single memory page (4KB) we can store 512 file references in it. That represents 4 TB(!) of data, so we can probably just accept the additional cost and allocate it and not think about it.&#xA;Databases with &gt; 4TB of disk size do exist, and we don&#x2019;t want to have this artificial limit on us, do we? Instead, we can use another approach. We&#x2019;ll start by allocating the array with a minimum size of 8 elements (sufficient until you get to 64GB). But what happens when we reach that size?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn addFile(self: *Pager, file: []const u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              // caller holds a write lock, we don&#x27;t care about readers, they can follow&#xA;        &#xA;        &#xA;          &#xA;              // either new or old pointers and are guarantee to only access the old range&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (self.files.len &#x2B; 1 &gt;= self.filesCapacity) {&#xA;        &#xA;        &#xA;          &#xA;                  var nextCapacity = self.filesCapacity * 2;&#xA;        &#xA;        &#xA;          &#xA;                  var newFiles = try self.allocator.alloc(PagerFile, nextCapacity);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer self.allocator.free(newFiles);&#xA;        &#xA;        &#xA;          &#xA;                  try self.pendingFree.append(self.allocator, newFiles);&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(PagerFile, newFiles, self.files);&#xA;        &#xA;        &#xA;          &#xA;                  self.files.ptr = newFiles.ptr;&#xA;        &#xA;        &#xA;          &#xA;                  self.filesCapacity = nextCapacity;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var cur = self.files.len;&#xA;        &#xA;        &#xA;          &#xA;              self.files.len &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;              self.files[cur] = try PagerFile.init(self.allocator, file);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          addFile.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What we do here is cheat. We don&#x2019;t need to free the memory immediately, when we reach the limit of the size of the array, we&#x2019;ll double its size, copy the data that we have and register it to be freed when we close the Pager. At that point, the caller already needs to ensure that there are no other users of the pager.&#xA;Because we copy the values from the old array, but keep it around, old readers may use the old or new arrays, but we don&#x2019;t actually care. The memory remains valid and accessible. In terms of wasted space, if our database went from a single file to being 128 TB in one run, we&#x2019;ll have an array with 16,384 elements (whose size is 128KB). Along the way, we had to double the size of the array a dozen times and we &#x201C;waste&#x201D; 128KB of unused buffers. This seems like a pretty reasonable cost to significantly reduce the level of complexity of concurrent access. Using this method, we can avoid any sort of synchronization on the read side. That is certainly a plus.&#xA;Here are the init() and deinit() calls for the Pager, to complete the picture:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: std.mem.Allocator, capacity: usize) !*Pager {&#xA;        &#xA;        &#xA;          &#xA;              var self = try allocator.create(Pager);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.destroy(self);&#xA;        &#xA;        &#xA;          &#xA;              self.allocator = allocator;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.filesCapacity = std.math.max(8, nextPowerOfTwo(capacity));&#xA;        &#xA;        &#xA;          &#xA;              var files = try allocator.alloc(PagerFile, self.filesCapacity);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(files);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.pendingFree = try PagerFileList.initCapacity(allocator, 1);&#xA;        &#xA;        &#xA;          &#xA;              errdefer self.pendingFree.deinit(allocator);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.ring = try PagerRing.init(allocator);&#xA;        &#xA;        &#xA;          &#xA;              errdefer self.ring.deinit();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.pendingFree.append(allocator, files);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.files = files;&#xA;        &#xA;        &#xA;          &#xA;              self.files.len = 0; // no values yet...&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn deinit(self: *Pager) void {&#xA;        &#xA;        &#xA;          &#xA;              for (self.files) |*file| {&#xA;        &#xA;        &#xA;          &#xA;                  file.deinit();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              while (self.pendingFree.popOrNull()) |toFree| {&#xA;        &#xA;        &#xA;          &#xA;                  self.allocator.free(toFree);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.pendingFree.deinit(self.allocator);&#xA;        &#xA;        &#xA;          &#xA;              self.ring.deinit();&#xA;        &#xA;        &#xA;          &#xA;              self.allocator.destroy(self);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Pager.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we allocate a PagerRing for the pager, which will deal with the actual I/O. The actual disposal of the files array is managed using the pendingFree list. That is a small cost to pay, to reduce the cost of adding a new file. In the deinit() routine, note that there is a distinction between releasing the files themselves (where we close the FilesChunk, release the relevant memory, close the file handle, etc) and releasing the arrays that hold the files themselves.&#xA;I&#x2019;m quite pleased with how this turned out, zero cost for reads (important) and negligible memory cost for most scenarios).&#xA;In my next post, I&#x2019;ll get started with actually reading the data from disk and putting that in the pager. So far, that is a 7 post series, and we haven&#x2019;t completed the first part. That simple scenario is surprisingly tricky.</p>
        </article>
        <article id="article-760">
            <a href="https://www.meziantou.net/using-http-3-quic-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-760">Using HTTP/3 (QUIC) in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 10, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">#What&#x27;s HTTP/3?HTTP/3 is a new version of HTTP. HTTP/3 protocol is supported by most modern browsers and servers. This update should bring performance benefits mostly for mobile users or unreliable connections. The main idea is to replace TCP by a new protocol, QUIC, which removes some issues of TC</p>
        </article>
        <div class="button flex justify-between">
            <a href="75.html"><span class="back arrow"></span></a>

            <a href="77.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>