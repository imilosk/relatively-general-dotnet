
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 48 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-471">
            <a href="https://ardalis.com/trunk-based-development-vs-long-lived-feature-branches/" target="_blank">
                <h2 class="title mb-6" id="article-471">Trunk-Based Development vs. Long-Lived Feature Branches: Which One is Right for Your Software Team?</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 14, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">When it comes to effective software development strategies, two distinct approaches often lock horns: Trunk-Based Development and Long-Lived&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-472">
            <a href="https://ayende.com/blog/200102-C/filtering-negative-numbers-fast-avx" target="_blank">
                <h2 class="title mb-6" id="article-472">Filtering negative numbers, fast</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 13, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post I discussed how we can optimize the filtering of negative numbers by unrolling the loop, looked into branchless code and in general was able to improve performance by up to 15% from the initial version we started with. We pushed as much as we could on what can be done using scalar code. Now it is the time to open a whole new world and see what we can do when we implement this challenge using vector instructions.&#xA;The key problem with such tasks is that SIMD, AVX and their friends were designed by&#x2026; an interesting process using a perspective that makes sense if you can see in a couple of additional dimensions. I assume that at least some of that is implementation constraints, but the key issue is that when you start using SIMD, you realize that you don&#x2019;t have general-purpose instructions. Instead, you have a lot of dedicated instructions that are doing one thing, hopefully well, and it is your role to compose them into something that would make sense. Oftentimes, you need to turn the solution on its head in order to successfully solve it using SIMD. The benefit, of course, is that you can get quite an amazing boost in speed when you do this.&#xA;The algorithm we use is basically to scan the list of entries and copy to the start of the list only those items that are positive. How can we do that using SIMD? The whole point here is that we want to be able to operate on multiple data, but this particular task isn&#x2019;t trivial. I&#x2019;m going to show the code first, then discuss what it does in detail:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_Avx(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var len = items.Length;&#xA;        &#xA;        &#xA;          &#xA;              if (len &lt;= 0)&#xA;        &#xA;        &#xA;          &#xA;                  return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              ref var permuteStart = ref Unsafe.AsRef(PermuteTable[0]);&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;              for (; i &#x2B; Vector256&lt;long&gt;.Count &lt;= len; i &#x2B;= Vector256&lt;long&gt;.Count)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var v = Vector256.LoadUnsafe(ref Unsafe.Add(ref output, i));&#xA;        &#xA;        &#xA;          &#xA;                  var bits = v.ExtractMostSignificantBits();&#xA;        &#xA;        &#xA;          &#xA;                  if (bits == 0) // do we have _any_ negatives here?&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      v.StoreUnsafe(ref Unsafe.Add(ref output, outputIdx));&#xA;        &#xA;        &#xA;          &#xA;                      outputIdx &#x2B;= Vector256&lt;long&gt;.Count;&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  // complex case, we have to deal with some negatives&#xA;        &#xA;        &#xA;          &#xA;                  var permute = Vector256.LoadUnsafe(ref Unsafe.Add(ref permuteStart, (int)bits * (sizeof(int) * 8))).AsInt32();&#xA;        &#xA;        &#xA;          &#xA;                  var m = Avx2.PermuteVar8x32(v.AsInt32(), permute).AsInt64();&#xA;        &#xA;        &#xA;          &#xA;                  m.StoreUnsafe(ref Unsafe.Add(ref output, outputIdx));&#xA;        &#xA;        &#xA;          &#xA;                  outputIdx &#x2B;= 4 - BitOperations.PopCount(bits);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // remainder, do that in a scalar fashion&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; len; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  ref var cur = ref Unsafe.Add(ref output, i);&#xA;        &#xA;        &#xA;          &#xA;                  if (cur &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;) = cur;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_Avx.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We start with the usual check (if you&#x2019;ll recall, that ensures that the JIT knows to elide some range checks, then we load the PremuteTable. For now, just assume that this is magic (and it is). The first interesting thing happens when we start iterating over the loop. Unlike before, now we do that in chunks of 4 int64 elements at a time. Inside the loop, we start by loading a vector of int64 and then we do the first odd thing. We call ExtractMostSignificantBits(), since the sign bit is used to mark whether&#xA0;a number if negative or not. That means that I can use a single instruction to get an integer with the bits set for all the negative numbers. That is particularly juicy for what we need, since there is no need for comparisons, etc.&#xA;If the mask we got is all zeroes, it means that all the numbers we loaded to the vector are positives, so we can write them as-is to the output and move to the next part. Things get interesting when that isn&#x2019;t the case.&#xA;We load a permute value using some shenanigans (we&#x2019;ll touch on that shortly) and call the PermuteVar8x32() method. The idea here is that we pack all the non-negative numbers to the start of the vector, then we write the vector to the output. The key here is that when we do that, we increment the output index only by the number of valid values.&#xA0; The rest of this method just handles the remainder that does not fit into a vector.&#xA;The hard part in this implementation was to figure out how to handle the scenario where we loaded some negative numbers. We need a way to filter them, after all. But there is no SIMD instruction that allows us to do so. Luckily, we have the Avx2.PermuteVar8x32() method to help here. To confuse things, we don&#x2019;t actually want to deal with 8x32 values. We want to deal with 4x64 values. There is Avx2.Permute4x64() method, and it will work quite nicely, with a single caveat. This method assumes that you are going to pass it a constant value. We don&#x2019;t have such a constant, we need to be able to provide that based on whatever the masked bits will give us.&#xA;So how do we deal with this issue of filtering with SIMD? We need to move all the values we care about to the front of the vector. We have the method to do that, PermuteVar8x32() method, and we just need to figure out how to actually make use of this. PermuteVar8x32() accepts an input vector as well as a vector of the premutation you want to make. In this case, we are basing this on the 4 top bits of the 4 elements vector of int64. As such, there are a total of 16 options available to us. We have to deal with 32bits values rather than 64bits, but that isn&#x2019;t that much of a problem.&#xA;Here is the premutation table that we&#x2019;ll be using:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static readonly int[] PermuteTableInts = new int[]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              0,1,2,3,4,5,6,7, // 0000&#xA;        &#xA;        &#xA;          &#xA;              2,3,4,5,6,7,0,0, // 0001&#xA;        &#xA;        &#xA;          &#xA;              0,1,4,5,6,7,0,0, // 0010&#xA;        &#xA;        &#xA;          &#xA;              4,5,6,7,0,0,0,0, // 0011&#xA;        &#xA;        &#xA;          &#xA;              0,1,2,3,6,7,0,0, // 0100&#xA;        &#xA;        &#xA;          &#xA;              2,3,6,7,0,0,0,0, // 0101&#xA;        &#xA;        &#xA;          &#xA;              0,1,6,7,0,0,0,0, // 0110&#xA;        &#xA;        &#xA;          &#xA;              6,7,0,0,0,0,0,0, // 0111&#xA;        &#xA;        &#xA;          &#xA;              0,1,2,3,4,5,0,0, // 1000&#xA;        &#xA;        &#xA;          &#xA;              2,3,4,5,0,0,0,0, // 1001&#xA;        &#xA;        &#xA;          &#xA;              0,1,4,5,0,0,0,0, // 1010&#xA;        &#xA;        &#xA;          &#xA;              4,5,0,0,0,0,0,0, // 1011&#xA;        &#xA;        &#xA;          &#xA;              0,1,2,3,0,0,0,0, // 1100&#xA;        &#xA;        &#xA;          &#xA;              2,3,0,0,0,0,0,0, // 1101&#xA;        &#xA;        &#xA;          &#xA;              0,1,0,0,0,0,0,0, // 1110&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,0,0,0,0, // 1111&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PermuteTableInts.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What you can see here is that when we have a 1 in the bits (shown in comments) we&#x2019;ll not copy that to the vector. Let&#x2019;s take a look at the entry of 0101, which may be caused by the following values [1,-2,3,-4].&#xA;When we look at the right entry at index #5 in the table: 2,3,6,7,0,0,0,0&#xA;What does this mean? It means that we want to put the 2nd int64 element in the source vector and move it as the first element of the destination vector, take the 3rd element from the source as the second element in the destination and discard the rest (marked as 0,0,0,0 in the table).&#xA;This is a bit hard to follow because we have to compose the value out of the individual 32 bits words, but it works quite well. Or, at least, it would work, but not as efficiently. This is because we would need to load the PermuteTableInts into a variable and access it, but there are better ways to deal with it. We can also ask the JIT to embed the value directly. The problem is that the pattern that the JIT recognizes is limited to ReadOnlySpan&lt;byte&gt;, which means that the already non-trivial int32 table got turned into this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // same as the one above, just in bytes for JIT optimizations&#xA;        &#xA;        &#xA;          &#xA;          public static ReadOnlySpan&lt;byte&gt; PermuteTable =&gt; new byte[]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              2,0,0,0,3,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              2,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PermuteTable.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is the exact same data as before, but using ReadOnlySpan&lt;byte&gt; means that the JIT can package that inside the data section and treat it as a constant value.&#xA;The code was heavily optimized, to the point where I noticed a JIT bug where these two versions of the code give different assembly output:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          int A(int i)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return i * 4 * 8;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          int B(int i)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return i * (4 * 8);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          code.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here is what we get out:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Program.&lt;&lt;Main&gt;$&gt;g__A|0_0(Int32)&#xA;        &#xA;        &#xA;          &#xA;              L0000: mov eax, ecx&#xA;        &#xA;        &#xA;          &#xA;              L0002: shl eax, 2&#xA;        &#xA;        &#xA;          &#xA;              L0005: shl eax, 3&#xA;        &#xA;        &#xA;          &#xA;              L0008: ret&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          Program.&lt;&lt;Main&gt;$&gt;g__B|0_1(Int32)&#xA;        &#xA;        &#xA;          &#xA;              L0000: mov eax, ecx&#xA;        &#xA;        &#xA;          &#xA;              L0002: shl eax, 5&#xA;        &#xA;        &#xA;          &#xA;              L0005: ret&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          code.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This looks like an unintended consequence of Roslyn and the JIT each doing their (separate jobs), but not reaching the end goal. Constant folding looks like it is done mostly by Roslyn, but it does a scan like that from the left, so it wouldn&#x2019;t convert $A * 4 * 8 to $A * 32. That is because it stopped evaluating the constants when it found a variable. When we add parenthesis, we isolate the value and now understand that we can fold it.&#xA;Speaking of assembly, here is the annotated assembly version of the code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          ; Filter.FilterCmp_Avx(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 push      rsi            ; push rsi to stack - we&#x27;ll be using a lot of state, so need to preserve it&#xA;        &#xA;        &#xA;          &#xA;                 vzeroupper                 ; clear AVX state, since we don&#x27;t know how the caller left it&#xA;        &#xA;        &#xA;          &#xA;                 mov       rdx,[rcx]        ; rdx is now the pointer of the items&#x27; span&#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,[rcx&#x2B;8]      ; ecx is now the length of the span&#xA;        &#xA;        &#xA;          &#xA;                 test      ecx,ecx          ; if items.Length &gt; 0&#xA;        &#xA;        &#xA;          &#xA;                 jg        short M02_L00    ; jump ahead to do work&#xA;        &#xA;        &#xA;          &#xA;                 xor       eax,eax          ; return 0&#xA;        &#xA;        &#xA;          &#xA;                 vzeroupper                 ; not actually needed, I think&#xA;        &#xA;        &#xA;          &#xA;                 pop       rsi            &#xA;        &#xA;        &#xA;          &#xA;                 ret&#xA;        &#xA;        &#xA;          &#xA;          M02_L00:&#xA;        &#xA;        &#xA;          &#xA;                 mov       rax,1CA3A753F78  ; load permuteStart&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d          ; outputIdx = 0&#xA;        &#xA;        &#xA;          &#xA;                 xor       r9d,r9d          ; i = 0&#xA;        &#xA;        &#xA;          &#xA;                 cmp       ecx,4            ; if items.Length &lt; 4&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L04    ; jump the AVX portion loop to the next one&#xA;        &#xA;        &#xA;          &#xA;          M02_L01:&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r9d          ; r10 = current i value&#xA;        &#xA;        &#xA;          &#xA;                 vmovdqu   ymm0,ymmword ptr [rdx&#x2B;r10*8] ; load vector register from output[i] (4 elements)&#xA;        &#xA;        &#xA;          &#xA;                 vmovmskpd r10d,ymm0        ; move the top bits from 4 int64 elements to r10d (bits)&#xA;        &#xA;        &#xA;          &#xA;                 test      r10d,r10d        ; if bits != 0&#xA;        &#xA;        &#xA;          &#xA;                 jne       short M02_L02    ; jump to the complex piece of the code&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r8d          &#xA;        &#xA;        &#xA;          &#xA;                 vmovdqu   ymmword ptr [rdx&#x2B;r10*8],ymm0 ; store vector to output[outputIdx]&#xA;        &#xA;        &#xA;          &#xA;                 add       r8d,4            ; outputIdx &#x2B;= 4&#xA;        &#xA;        &#xA;          &#xA;                 jmp       short M02_L03    ; restart loop&#xA;        &#xA;        &#xA;          &#xA;          M02_L02:&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,r8d          ; r11 - current outputIdx value&#xA;        &#xA;        &#xA;          &#xA;                 mov       esi,r10d         ; esi = bits&#xA;        &#xA;        &#xA;          &#xA;                 shl       esi,5            ; bits * 4 * 8 - optimized&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    rsi,esi          &#xA;        &#xA;        &#xA;          &#xA;                 vmovdqu   ymm1,ymmword ptr [rax&#x2B;rsi] ; load vector from premutation table&#xA;        &#xA;        &#xA;          &#xA;                 vpermd    ymm0,ymm1,ymm0   ; permute value&#xA;        &#xA;        &#xA;          &#xA;                 vmovdqu   ymmword ptr [rdx&#x2B;r11*8],ymm0 ; write to output&#xA;        &#xA;        &#xA;          &#xA;                 popcnt    r10d,r10d        ; count the bits&#xA;        &#xA;        &#xA;          &#xA;                 neg       r10d             ; negate the value&#xA;        &#xA;        &#xA;          &#xA;                 lea       r8d,[r10&#x2B;r8&#x2B;4]   ; add to outputIdx &#x2B; 4&#xA;        &#xA;        &#xA;          &#xA;          M02_L03:&#xA;        &#xA;        &#xA;          &#xA;                 add       r9d,4            ; for loop handling&#xA;        &#xA;        &#xA;          &#xA;                 lea       r10d,[r9&#x2B;4]&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r10d,ecx         &#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L01    ; jump to start of loop&#xA;        &#xA;        &#xA;          &#xA;          M02_L04:&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r9d,ecx          ; if there are no elements remaining&#xA;        &#xA;        &#xA;          &#xA;                 jge       short M02_L07    ; jump to end&#xA;        &#xA;        &#xA;          &#xA;          M02_L05:&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    rax,r9d          ; here is the scalar version, already discussed previously&#xA;        &#xA;        &#xA;          &#xA;                 lea       rax,[rdx&#x2B;rax*8]&#xA;        &#xA;        &#xA;          &#xA;                 mov       rax,[rax]&#xA;        &#xA;        &#xA;          &#xA;                 test      rax,rax&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L06&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,r8d&#xA;        &#xA;        &#xA;          &#xA;                 lea       r8d,[r10&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r10*8],rax&#xA;        &#xA;        &#xA;          &#xA;          M02_L06:&#xA;        &#xA;        &#xA;          &#xA;                 inc       r9d&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r9d,ecx&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L05&#xA;        &#xA;        &#xA;          &#xA;          M02_L07:&#xA;        &#xA;        &#xA;          &#xA;                 mov       eax,r8d&#xA;        &#xA;        &#xA;          &#xA;                 vzeroupper&#xA;        &#xA;        &#xA;          &#xA;                 pop       rsi&#xA;        &#xA;        &#xA;          &#xA;                 ret&#xA;        &#xA;        &#xA;          &#xA;          ; Total bytes of code 179&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_Avx.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And after all of this work, where are we standing?&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;285.7 ns&#xA;3.84 ns&#xA;3.59 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;23&#xA;272.6 ns&#xA;3.98 ns&#xA;3.53 ns&#xA;0.95&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;23&#xA;261.4 ns&#xA;1.27 ns&#xA;1.18 ns&#xA;0.91&#xA;0.01&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Avx&#xA;23&#xA;261.6 ns&#xA;1.37 ns&#xA;1.28 ns&#xA;0.92&#xA;0.01&#xA;521 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;758.7 ns&#xA;1.51 ns&#xA;1.42 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1047&#xA;756.8 ns&#xA;1.83 ns&#xA;1.53 ns&#xA;1.00&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;1047&#xA;640.4 ns&#xA;1.94 ns&#xA;1.82 ns&#xA;0.84&#xA;0.00&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Avx&#xA;1047&#xA;426.0 ns&#xA;1.62 ns&#xA;1.52 ns&#xA;0.56&#xA;0.00&#xA;521 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;502,681.4 ns&#xA;3,732.37 ns&#xA;3,491.26 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1048599&#xA;499,472.7 ns&#xA;6,082.44 ns&#xA;5,689.52 ns&#xA;0.99&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;1048599&#xA;425,800.3 ns&#xA;352.45 ns&#xA;312.44 ns&#xA;0.85&#xA;0.01&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Avx&#xA;1048599&#xA;218,075.1 ns&#xA;212.40 ns&#xA;188.29 ns&#xA;0.43&#xA;0.00&#xA;521 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;29,820,978.8 ns&#xA;73,461.68 ns&#xA;61,343.83 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;33554455&#xA;29,471,229.2 ns&#xA;73,805.56 ns&#xA;69,037.77 ns&#xA;0.99&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;33554455&#xA;29,234,413.8 ns&#xA;67,597.45 ns&#xA;63,230.70 ns&#xA;0.98&#xA;0.00&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Avx&#xA;33554455&#xA;28,498,115.4 ns&#xA;71,661.94 ns&#xA;67,032.62 ns&#xA;0.96&#xA;0.00&#xA;521 B&#xA;&#xA;&#xA;&#xA;So it seems that the idea of using SIMD instruction has a lot of merit. Moving from the original code to the final version, we see that we can complete the same task in up to half the time.&#xA;I&#x2019;m not quite sure why we aren&#x2019;t seeing the same sort of performance on the 32M, but I suspect that this is likely because we far exceed the CPU cache and we have to fetch it all from memory, so that is as fast as it can go.&#xA;If you are interested in learning more, Lemire solves the same problem in SVE (SIMD for ARM) and Paul has a similar approach in Rust.&#xA;If you can think of further optimizations, I would love to hear your ideas.</p>
        </article>
        <article id="article-473">
            <a href="https://ayende.com/blog/200101-C/filtering-negative-numbers-fast-unroll" target="_blank">
                <h2 class="title mb-6" id="article-473">Filtering negative numbers, fast</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 12, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, we looked into what it would take to reduce the cost of filtering negative numbers. We got into the assembly and analyzed exactly what was going on. In terms of this directly, I don&#x2019;t think that even hand-optimized assembly would take us further. Let&#x2019;s see if there are other options that are available for us to get better speed.&#xA;The first thing that pops to mind here is to do a loop unrolling. After all, we have a very tight loop, if we can do more work per loop iteration, we might get better performance, no? Here is my first version:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_Unroll(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (items.Length &lt;= 0)&#xA;        &#xA;        &#xA;          &#xA;                  return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (; i &#x2B; 4 &lt; items.Length; i &#x2B;= 4)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var i0 = items[i &#x2B; 0];&#xA;        &#xA;        &#xA;          &#xA;                  var i1 = items[i &#x2B; 1];&#xA;        &#xA;        &#xA;          &#xA;                  var i2 = items[i &#x2B; 2];&#xA;        &#xA;        &#xA;          &#xA;                  var i3 = items[i &#x2B; 3];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i0);&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i1);&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i2);&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i3);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, items[i]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [MethodImpl(MethodImplOptions.AggressiveInlining)]&#xA;        &#xA;        &#xA;          &#xA;              void AddToOutput(ref long output, long input)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (input &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      return;&#xA;        &#xA;        &#xA;          &#xA;                  Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;) = input;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_Unroll.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And here are the benchmark results:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;274.6 ns&#xA;0.40 ns&#xA;0.35 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;257.5 ns&#xA;0.94 ns&#xA;0.83 ns&#xA;0.94&#xA;606 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;748.1 ns&#xA;2.91 ns&#xA;2.58 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;702.5 ns&#xA;5.23 ns&#xA;4.89 ns&#xA;0.94&#xA;606 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;501,545.2 ns&#xA;4,985.42 ns&#xA;4,419.45 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;446,311.1 ns&#xA;3,131.42 ns&#xA;2,929.14 ns&#xA;0.89&#xA;606 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;29,637,052.2 ns&#xA;184,796.17 ns&#xA;163,817.00 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;29,275,060.6 ns&#xA;145,756.53 ns&#xA;121,713.31 ns&#xA;0.99&#xA;606 B&#xA;&#xA;&#xA;&#xA;That is quite a jump, 6% &#x2013; 11% savings is no joke. Let&#x2019;s look at what is actually going on at the assembly level and see if we can optimize this further.&#xA;As expected, the code size is bigger, 264 bytes versus the 55 we previously got. But more importantly, we got the range check back, and a lot of them:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;                 lea       r11d,[r8&#x2B;1]        ; var i01_idx = i&#x2B;1&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r11d,ecx           ; if i01_idx &gt;=&#xA;        &#xA;        &#xA;          &#xA;                 jae       near ptr M02_L10   ; jump to range check&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_Unroll.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The JIT isn&#x2019;t able to reason about our first for loop and see that all our accesses are within bounds, which leads to doing a lot of range checks, and likely slows us down. Even with that, we are still showing significant improvements here.&#xA;Let&#x2019;s see what we can do with this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (; i &#x2B; 4 &lt; items.Length; i &#x2B;= 4)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 0));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 1));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 2));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 3));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ElidedRangeChecks.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;With that, we expect to have no range checks and still be able to benefit from the unrolling.&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;275.4 ns&#xA;2.31 ns&#xA;2.05 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;253.6 ns&#xA;2.59 ns&#xA;2.42 ns&#xA;0.92&#xA;0.01&#xA;563 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;741.6 ns&#xA;5.95 ns&#xA;5.28 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;665.5 ns&#xA;2.38 ns&#xA;2.22 ns&#xA;0.90&#xA;0.01&#xA;563 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;497,624.9 ns&#xA;3,904.39 ns&#xA;3,652.17 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;444,489.0 ns&#xA;2,524.45 ns&#xA;2,361.38 ns&#xA;0.89&#xA;0.01&#xA;563 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;29,781,164.3 ns&#xA;361,625.63 ns&#xA;320,571.70 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;29,954,093.9 ns&#xA;588,614.32 ns&#xA;916,401.59 ns&#xA;1.01&#xA;0.04&#xA;563 B&#xA;&#xA;&#xA;&#xA;That helped, by quite a lot, it seems, for most cases, the 32M items case, however, was slightly slower, which is quite a surprise.&#xA;Looking at the assembly, I can see that we still have branches, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          M02_L03:&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;2]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]&#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9          ; if items[i&#x2B;2] &lt; 0:&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L04  ;     continue&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,eax&#xA;        &#xA;        &#xA;          &#xA;                 lea       eax,[r10&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r10*8],r9&#xA;        &#xA;        &#xA;          &#xA;          M02_L04:&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;3]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8] &#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9          ; if items[i&#x2B;3] &lt; 0:&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L05  ;     continue&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,eax&#xA;        &#xA;        &#xA;          &#xA;                 lea       eax,[r10&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r10*8],r9&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          branches.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And here is why this is the case:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.AggressiveInlining)]&#xA;        &#xA;        &#xA;          &#xA;          void AddToOutput(ref long output, long input)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (input &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                  return;&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;) = input;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          AddToOutput.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Now, can we do better here? It turns out that we can, by using a branchless version of the operation. Here is another way to write the same thing:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.AggressiveInlining)]&#xA;        &#xA;        &#xA;          &#xA;          unsafe void AddToOutput(ref long output, long input)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              bool isNegative = (input &lt; 0);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.Add(ref output, outputIdx) = input;&#xA;        &#xA;        &#xA;          &#xA;              outputIdx &#x2B;= *(byte*)&amp;isNegative;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          AddToOutput.Branchless.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What happens here is that we are unconditionally setting the value in the array, but only increment if the value is greater than or equal to zero. That saves us in branches and will likely result in less code. In fact, let&#x2019;s see what sort of assembly the JIT will output:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;                 movsxd    r9,r8d         ; r9 = i&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]  ; r9 = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9         ; copy the item to r10 temporary&#xA;        &#xA;        &#xA;          &#xA;                 not       r10            ; flips the bits, important for the next instruction&#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F         ; r10 = r9 &gt;&gt; 63 (basically, if &lt; 0, it&#x27;s 1, otherwise 0)&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax        ; r11 = outputIdx&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9 ; items[outputIdx] = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d       ; outputIdx &#x2B;= (items[i] &lt; 0 ? 0 : 1);&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;1]     ; i&#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]  ; r9 = items[&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9         ; and the same here for the next round...&#xA;        &#xA;        &#xA;          &#xA;                 not       r10&#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          movsxd    r9,r8d         &#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8] &#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9         ; &#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F         &#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax        ; r11 is the outputIdx &#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9 ; items[outputIdx]&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d       ; outputIdx &#x2B;= r10 (which is 1 i&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9&#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Unrolled.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What about the performance? I decided to pit the two versions (normal and branchless) head to head and see what this will give us:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;276.3 ns&#xA;4.13 ns&#xA;3.86 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;23&#xA;263.6 ns&#xA;0.95 ns&#xA;0.84 ns&#xA;0.96&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;743.7 ns&#xA;9.41 ns&#xA;8.80 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1047&#xA;733.3 ns&#xA;3.54 ns&#xA;3.31 ns&#xA;0.99&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;502,631.1 ns&#xA;3,641.47 ns&#xA;3,406.23 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1048599&#xA;495,590.9 ns&#xA;335.33 ns&#xA;297.26 ns&#xA;0.99&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;29,356,331.7 ns&#xA;207,133.86 ns&#xA;172,966.15 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;33554455&#xA;29,709,835.1 ns&#xA;86,129.58 ns&#xA;71,922.10 ns&#xA;1.01&#xA;547 B&#xA;&#xA;&#xA;&#xA;Surprisingly enough, it looks like the branchless version is very slightly slower. That is a surprise, since I would expect reducing the branches to be more efficient.&#xA;Looking at the assembly of those two, the branchless version is slightly bigger (10 bytes, not that meaningful). I think that the key here is that there is a 0.5% chance of actually hitting the branch, which is pretty low. That means that the branch predictor can likely do a really good job and we aren&#x2019;t going to see any big benefits from the branchless version.&#xA;That said&#x2026; what would happen if we tested that with 5% negatives? That difference in behavior may cause us to see a different result. I tried that, and the results were quite surprising. In the case of the 1K and 32M items, we see a slightl&#xA0;cost for the branchless version (additional 1% &#x2013; 4%) while for the 1M entries there is an 18% reduction in latency for the branchless version.&#xA;I ran the tests again with a 15% change of negative, to see what would happen. In that case, we get:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;273.5 ns&#xA;3.66 ns&#xA;3.42 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;23&#xA;280.2 ns&#xA;4.85 ns&#xA;4.30 ns&#xA;1.03&#xA;0.02&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;1,675.7 ns&#xA;29.55 ns&#xA;27.64 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1047&#xA;1,676.3 ns&#xA;16.97 ns&#xA;14.17 ns&#xA;1.00&#xA;0.02&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;2,206,354.4 ns&#xA;6,141.19 ns&#xA;5,444.01 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1048599&#xA;1,688,677.3 ns&#xA;11,584.00 ns&#xA;10,835.68 ns&#xA;0.77&#xA;0.01&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;205,320,736.1 ns&#xA;2,757,108.01 ns&#xA;2,152,568.58 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;33554455&#xA;199,520,169.4 ns&#xA;2,097,285.87 ns&#xA;1,637,422.86 ns&#xA;0.97&#xA;0.01&#xA;547 B&#xA;&#xA;&#xA;&#xA;As you can see, we have basically the same cost under 15% negatives for small values, a big improvement on the 1M scenario and not much improvement on the 32M scenario.&#xA;All in all, that is very interesting information. Digging into the exact why and how of that means pulling a CPU instruction profiler and starting to look at where we have stalls, which is a bit further that I want to invest in this scenario.&#xA;What if we&#x2019;ll try to rearrange the code a little bit. The code looks like this (load the value and AddToOutput() immediately):&#xA;&#xA;AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 0));&#xA;&#xA;What if we split it a little bit, so the code will look like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (; i &#x2B; 4 &lt; items.Length; i &#x2B;= 4)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var i0 = Unsafe.Add(ref itemsRef, i &#x2B; 0);&#xA;        &#xA;        &#xA;          &#xA;              var i1 = Unsafe.Add(ref itemsRef, i &#x2B; 1);&#xA;        &#xA;        &#xA;          &#xA;              var i2 = Unsafe.Add(ref itemsRef, i &#x2B; 2);&#xA;        &#xA;        &#xA;          &#xA;              var i3 = Unsafe.Add(ref itemsRef, i &#x2B; 3);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i0);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i1);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i2);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i3);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ReShuffle.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea here is that we are trying to get the JIT / CPU to fetch the items before they are actually needed, so there would be more time for the memory to arrive.&#xA;Remember that for the 1M scenario, we are dealing with 8MB of memory and for the 32M scenario, we have 256MB. Here is what happens when we look at the loop prolog, we can see that it is indeed first fetching all the items from memory, then doing the work:&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;                 movsxd    r9,r8d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]&#xA;        &#xA;        &#xA;          &#xA;                 lea       r10d,[r8&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,[rdx&#x2B;r10*8]&#xA;        &#xA;        &#xA;          &#xA;                 lea       r11d,[r8&#x2B;2]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,r11d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r11,[rdx&#x2B;r11*8]&#xA;        &#xA;        &#xA;          &#xA;                 lea       esi,[r8&#x2B;3]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    rsi,esi&#xA;        &#xA;        &#xA;          &#xA;                 mov       rsi,[rdx&#x2B;rsi*8]&#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          shuffled.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;In terms of performance, that gives us a small win (1% &#x2013; 2% range) for the 1M and 32M entries scenario.&#xA;The one last thing that I wanted to test is if we&#x2019;ll unroll the loop even further, what would happen if we did 8 items per loop, instead of 4.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (; i &#x2B; 8 &lt; items.Length; i &#x2B;= 8)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Sse.Prefetch2(Unsafe.AsPointer(ref Unsafe.Add(ref itemsRef, i &#x2B; 0)));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 0));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 1));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 2));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 3));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 4));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 5));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 6));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 7));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Roll8AndPreftech.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is some improvement, (4% in the 1K scenario, 1% in the 32M scenario) but also slowdowns&#xA0; (2% in the 1M scenario).&#xA;I think that this is probably roughly the end of the line as far as we can get for scalar code.&#xA;We already made quite a few strides in trying to parallelize the work the CPU is doing by just laying out the code as we would like it to be. We tried to control the manner in which it touches memory and in general, those are pretty advanced techniques.&#xA;To close this post, I would like to take a look at the gains we got. I&#x2019;m comparing the first version of the code, the last version we had on the previous post and the unrolled version for both branchy and branchless with 8 operations at once and memory prefetching.&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;277.3 ns&#xA;0.69 ns&#xA;0.64 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;23&#xA;270.7 ns&#xA;0.42 ns&#xA;0.38 ns&#xA;0.98&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;23&#xA;257.6 ns&#xA;1.45 ns&#xA;1.21 ns&#xA;0.93&#xA;0.00&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;23&#xA;259.9 ns&#xA;1.96 ns&#xA;1.84 ns&#xA;0.94&#xA;0.01&#xA;682 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;754.3 ns&#xA;1.38 ns&#xA;1.22 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1047&#xA;749.0 ns&#xA;1.81 ns&#xA;1.69 ns&#xA;0.99&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;1047&#xA;647.2 ns&#xA;2.23 ns&#xA;2.09 ns&#xA;0.86&#xA;0.00&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;1047&#xA;721.2 ns&#xA;1.23 ns&#xA;1.09 ns&#xA;0.96&#xA;0.00&#xA;682 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;499,675.6 ns&#xA;2,639.97 ns&#xA;2,469.43 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1048599&#xA;494,388.4 ns&#xA;600.46 ns&#xA;532.29 ns&#xA;0.99&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;1048599&#xA;426,940.7 ns&#xA;1,858.57 ns&#xA;1,551.99 ns&#xA;0.85&#xA;0.01&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;1048599&#xA;483,940.8 ns&#xA;517.14 ns&#xA;458.43 ns&#xA;0.97&#xA;0.00&#xA;682 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;30,282,334.8 ns&#xA;599,306.15 ns&#xA;531,269.30 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;33554455&#xA;29,410,612.5 ns&#xA;29,583.56 ns&#xA;24,703.61 ns&#xA;0.97&#xA;0.02&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;33554455&#xA;29,102,708.3 ns&#xA;42,824.78 ns&#xA;40,058.32 ns&#xA;0.96&#xA;0.02&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;33554455&#xA;29,761,841.1 ns&#xA;48,108.03 ns&#xA;42,646.51 ns&#xA;0.98&#xA;0.02&#xA;682 B&#xA;&#xA;&#xA;&#xA;The unrolled 8 version is the winner by far, in this scenario (0.5% negatives). Since that is the scenario we have in the real code, that is what I&#x2019;m focusing on.&#xA;Is there anything left to do here?&#xA;My next step is to explore whether&#xA0;using vector instructions will be a good option for us.</p>
        </article>
        <article id="article-474">
            <a href="https://ayende.com/blog/200100-C/filtering-negative-numbers-fast-scalar" target="_blank">
                <h2 class="title mb-6" id="article-474">Filtering negative numbers, fast</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 11, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">While working deep on the guts of RavenDB, I found myself with a seemingly simple task. Given a list of longs, I need to filter out all negative numbers as quickly as possible.&#xA;The actual scenario is that we run a speculative algorithm, given a potentially large list of items, we check if we can fulfill the request in an optimal fashion. However, if that isn&#x2019;t possible, we need to switch to a slower code path that does more work.&#xA;Conceptually, this looks something like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void Run(Span&lt;long&gt; entries, long switchOverPoint, Aggregation state)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            long cost = 0;&#xA;        &#xA;        &#xA;          &#xA;            for (var i = 0; i &lt; entries.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;            {&#xA;        &#xA;        &#xA;          &#xA;              var (item, searchCost) = FetchCheaply(entries[i]);&#xA;        &#xA;        &#xA;          &#xA;              cost &#x2B;= searchCost;&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if(item is not null)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                 entries[i] = -entries[i]; // mark as processed&#xA;        &#xA;        &#xA;          &#xA;                 if(state.Aggregate(item))&#xA;        &#xA;        &#xA;          &#xA;                    return; // we have enough results to bail early&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if(cost &gt; switchOverPoint)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                // speculative execution failed, we need to do this the hard way&#xA;        &#xA;        &#xA;          &#xA;                RunManually(entries, state);&#xA;        &#xA;        &#xA;          &#xA;                return;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Choices.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;That is the setup for this story. The problem we have now is that we now need to filter the results we pass to the RunManually() method.&#xA;There is a problem here, however. We marked the entries that we already used in the list by negating them. The issue is that RunManually() does not allow negative values, and its internal implementation is not friendly to ignoring those values.&#xA;In other words, given a Span&lt;long&gt;, I need to write the code that would filter out all the negative numbers. Everything else about the list of numbers should remain the same (the order of elements, etc).&#xA;From a coding perspective, this is as simple as:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public Span&lt;long&gt; FilterNegative(Span&lt;long&gt; entries)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return entries.ToArray().Where(l =&gt; l &gt; 0).ToArray();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          VeryBad.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Please note, just looking at this code makes me cringe a lot. This does the work, but it has an absolutely horrible performance profile. It allocates multiple arrays, uses a lambda, etc.&#xA;We don&#x2019;t actually care about the entries here, so we are free to modify them without allocating a new value. As such, let&#x2019;s see what kind of code we can write to do this work in an efficient manner. Here is what I came up with:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              int output = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (items[i] &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  items[output&#x2B;&#x2B;] = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return output;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Cmp.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The way this works is that we scan through the list, skipping writing the negative lists, so we effectively &#x201C;move down&#x201D; all the non-negative lists on top of the negative ones. This has a cost of O(N) and will modify the entire array, the final output is the number of valid items that we have there.&#xA;In order to test the performance, I wrote the following harness:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [RPlotExporter]&#xA;        &#xA;        &#xA;          &#xA;          [DisassemblyDiagnoser]&#xA;        &#xA;        &#xA;          &#xA;          public class SimdVsScalar&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              private long[] items;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Params(1024 &#x2B; 23, 1024 * 1024 &#x2B; 23, 32 * 1024 * 1024 &#x2B; 23)]&#xA;        &#xA;        &#xA;          &#xA;              public int N;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [GlobalSetup]&#xA;        &#xA;        &#xA;          &#xA;              public void Setup()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  items = new long[N];&#xA;        &#xA;        &#xA;          &#xA;                  var r = new Random(2391);&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      items[i] = r.NextInt64();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private void SprinkleNegatives()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var r = new Random(13245);&#xA;        &#xA;        &#xA;          &#xA;                  var negatives = Math.Max((int)(items.Length * 0.005), 1);&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; negatives; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var idx = r.Next(items.Length);&#xA;        &#xA;        &#xA;          &#xA;                      items[idx] = -items[idx];&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Benchmark]&#xA;        &#xA;        &#xA;          &#xA;              public int FilterOr()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  SprinkleNegatives();&#xA;        &#xA;        &#xA;          &#xA;                  return Filter.FilterOr(items);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Benchmark]&#xA;        &#xA;        &#xA;          &#xA;              public int FilterCmp()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  SprinkleNegatives();&#xA;        &#xA;        &#xA;          &#xA;                  return Filter.FilterCmp(items);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Benchmark]&#xA;        &#xA;        &#xA;          &#xA;              public int Base()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  SprinkleNegatives();&#xA;        &#xA;        &#xA;          &#xA;                  return items.Length;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Bench.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We compare 1K, 1M and 32M elements arrays, each of which has about 0.5% negative, randomly spread across the range. Because we modify the values directly, we need to sprinkle the negatives across the array on each call. In this case, I&#x2019;m testing two options for this task, one that uses a direct comparison (shown above) and one that uses bitwise or, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterOr(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              int output = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if ((items[i] &amp; ~long.MaxValue) != 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  items[output&#x2B;&#x2B;] = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return output;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterOr.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m testing the cost of sprinkling negatives as well, since that has to be done before each benchmark call (since we modify the array during the call, we need to &#x201C;reset&#x201D; its state for the next one).&#xA;Given the two options, before we discuss the results, what would you expect to be the faster option? How would the size of the array matter here?&#xA;I really like this example, because it is simple, there isn&#x2019;t any real complexity in what we are trying to do. And there is a very straightforward implementation that we can use as our baseline. That also means that I get to analyze what is going on at a very deep level. You might have noticed the disassembler attribute on the benchmark code, we are going to dive deep into that. For the same reason, we aren&#x2019;t using exactly 1K, 1M, or 32M arrays, but slightly higher than that, so we&#x2019;ll have to deal with remainders later on.&#xA;Let&#x2019;s first look at what the JIT actually did here. Here is the annotated assembly for the FilterCmp function:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          ; Filter.FilterCmp(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 sub       rsp,28            ; Reserve stack space&#xA;        &#xA;        &#xA;          &#xA;                 mov       rax,[rcx]         ; rax now holds the pointer from the span&#xA;        &#xA;        &#xA;          &#xA;                 mov       edx,[rcx&#x2B;8]       ; edx now holds the length of the span&#xA;        &#xA;        &#xA;          &#xA;                 xor       ecx,ecx           ; zero ecx (i)&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d           ; zero r8d (output)&#xA;        &#xA;        &#xA;          &#xA;                 test      edx,edx           ; if items.Length &lt;= 0&#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L02     ; jump the epilog &amp; return&#xA;        &#xA;        &#xA;          &#xA;          M02_L00:&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9d,r8d           &#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rax&#x2B;r9*8]     ; r9 = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9             ; r9 &lt; 0&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L01     ; continue to next iteration&#xA;        &#xA;        &#xA;          &#xA;                 &#xA;        &#xA;        &#xA;          &#xA;                 ; items[output] -- range check&#xA;        &#xA;        &#xA;          &#xA;                 lea       r10d,[rcx&#x2B;1]      ; r10d = output&#x2B;1&#xA;        &#xA;        &#xA;          &#xA;                 cmp       ecx,edx           ; check against items.length&#xA;        &#xA;        &#xA;          &#xA;                 jae       short M02_L03     ; jump to out of range exception&#xA;        &#xA;        &#xA;          &#xA;                 &#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,ecx           ; clear high bits in rcx (overflow from addition?)&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rax&#x2B;rcx*8],r9    ; items[output] = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,r10d          ; output = r10d&#xA;        &#xA;        &#xA;          &#xA;          M02_L01:&#xA;        &#xA;        &#xA;          &#xA;                 inc       r8d               ; i&#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r8d,edx           ; i &lt; item.Length&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L00     ; back to start of the loop&#xA;        &#xA;        &#xA;          &#xA;          M02_L02:&#xA;        &#xA;        &#xA;          &#xA;                 mov       eax,ecx           ; return output&#xA;        &#xA;        &#xA;          &#xA;                 add       rsp,28&#xA;        &#xA;        &#xA;          &#xA;                 ret&#xA;        &#xA;        &#xA;          &#xA;          M02_L03:                           ; range check failure&#xA;        &#xA;        &#xA;          &#xA;                 call      CORINFO_HELP_RNGCHKFAIL&#xA;        &#xA;        &#xA;          &#xA;                 int       3&#xA;        &#xA;        &#xA;          &#xA;          ; Total bytes of code 69&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For the FilterOr, the code is pretty much the same, except that the key part is:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          -       test      r9,r9&#x9;&#xA;        &#xA;        &#xA;          &#xA;          -       jl        short M02_L01&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;       mov       r10,8000000000000000&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;       test      r10,r9&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;       jne       short M02_L01&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CmpVsOr.diff&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, the cmp option is slightly smaller, in terms of code size. In terms of performance, we have:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;&#xA;&#xA;&#xA;&#xA;FilterOr&#xA;1047&#xA;745.6 ns&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;745.8 ns&#xA;&#xA;&#xA;&#x2014;&#xA;&#x2013;&#xA;&#x2013;&#xA;&#xA;&#xA;FilterOr&#xA;1048599&#xA;497,463.6 ns&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;498,784.8 ns&#xA;&#xA;&#xA;&#x2014;&#xA;&#x2013;&#xA;&#x2013;&#xA;&#xA;&#xA;FilterOr&#xA;33554455&#xA;31,427,660.7 ns&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;30,024,102.9 ns&#xA;&#xA;&#xA;&#xA;The costs are very close to one another, with Or being very slightly faster on low numbers, and Cmp being slightly faster on the larger sizes. Note that the difference level between them is basically noise. They have the same performance.&#xA;The question is, can we do better here?&#xA;Looking at the assembly, there is an extra range check in the main loop that the JIT couldn&#x2019;t elide (the call to items[output&#x2B;&#x2B;]). Can we do something about it, and would it make any difference in performance? Here is how I can remove the range check:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_NoRangeCheck(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (items[i] &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  ref var outputDest = ref Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  outputDest = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here I&#x2019;m telling the JIT: &#x201C;I know what I&#x2019;m doing&#x201D;, and it shows.&#xA;Let&#x2019;s look at the assembly changes between those two methods, first the prolog:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          &#x9;; Filter.FilterCmp_NoRangeCheck(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 sub       rsp,28             ; setup stack space&#xA;        &#xA;        &#xA;          &#xA;                 mov       rax,[rcx]          ; rax is not the pointer for the span&#xA;        &#xA;        &#xA;          &#xA;                 mov       edx,[rcx&#x2B;8]        ; edx is the length of the span&#xA;        &#xA;        &#xA;          &#xA;                 xor       ecx,ecx            ; zero ecx (i = 0)&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d            ; zero r8d (outputIdx = 0)&#xA;        &#xA;        &#xA;          &#xA;                 test      edx,edx            ; if items.Length == 0&#xA;        &#xA;        &#xA;          &#xA;                 je        short M02_L03      ; jump to CORINFO_HELP_RNGCHKFAIL&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,rax             ; output = items[0]&#xA;        &#xA;        &#xA;          &#xA;                 test      edx,edx            ; if items.Length &lt;= 0&#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L02      ; jump past the for loop&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck.prolog.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here you can see what we are actually doing here. Note the last 4 instructions,&#xA0;we have a range check for the items, and then we have another check for the loop. The first will get you an exception, the second will just skip the loop. In both cases, we test the exact same thing. The JIT had a chance to actually optimize that, but didn&#x2019;t.&#xA;Here is a funny scenario where adding code may reduce the amount of code generated. Let&#x2019;s do another version of this method:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_NoRangeCheck(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (items.Length == 0)&#xA;        &#xA;        &#xA;          &#xA;                  return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (items[i] &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  ref var outputDest = ref Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  outputDest = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck2.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In this case, I added a check to handle the scenario of items being empty. What can the JIT do with this now? It turns out, quite a lot. We dropped 10 bytes from the method, which is a nice result of our diet.&#xA0; Here is the annotated version of the assembly:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          ; Filter.FilterCmp_NoRangeCheck(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 mov       rdx,[rcx]        ; rdx = pointer of items&#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,[rcx&#x2B;8]      ; ecx = length of items&#xA;        &#xA;        &#xA;          &#xA;                 test      ecx,ecx          ; items.Length == 0&#xA;        &#xA;        &#xA;          &#xA;                 jne       short M02_L00    ; if not true, jump ahead&#xA;        &#xA;        &#xA;          &#xA;                 xor       eax,eax          ; return 0&#xA;        &#xA;        &#xA;          &#xA;                 ret&#xA;        &#xA;        &#xA;          &#xA;          M02_L00:&#xA;        &#xA;        &#xA;          &#xA;                 xor       eax,eax          ; outputIdx = 0&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d          ; i = 0&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,rdx           ; output = items.pointer&#xA;        &#xA;        &#xA;          &#xA;                 test      ecx,ecx          ; if items.Length &lt;= 0&#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L03    ; jump to end function exit&#xA;        &#xA;        &#xA;          &#xA;          M02_L01:&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,r8d          &#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,[r9&#x2B;r10*8]   ; r10 = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 test      r10,r10          ; if items[i] &lt; 0&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L02&#xA;        &#xA;        &#xA;          &#xA;                 lea       r11d,[rax&#x2B;1]     ; r11d = output &#x2B;1&#xA;        &#xA;        &#xA;          &#xA;                 cdqe                       ; sign extent RAX (32 bits module on the addition)&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;rax*8],r10  ; copy r10 (items[i]) to items[r11d]&#xA;        &#xA;        &#xA;          &#xA;                 mov       eax,r11d         ; outputIdx = r11d&#xA;        &#xA;        &#xA;          &#xA;          M02_L02:&#xA;        &#xA;        &#xA;          &#xA;                 inc       r8d              ; i&#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r8d,ecx          ; i &lt; items.Length&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L01    ; do the loop again&#xA;        &#xA;        &#xA;          &#xA;          M02_L03:&#xA;        &#xA;        &#xA;          &#xA;                 ret                        ; return&#xA;        &#xA;        &#xA;          &#xA;          ; Total bytes of code 59&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;A lot of the space savings in this case come from just not having to do a range check, but you&#x2019;ll note that we still do an extra check there (lines 12..13), even though we already checked that. I think that the JIT knows that the value is not zero at this point, but has to consider that the value may be negative.&#xA;If we&#x2019;ll change the initial guard clause to: items.Length &lt;= 0, what do you think will happen? At this point, the JIT is smart enough to just elide everything, we are at 55 bytes of code and it is a super clean assembly (not a sentence I ever thought I would use). I&#x2019;ll spare you going through more assembly listing, but you can find the output here.&#xA;And after all of that, where are we at?&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;274.5 ns&#xA;1.91 ns&#xA;1.70 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;23&#xA;269.7 ns&#xA;1.33 ns&#xA;1.24 ns&#xA;0.98&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;744.5 ns&#xA;4.88 ns&#xA;4.33 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1047&#xA;745.8 ns&#xA;3.44 ns&#xA;3.22 ns&#xA;1.00&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;502,608.6 ns&#xA;3,890.38 ns&#xA;3,639.06 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1048599&#xA;490,669.1 ns&#xA;1,793.52 ns&#xA;1,589.91 ns&#xA;0.98&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;30,495,286.6 ns&#xA;602,907.86 ns&#xA;717,718.92 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;33554455&#xA;29,952,221.2 ns&#xA;442,176.37 ns&#xA;391,977.84 ns&#xA;0.99&#xA;0.02&#xA;397 B&#xA;&#xA;&#xA;&#xA;There is a very slight benefit to the NoRangeCheck, but even when we talk about 32M items, we aren&#x2019;t talking about a lot of time.&#xA;The question what can we do better here?</p>
        </article>
        <article id="article-475">
            <a href="https://www.meziantou.net/listing-windows-virtual-desktops-using-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-475">Listing Windows virtual desktops using .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 11, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the blog post Per virtual desktop single-instance application, I introduced the IVirtualDesktopManager interface to detect if a window is on the current virtual desktop. In this post, I describe how to list the virtual desktops. This can be useful to provide a list of virtual desktops to the use</p>
        </article>
        <article id="article-476">
            <a href="https://ardalis.com/building-resilient-email-method-dotnet-retry-outbox-pattern/" target="_blank">
                <h2 class="title mb-6" id="article-476">Building a Resilient Email Sending Method in .NET with SmtpClient, Retry Support, and the Outbox Pattern</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 08, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Introduction In the world of software applications, email sending functionalities are indispensable. From password resets to notifications&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-477">
            <a href="https://andrewlock.net/exploring-the-dotnet-8-preview-introducing-the-identity-api-endpoints/" target="_blank">
                <h2 class="title mb-6" id="article-477">Introducing the Identity API endpoints</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 05, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Exploring the .NET 8 preview - Part 8</p>
        </article>
        <article id="article-478">
            <a href="https://ayende.com/blog/200065-B/optimizing-a-three-way-merge" target="_blank">
                <h2 class="title mb-6" id="article-478">Optimizing a three-way merge</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 04, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Deep inside of the Corax indexing engine inside of RavenDB there is the notion of a posting list. A posting list is just an ordered set of entry ids that contains a particular term. During the indexing process, we need to add and remove items from that posting list. This ends up being something like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // All three parameters are sorted, the output is the merged list in &#xA;        &#xA;        &#xA;          &#xA;          // the existing parameter&#xA;        &#xA;        &#xA;          &#xA;          long[] Merge(long[] existing, long[] additions, long[] removals);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          merge.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For fun, go and ask ChatGPT to write you the code for this task.&#xA;You can assume that there are no duplicates between the removals and additions, and that adding an existing item is a no-op (so just one value would be in the end result). Here is a quick solution for this task (not actually tested that much, mind, but sufficient to understand what I&#x2019;m trying to do):&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static long[] Merge(long[] existing, long[] additions, long[] removals)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              List&lt;long&gt; result = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int existingIndex = 0;&#xA;        &#xA;        &#xA;          &#xA;              int additionsIndex = 0;&#xA;        &#xA;        &#xA;          &#xA;              int removalsIndex = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (; existingIndex &lt; existing.Length; existingIndex&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  bool removed = false;&#xA;        &#xA;        &#xA;          &#xA;                  for (; removalsIndex &lt; removals.Length; removalsIndex&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (removals[removalsIndex] &gt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          break; // will remove in the future&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      if (removals[removalsIndex] &lt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          continue; // not in the existing, can skip&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      removed = true;&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (removed)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (additionsIndex &gt;= additions.Length)&#xA;        &#xA;        &#xA;          &#xA;                      break; // no work remaining&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  for (; additionsIndex &lt; additions.Length; additionsIndex&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (additions[additionsIndex] &gt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          break;&#xA;        &#xA;        &#xA;          &#xA;                      else if (additions[additionsIndex] &lt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          result.Add(additions[additionsIndex]);&#xA;        &#xA;        &#xA;          &#xA;                      else&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          // it&#x27;s equal, so we&#x27;ll move to the next one and let the existing add it&#xA;        &#xA;        &#xA;          &#xA;                      }    &#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  result.Add(existing[existingIndex]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // add the remainders&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(additions[additionsIndex..]);&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(existing[existingIndex..]);&#xA;        &#xA;        &#xA;          &#xA;              return result.ToArray();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Merge.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;If you look at this code in terms of performance, you&#x2019;ll realize that this is quite expensive. In terms of complexity, this is actually pretty good, we iterate over the arrays just once, and the number of comparisons is also bounded to the lengths of the list.&#xA;However, there is a big issue here, the number of branches that you have to deal with. Basically, every if and every for loop is going to add a tiny bit of latency to the system. This is because these are unpredictable branches, which are pretty nasty to deal with.&#xA;It turns out that the values that we put in the posting list are actually always a multiple of 4, so the bottom 2 bits are always cleared. That means that we actually have a different way to deal with it. Here is the new logic:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static long[] MergeOptimized(long[] existing, long[] additions, long[] removals)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; removals.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  removals[i] |= 1;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              List&lt;long&gt; result = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(existing);&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(additions);&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(removals);&#xA;        &#xA;        &#xA;          &#xA;              result.Sort();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; result.Count - 1; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  outputIdx &#x2B;= ToInt32((result[i &#x2B; 1] &amp; ~1) != result[i]);&#xA;        &#xA;        &#xA;          &#xA;                  result[outputIdx] = result[i &#x2B; 1];&#xA;        &#xA;        &#xA;          &#xA;                  outputIdx -= (int)(result[i &#x2B; 1] &amp; 1);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return result.Take(outputIdx).ToArray();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          MergeOptimized.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This code was written with an eye to being able to explain the algorithm, mind, not performance.&#xA;The idea goes like this. We flag the removals with a bit, then concatenate all the arrays together, sort them, and then do a single scan over the whole thing, removing duplicates and removals.&#xA;In the real code, we are using raw pointers, not a List, so there&#xA0;are no access checks, etc.&#xA;From an algorithmic perspective, this code makes absolutely no sense at all. We concatenate all the values together, then sort them (O(NlogN) operation) then scan it again?!&#xA;How can that be faster than a single scan across all three arrays? The answer is simple, we have a really efficient sort primitive (vxsort) that is able to sort things really fast (GB/sec). There is a really good series of posts that explain how that is achieved.&#xA;Since we consider sorting to be cheap, the rest of the work is just a single scan on the list, and there are no branches at all there. The code plays with the offset that we write into, figuring out whether&#xA0;we need to overwrite the current value (duplicate) or go back (removal), but in general it means that it can execute very quickly.&#xA;This approach also has another really important aspect. Take a look at the actual code that we have in production. This is from about an hour worth of profiling a busy indexing session:&#xA;&#xA;And the more common code path:&#xA;&#xA;In both of them, you&#x2019;ll notice something really important. There isn&#x2019;t a call to sorting at all in here. In fact, when I search for the relevant function, I find:&#xA;&#xA;That is 25 ms out of over an hour.&#xA;How can this be? As efficient as the sorting can be, we are supposed to be calling it a lot.&#xA;Well, consider one scenario, what happens if:&#xA;&#xA;&#xA;There are no removals&#xA;&#xA;&#xA;All additions happen after the last existing item in the list&#xA;&#xA;&#xA;In this case, I don&#x2019;t need to do anything beyond concatenate the lists. I can skip the entire process entirely, just copy the existing and additions to the output and call it a day.&#xA;Even when I do have a lot of removals and complicated merge processes, the code structure means that the CPU can get through this code very quickly. This isn&#x2019;t super friendly for humans to read, but for the CPU, this is chump change.</p>
        </article>
        <article id="article-479">
            <a href="https://www.meziantou.net/turn-off-monitors-when-locking-the-computer.htm" target="_blank">
                <h2 class="title mb-6" id="article-479">Turn off monitors when locking the computer</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 04, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">When I lock my computer, it&#x27;s because I&#x27;m going to leave it for a while. I don&#x27;t want to waste energy by keeping the monitors on and I don&#x27;t like having a useless source of light. So, I want to turn them off automatically when I lock my computer.To turn off monitors on Windows, you can use the Send</p>
        </article>
        <article id="article-480">
            <a href="https://ayende.com/blog/200033-B/not-all-o-1-operations-are-considered-equal" target="_blank">
                <h2 class="title mb-6" id="article-480">Not all O(1) operations are considered equal</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 30, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">At some point in any performance optimization sprint, you are going to run into a super annoying problem: The dictionary.&#xA;The reasoning is quite simple. One of the most powerful optimization techniques is to use a cache, which is usually implemented as a dictionary. Today&#x2019;s tale is about a dictionary, but surprisingly enough, not about a cache.&#xA;Let&#x2019;s set up the background, I&#x2019;m looking at optimizing a big indexing batch deep inside RavenDB, and here is my current focus:&#xA;&#xA;&#xA;&#xA;You can see that the RecordTermsForEntries take 4% of the overall indexing time. That is&#x2026; a lot, as you can imagine.&#xA;What is more interesting here is why. The simplified version of the code looks like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private readonly Dictionary&lt;long, List&lt;RecordedTerm&gt;&gt; _termsPerEntryId = new();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private void RecordTermsForEntries(List&lt;TermInEntryModification&gt; entriesForTerm, long termContainerId)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; entriesForTerm.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var entry = entriesForTerm[i];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  ref var entryTerms = ref CollectionsMarshal.GetValueRefOrAddDefault(_termsPerEntryId, entry.EntryId, out var exists);&#xA;        &#xA;        &#xA;          &#xA;                  if (exists == false)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      entryTerms = new List&lt;RecordedTerm&gt;();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  entryTerms.Add(&#xA;        &#xA;        &#xA;          &#xA;                      new RecordedTerm&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          TermContainerId = recordedTermContainerId&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          RecordTermsForEntries.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Basically, we are registering, for each entry, all the terms that belong to it. This is complicated by the fact that we are doing the process in stages:&#xA;&#xA;Create the entries&#xA;Process the terms for the entries&#xA;Write the terms to persistent storage (giving them the recorded term id)&#xA;Update the entries to record the term ids that they belong to&#xA;&#xA;The part of the code that we are looking at now is the last one, where we already wrote the terms to persistent storage and we need to update the entries. This is needed so when we read them, we&#x2019;ll be able to find the relevant terms.&#xA;At any rate, you can see that this method cost is absolutely dominated by the dictionary call. In fact, we are actually using an optimized method here to avoid doing a TryGetValue() and then Add() in case the value is not already in the dictionary.&#xA;If we actually look at the metrics, this is actually kind of awesome. We are calling the dictionary almost 400 million&#xA0;times and it is able to do the work in under 200 nanoseconds per call.&#xA;That is pretty awesome, but that still means that we have over 2% of our total indexing time spent doing lookups. Can we do better?&#xA;In this case, absolutely. Here is how this works, instead of doing a dictionary lookup, we are going to store a list. And the entry will record the index of the item in the list. Here is what this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private readonly List&lt;List&lt;RecordedTerm&gt;&gt; _termsPerEntryId = new();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private void RecordTermsForEntries(List&lt;TermInEntryModification&gt; entriesForTerm, long termContainerId)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; entriesForTerm.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var entry = entriesForTerm[i];&#xA;        &#xA;        &#xA;          &#xA;                  if(entry.TermsPerEntryIndex == -1)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      entry.TermsPerEntryIndex = _termsPerEntryId.Count;&#xA;        &#xA;        &#xA;          &#xA;                      _termsPerEntryId.Add(new List&lt;RecordedTerm&gt;());&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  ref var entryTerms = ref CollectionsMarshal.AsSpan(_termsPerEntryId)[_termsPerEntryId.TermContainerId];&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;                  entryTerms.Add(&#xA;        &#xA;        &#xA;          &#xA;                      new RecordedTerm&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          TermContainerId = recordedTermContainerId&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          RecordTermsForEntries2.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There isn&#x2019;t much to this process, I admit. I was lucky that in this case, we were able to reorder things in such a way that skipping the dictionary lookup is a viable method.&#xA;In other cases, we would need to record the index at the creation of the entry (effectively reserving the position) and then use that later.&#xA;And the result is&#x2026;&#xA;&#xA;That is pretty good, even if I say so myself. The cost went down from 3.6 microseconds per call to 1.3 microseconds. That is almost 3 folds improvement.</p>
        </article>
        <div class="button flex justify-between">
            <a href="47.html"><span class="back arrow"></span></a>

            <a href="49.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>