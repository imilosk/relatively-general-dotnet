
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 78 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-771">
            <a href="https://andrewlock.net/creating-a-source-generator-part-8-solving-the-source-generator-marker-attribute-problem-part2/" target="_blank">
                <h2 class="title mb-6" id="article-771">Solving the source generator &#x27;marker attribute&#x27; problem - Part 2</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 01, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 8</p>
        </article>
        <article id="article-772">
            <a href="https://www.meziantou.net/parallelize-test-cases-execution-in-xunit.htm" target="_blank">
                <h2 class="title mb-6" id="article-772">Parallelize test cases execution in xUnit</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 31, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you have read my introduction to xUnit.NET, you know that tests are executed sequentially inside a collection. By default, a collection is created per each class. So, all tests in a class are executed sequentially. You may want to execute all tests in parallel to reduce the execution time. A wor</p>
        </article>
        <article id="article-773">
            <a href="https://ayende.com/blog/196385-B/talking-at-carnegie-mellon-database-group-practical-considerations-for-acid-mvcc-storage-engines" target="_blank">
                <h2 class="title mb-6" id="article-773">Talking at Carnegie Mellon Database Group: Practical Considerations for ACID/MVCC Storage Engines</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 28, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Next week I&#x2019;ll be talking at CMU about how to build storage engines and what you need to consider when building them. The talk is open to the public (don&#x2019;t have to be at CMU to be there).Here are the details:Event Date: Monday January 31, 2022Event Time: 04:30pm ESTLocation: https://cmu.zoom.us/j/95002789605?pwd=eEtJRnRaNnQ1bFZmTnUwbDRMaXBRQT09In this talk, Oren Eini, founder of RavenDB, will discuss the design decisons and the manner in which RavenDB deals with storing data on disk.Achieving highly concurrent and transactional system can be a challenging task. RavenDB solves this issue using a storage engine called Voron. We&#x2019;ll go over the design of Voron and how it is able to achieve both high performance and maintain ACID integrity.This talk is part of the Vaccination Database (Booster) Tech Talk Seminar Series.Zoom Link: https://cmu.zoom.us/j/95002789605 (Passcode 982149)</p>
        </article>
        <article id="article-774">
            <a href="https://ardalis.com/web-api-dto-considerations/" target="_blank">
                <h2 class="title mb-6" id="article-774">Web API DTO Considerations</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 25, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">When designing web APIs, it&#x27;s important to think about how the data being passed to and from the endpoint will be structured. How important&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-775">
            <a href="https://andrewlock.net/creating-a-source-generator-part-7-solving-the-source-generator-marker-attribute-problem-part1/" target="_blank">
                <h2 class="title mb-6" id="article-775">Solving the source generator &#x27;marker attribute&#x27; problem - Part 1</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 25, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 7</p>
        </article>
        <article id="article-776">
            <a href="https://ayende.com/blog/196353-A/implementing-a-file-pager-in-zig-pages-buffers-and-metadata-oh-my" target="_blank">
                <h2 class="title mb-6" id="article-776">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 24, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Databases will typically divide their data files into pages, and manage all data in pages. As you can imagine, the notion of pages is pretty important to a database. Up to this point, we worked with pages, but not really. A page was just a buffer that we could read and write to. It took me 13 posts to manage to read and write pages from disk, but that is just the beginning. We need to add some structure for the pages. The usual way to do that is to have a page header, which contains some metadata about the page. That leads to an interesting question, how do we manage the page metadata?&#xA;One way to do that is to reserve a part of the page for this purpose, like so:&#xA;&#xA0;&#xA;This is probably the simplest option (and what we use in Voron), but I don&#x2019;t like it very much. It makes certain operations harder to deal with, because the usable size of the page is no longer a power of 2. Assuming we have 8KB pages and a page header of 64 bytes, that means that we can use just 8,128 bytes in the page. A lot of data structures are far easier to use if we can assume that the size is a power of 2.&#xA;Another thing to remember is that the underlying pager that we use operates on the level of 2 MB chunks. In other words, reading a value from the same 2MB range is as cheap as reading a value from the same 8KB page. For that reason, we can utilize the following approach, we&#x2019;ll reserve the first section of the chunk for all the page headers. Here is what this will look like:&#xA;&#xA0;&#xA;A chunk is 2MB in size, and pages are 8KB. That gives us 256 pages in a chunk. If we reserve the first page for page headers, that gives us 32 bytes for each page header. That is quite a lot, to be honest, which is great, because having more space on the header gives us a lot of options down the road.&#xA;An important consideration to pay attention to is that we read from the disk at 2MB chunks, but when we write, the writes happen at the page boundary. A change on Page #3, for example, means that we have to change both the header page and then page #3 as separate operations. If we were using an embedded page header, we&#x2019;ll have just a single write to deal with. In practice, I don&#x2019;t think this is a major issue. We are doing asynchronous writes and write coalescing anyway. For that matter, writes are actually done lazily (and the critical path goes to the Write Ahead Log anyway) so I don&#x2019;t think this aspect matters so much.&#xA;At any rate, let&#x2019;s get some idea about what the page header will look like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const PageTag = enum(u8) {&#xA;        &#xA;        &#xA;          &#xA;              none = 0,&#xA;        &#xA;        &#xA;          &#xA;              freeSpaceBitmap = 1,&#xA;        &#xA;        &#xA;          &#xA;              metadata = 2,&#xA;        &#xA;        &#xA;          &#xA;              multiPage = 3,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub const PageHeader = extern struct {&#xA;        &#xA;        &#xA;          &#xA;              tag: PageTag,&#xA;        &#xA;        &#xA;          &#xA;              reservedAlignment: [3]u8,&#xA;        &#xA;        &#xA;          &#xA;              data: extern union {&#xA;        &#xA;        &#xA;          &#xA;                  fresSpaceBitmap: extern struct { freePages: u32 },&#xA;        &#xA;        &#xA;          &#xA;                  multiPage: extern struct { pagesCount: u32 },&#xA;        &#xA;        &#xA;          &#xA;                  reserved: [20]u8,&#xA;        &#xA;        &#xA;          &#xA;              },&#xA;        &#xA;        &#xA;          &#xA;              checksum: [8]u8,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn getPageCount(self: *PageHeader) u32 {&#xA;        &#xA;        &#xA;          &#xA;                  return switch (self.tag) {&#xA;        &#xA;        &#xA;          &#xA;                      .none, .metadata =&gt; 1,&#xA;        &#xA;        &#xA;          &#xA;                      .freeSpaceBitmap =&gt; pager.PagesInFile / @bitSizeOf(u8) / pager.PageSize, // 128&#xA;        &#xA;        &#xA;          &#xA;                      .multiPage =&gt; self.data.multiPage.pagesCount,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          comptime {&#xA;        &#xA;        &#xA;          &#xA;              if (@sizeOf(PageHeader) != 32) {&#xA;        &#xA;        &#xA;          &#xA;                  @compileError(std.fmt.comptimePrint(&quot;The PageHeader must be exactly 32 bytes in size but was {}&quot;, .{@sizeOf(PageHeader)}));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PageHeader.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I should note that this is merely a skeleton of the page header, just showing its structure. Over time, we&#x2019;ll add a lot more details, but this is sufficient to understand the direction I&#x2019;m going. A page header is denoted by a tag, which determines what type of page this is. Based on the type of the page, we can set various fields inside the header. You can also see the getPageCount(), which is a good demonstration of how we work with the page header. I need to have fine-grained control over the bytes in the header, so I&#x2019;m setting them up in this manner.&#xA;&#xA;Zig currently has a number of bugs related to packed / extern structs and unions, which make this a bit harder than expected, sadly. I&#x2019;m waiting for the self hosted compiler, which will hopefully fix those issues.&#xA;&#xA;With the PageHeader struct in place, we can start making use of this, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const Page = struct {&#xA;        &#xA;        &#xA;          &#xA;              page: u64,&#xA;        &#xA;        &#xA;          &#xA;              header: *PageHeader,&#xA;        &#xA;        &#xA;          &#xA;              buffer: []u8,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn getPage(p: *pager.Pager, loadedChunks: *pager.Pager.ChunksSet, page: u64, options: pager.GetPageOptions) !Page {&#xA;        &#xA;        &#xA;          &#xA;              const headerPage = (page / pager.PagesInChunk) * pager.PagesInChunk;&#xA;        &#xA;        &#xA;          &#xA;              const headerBytes = try p.getPage(loadedChunks, headerPage, 1, options);&#xA;        &#xA;        &#xA;          &#xA;              const pageIndexInChunk = page % pager.PagesInChunk;&#xA;        &#xA;        &#xA;          &#xA;              const headerEntries: []PageHeader = std.mem.bytesAsSlice(PageHeader, headerBytes);&#xA;        &#xA;        &#xA;          &#xA;              const pageHeader: *PageHeader = &amp;headerEntries[pageIndexInChunk];&#xA;        &#xA;        &#xA;          &#xA;              const pageCount = pageHeader.getPageCount();&#xA;        &#xA;        &#xA;          &#xA;              const buffer = try p.getPage(loadedChunks, page, pageCount, options);&#xA;        &#xA;        &#xA;          &#xA;              return Page{ .page = page, .header = pageHeader, .buffer = buffer };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getPage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There isn&#x2019;t much going on here, which is great, but it does deserve some explanation. We first get the first page in the chunk for the page that was requested. For example, if we wanted to get page # 4, we get page #0, if we wanted to get page # 300, we&#x2019;ll get page #256.&#xA0; That page is the metadata page for the chunk, the only thing that it contains is the headers for all the pages in the chunk in question (including itself, of course).&#xA;The reason that this matters is that the header for the page is used to compute the number of pages that we need to return. As you&#x2019;ll note, the API we have here does not provide a way for the caller to say how many pages should be returned. We need to figure it out on our own. To do that, however, we need to store that information somewhere. That is where the page header comes into place.&#xA;We get the page header of the page we care about from the metadata page of the chunk and compute the number of pages to get from the pager. Then we return to the caller the page header and the page buffer as a single unit.&#xA;Of course, this presupposes that the values got to the pages somehow. That leads us to other directions, however, dealing with page allocations. You can already see some hints of that in the code above, where we use freeSpaceBitmap. I&#x2019;ll dedicate my next post to this topic.</p>
        </article>
        <article id="article-777">
            <a href="https://www.meziantou.net/awaiting-an-async-void-method-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-777">Awaiting an async void method in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 24, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">async void methods are not a good way to define async methods. You should return a Task or ValueTask instead. The main point is to be able to await the method. But, is it possible to await an async void method? I don&#x27;t say you should use async void in your code, I&#x27;m just questioning the point of no</p>
        </article>
        <article id="article-778">
            <a href="https://ayende.com/blog/196321-C/implementing-a-file-pager-in-zig-write-behind-implementation" target="_blank">
                <h2 class="title mb-6" id="article-778">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 21, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the last post, we figured out how we can find what pages we should flush to disk. In this one, I want to talk about how we can actually do the flushing. Once a page is marked as ready for flushing, we need to start an async process in which we write it to the disk. While that process is running, we need to ensure that there are no further writes happening on that page. We want to be able to handle flushing writes in the background with as little fuss as we possibly can, while at the same time maximizing parallelism. That turns out to be a significant challenge. Our previous write strategy simply gathered all the writes in memory and then flushed them to disk. Now we need to have an ongoing process. In addition, we also want to handle the scenario where we flush everything in memory for certain scenarios, such as checkpoints or orderly shutdown.&#xA;In short, the approach we previously took isn&#x2019;t going to be sufficient for our needs. For that reason, I want to clear the board and start from scratch. As a reminder, here is the API that we provide:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            var writer = pager.acquireWriter();&#xA;        &#xA;        &#xA;          &#xA;            defer writer.release();&#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;            writer.write(pageNum, pageBuffer);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The rules for this API are fairly simple. You acquire the writer and then may call the write() method any number of times. The writer will aggregate the writes in memory, and will use write behind to write the data to disk in the background. In other words, we aren&#x2019;t necessarily going to write to the disk when write() is called, only to our own buffer.&#xA;Note that the writer is working using pages, not chunks, even though the buffer pool we use operates on chunks. In addition to the write() method, we have a flush() which pushes everything that is currently in the writer to the disk. That one is meant to be called when we want to create a checkpoint or when we do an orderly shutdown. The flush() call starts an asynchronous process that we can wait upon, so we aren&#x2019;t going to stall on checkpoints.&#xA0; While we write a page to disk, we&#x2019;ll reject any writes to that page. This is important, because to do otherwise will mean that we may send messed up data to disk.&#xA;We also need to handle any and all sequences of writes. For example, consider:&#xA;&#xA;write(2, [1 page]);&#xA0; // write a single page #2&#xA;write(4, [4 pages]);// write 4 pages from page #4 (so pages: 4,5,6,7)&#xA;&#xA;Now, we may actually get additional writes as well:&#xA;&#xA;write(6, [3 pages]);&#xA;write(4, [1 page]);&#xA;&#xA;In other words, there are no requirements from the caller about what should be called and in what order. The caller may write a set of pages and then repurpose them again. In this case, we expect that the end result is that we&#x2019;ll issue the following writes to the disk:&#xA;&#xA;write(2, 1 page);&#xA;write(4, 1 page);&#xA;write(6, 3 pages);&#xA;&#xA;Note that we have page #5, it was written in the first call to page #4 (when it used 4 pages), however, with the update of page #4 to be a single page, the data in page #5 is no longer relevant and we can skip writing it to disk. This is an effect of working with pages. The data doesn&#x2019;t make sense outside of a page boundary, after all, so we should only write meaningful data.&#xA;After spending a lot of time thinking about it, I decided to go with the following behavior: The Pager&#x2019;s writer will manage the write buffers, flushing to the disk when it is time. Callers can decide to let writes happen in the background or to wait for them. Here is the new state of the Writer:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const Writer = struct {&#xA;        &#xA;        &#xA;          &#xA;                  lock: std.Thread.Mutex,&#xA;        &#xA;        &#xA;          &#xA;                  cache: Lru,&#xA;        &#xA;        &#xA;          &#xA;                  parent: *Pager,&#xA;        &#xA;        &#xA;          &#xA;                  inflight: collections.SortedList(*WriteState, sortWriteState),&#xA;        &#xA;        &#xA;          &#xA;                  completed: ?*WriteState,&#xA;        &#xA;        &#xA;          &#xA;                  backgroundWrites: std.atomic.Atomic(u32),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Writer.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There are a few interesting fields here:&#xA;&#xA;The lock is there to ensure that we have only a single writer. As a reminder, the actual I/O is asynchronous.&#xA;The cache implements an Lru with a twist, I improved on that since the last post, more on this later.&#xA;The parent field is the owning pager, obviously.&#xA;The last three fields (inflight, completed and backgroundWrites) are all about handling the asynchronous writes for us.&#xA;&#xA;Let&#x2019;s take a look at how we handle the state for a particular write and then we&#x2019;ll be able to discuss the implementation in depth:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const WriteState = struct {&#xA;        &#xA;        &#xA;          &#xA;                page: u64,&#xA;        &#xA;        &#xA;          &#xA;                count: u32,&#xA;        &#xA;        &#xA;          &#xA;                writer: *Writer,&#xA;        &#xA;        &#xA;          &#xA;                chunks: ChunksSet = .{},&#xA;        &#xA;        &#xA;          &#xA;                err: ?anyerror = null,&#xA;        &#xA;        &#xA;          &#xA;                list: *Lru.List = undefined,&#xA;        &#xA;        &#xA;          &#xA;                next: ?*WriteState = null,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          WriteState.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;On the surface, the WriteState is pretty simple. It contains the page we are writing and how many pages are involved in a particular write, but there are also quite a few additional fields that are&#x2026; strange. The writer field is used when we are returning from a callback, the chunks are&#xA0;used to record which chunks are relevant for this particular write (remember, the Writer operates at the page level, while the Pager operates at the chunk level). Because we deal with individual pages, we have to ensure that each one of them has its own reference for the chunk in question. That also has the effect of pinning any dirty pages in memory until they are flushed to disk. The err field holds whether there was an error (and what was it) when writing to the disk. The list field is used in conjunction with the write behind policy and will be discussed shortly. We use the next field to create a single linked list with the head being the completed field on the Writer.&#xA;With that in mind, let&#x2019;s look at how the write() method is implemented:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn write(self: *Writer, page: u64, buffer: []u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              std.debug.assert(buffer.len % FileChunks.PageSize == 0);&#xA;        &#xA;        &#xA;          &#xA;              const allocator = self.parent.allocator;&#xA;        &#xA;        &#xA;          &#xA;              const count = @intCast(u32, buffer.len / FileChunks.PageSize);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              _ = try self.drainCompleted();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.ensureNotWrittenTo(page, count);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (self.cache.get(page)) |ws| {&#xA;        &#xA;        &#xA;          &#xA;                  // can just update the buffer...&#xA;        &#xA;        &#xA;          &#xA;                  if (ws.count == count) {&#xA;        &#xA;        &#xA;          &#xA;                      var cachedBuffer = try self.parent.getPage(&amp;ws.chunks, page, count, .{ .forWrites = true });&#xA;        &#xA;        &#xA;          &#xA;                      std.mem.copy(u8, cachedBuffer, buffer);&#xA;        &#xA;        &#xA;          &#xA;                      return;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (self.cache.remove(allocator, page)) |removed| {&#xA;        &#xA;        &#xA;          &#xA;                      // previous was the wrong size, so can just discard&#xA;        &#xA;        &#xA;          &#xA;                      try removed.deinit(self);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  const state = try allocator.create(WriteState);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer allocator.destroy(state);&#xA;        &#xA;        &#xA;          &#xA;                  state.* = .{ .writer = self, .page = page, .count = count };&#xA;        &#xA;        &#xA;          &#xA;                  var cachedBuffer = try self.parent.getPage(&amp;state.chunks, page, count, .{ .forWrites = true });&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, cachedBuffer, buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.cache.push(allocator, state);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              while (self.cache.evictOverflow(allocator)) |ws| {&#xA;        &#xA;        &#xA;          &#xA;                  try self.writePageToDisk(ws);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          write.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We start by draining any completed writes. It is important to detect any errors and to release the references from the chunks we locked during the write portion. We treat any error during the write process as fatal and abort immediately. At this point, we don&#x2019;t know what the state of the system is. The only safe way to handle this is to shutdown and run recovery.&#xA;The next step is ensureNotWrittenTo() call. This is required because we may be in the process of writing a page to the disk, and we cannot modify the memory for that page (or pages) while they are being written to the disk. This is a recoverable error, by the way. The caller should wait until the pending writes are complete and retry.&#xA;We then check in the cache if the page is already there. If it is, we have to consider the potential for a mismatch in the sizes (described earlier in this post), when we have a previous write that spanned three pages but the current one only applies to a single page. Since the page boundary is important, we can just discard the previous write and continue. For the common case of a write to a page that was previously written to, however, we can simply copy the data from the provided buffer to the right page in memory and move on. Most of the hot pages should fit into this code path.&#xA;We then allocate the state for the current write, get the page (or pages) and copy the data from the provided buffer to our own memory. We also, crucially, push the new state into the writer&#x2019;s cache. In the previous post that action would evict a page that we need to handle. In the current code, that is handled at the epilog of the method.&#xA;We iterate over the cache and evict any pages that don&#x2019;t fit into the cache any longer. This is because a single write may evict multiple pages. If we have space for 32KB, and we currently have 4 separate pages in the cache, we are full. Adding a write for 2 pages, however, will need to evict two items out of the cache. Another aspect that I changed from the last post is that I&#x2019;m no longer requiring that the current page will not be evicted immediately.&#xA;I mentioned that I changed the Lru&#x2019;s implementation significantly.&#xA0; Previously it was fairly generic, but it turns out that it is better to specialize it specifically for our needs. Here is the current version:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const Lru = struct {&#xA;        &#xA;        &#xA;          &#xA;                const List = struct {&#xA;        &#xA;        &#xA;          &#xA;                    list: collections.DoublyLinkedList(*WriteState) = .{},&#xA;        &#xA;        &#xA;          &#xA;                    used: usize = 0,&#xA;        &#xA;        &#xA;          &#xA;                    max: usize,&#xA;        &#xA;        &#xA;          &#xA;                };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                young: List,&#xA;        &#xA;        &#xA;          &#xA;                old: List,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                map: std.AutoHashMapUnmanaged(u64, *collections.DoublyLinkedList(*WriteState).Node) = .{},&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Lru.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This Lru is implemented using a generational approach. The idea is that we can specify the sizes of the young and old generations independently. A new page that is added to the cache is written to the young generation. If there is another write to the page, it will be moved to the old generation. If the size of the data in each generation is too big, we use a simple Least Recently Used to evict items. An item that expired on the old generation will be moved to the young generation, while an item that expires from the young generation will be evicted completely. Here is how this looks like in code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn get(self: *Lru, page: u64) ?*WriteState {&#xA;        &#xA;        &#xA;          &#xA;              if (self.map.get(page)) |existing| {&#xA;        &#xA;        &#xA;          &#xA;                  const item = existing.item;&#xA;        &#xA;        &#xA;          &#xA;                  if (item.list != &amp;self.old) {&#xA;        &#xA;        &#xA;          &#xA;                      item.list.used -= item.count * FileChunks.PageSize;&#xA;        &#xA;        &#xA;          &#xA;                      item.list.list.evict(existing);&#xA;        &#xA;        &#xA;          &#xA;                      item.list = &amp;self.old;&#xA;        &#xA;        &#xA;          &#xA;                      self.old.used &#x2B;= item.count * FileChunks.PageSize;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  self.old.list.moveFirst(existing);&#xA;        &#xA;        &#xA;          &#xA;                  return existing.item;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return null;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn push(self: *Lru, allocator: std.mem.Allocator, item: *WriteState) !void {&#xA;        &#xA;        &#xA;          &#xA;              std.debug.assert(self.map.get(item.page) == null);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var node = try self.young.list.prepend(allocator, item);&#xA;        &#xA;        &#xA;          &#xA;              item.list = &amp;self.young;&#xA;        &#xA;        &#xA;          &#xA;              self.young.used &#x2B;= item.count * FileChunks.PageSize;&#xA;        &#xA;        &#xA;          &#xA;              try self.map.put(allocator, item.page, node);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn evictOverflow(self: *Lru, allocator: std.mem.Allocator) ?*WriteState {&#xA;        &#xA;        &#xA;          &#xA;              if (self.old.used &gt; self.old.max) {&#xA;        &#xA;        &#xA;          &#xA;                  if (self.old.list.evictLast()) |e| {&#xA;        &#xA;        &#xA;          &#xA;                      self.young.list.moveFirst(e);&#xA;        &#xA;        &#xA;          &#xA;                      self.young.used &#x2B;= e.item.count * FileChunks.PageSize;&#xA;        &#xA;        &#xA;          &#xA;                      self.old.used -= e.item.count * FileChunks.PageSize;&#xA;        &#xA;        &#xA;          &#xA;                      e.item.list = &amp;self.young;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.young.used &gt; self.young.max) {&#xA;        &#xA;        &#xA;          &#xA;                  if (self.young.list.popLast(allocator)) |e| {&#xA;        &#xA;        &#xA;          &#xA;                      self.young.used -= e.count * FileChunks.PageSize;&#xA;        &#xA;        &#xA;          &#xA;                      return e;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return null;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Lru.imp.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is the same rough algorithm used by MySQL. The advantage here is that there is O(1) cost for the entire process, but at the same time, busy pages actually have a good chance of not being written to the disk (which is ideal, since if they are busy, they keep changing). To give some context to the sizes involved, we may decide that the old generation contains 192 MB and the young generation is 64 MB. A page write will remain in the young generation until we have another 64 MB (8,192 individual page writes), if there were any writes to it again in that time frame, it will go to the old generation. Only if we didn&#x27;t have any writes to it in that time frame will we flush it to disk. Once a page was moved to the old generation, it has to go through a buffer of 256 MB (32K page writes) before it will go to the disk. Hot pages should be safe from spurious writes, especially since we&#x2019;ll write them to the disk anyway whenever we do a checkpoint.&#xA;When a page is evicted from the cache, the writePageToDisk() method is called on it, there is a bit of work going on here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn writePageToDisk(self: *Writer, ws: *WriteState) !void {&#xA;        &#xA;        &#xA;          &#xA;              // merge backward&#xA;        &#xA;        &#xA;          &#xA;              while (ws.page &gt; 0 and&#xA;        &#xA;        &#xA;          &#xA;                  try self.tryMergePages(ws, ws.page - 1))&#xA;        &#xA;        &#xA;          &#xA;              {}&#xA;        &#xA;        &#xA;          &#xA;              // merge forward&#xA;        &#xA;        &#xA;          &#xA;              while (try self.tryMergePages(ws, ws.page &#x2B; ws.count)) {}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.inflight.add(self.parent.allocator, ws);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var pageBuffer = try self.parent.getPage(&amp;ws.chunks, ws.page, ws.count, .{});&#xA;        &#xA;        &#xA;          &#xA;              _ = self.backgroundWrites.fetchAdd(1, .Release);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var fileIdx = ws.page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              var file = self.parent.files[fileIdx] orelse return error.FileIsNotLoaded;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.parent.ring.submit(.{&#xA;        &#xA;        &#xA;          &#xA;                  .tag = .Write,&#xA;        &#xA;        &#xA;          &#xA;                  .fd = file.fd,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = pageBuffer,&#xA;        &#xA;        &#xA;          &#xA;                  .offset = (ws.page % FileChunks.PagesInFile),&#xA;        &#xA;        &#xA;          &#xA;                  .context = @ptrToInt(ws),&#xA;        &#xA;        &#xA;          &#xA;                  .callback = completeFlushCallback,&#xA;        &#xA;        &#xA;          &#xA;              }) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;                  // we aren&#x27;t removing the inflight record, an error here is probably&#xA;        &#xA;        &#xA;          &#xA;                  // fatal, and we already merged pages, so we can&#x27;t revert the state&#xA;        &#xA;        &#xA;          &#xA;                  self.backgroundWrites.fetchSub(1, .Release); &#xA;        &#xA;        &#xA;          &#xA;                  return e;&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn tryMergePages(self: *Writer, cur: *WriteState, page: u64) !bool {&#xA;        &#xA;        &#xA;          &#xA;              var curFileIdx = cur.page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              var fileIdx = page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              if (curFileIdx != fileIdx)&#xA;        &#xA;        &#xA;          &#xA;                  return false;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (self.cache.remove(self.parent.allocator, page)) |p| {&#xA;        &#xA;        &#xA;          &#xA;                  cur.page = std.math.min(cur.page, page);&#xA;        &#xA;        &#xA;          &#xA;                  cur.count &#x2B;= p.count;&#xA;        &#xA;        &#xA;          &#xA;                  // move chunk ownership&#xA;        &#xA;        &#xA;          &#xA;                  var it = p.chunks.keyIterator();&#xA;        &#xA;        &#xA;          &#xA;                  while (it.next()) |c| {&#xA;        &#xA;        &#xA;          &#xA;                      try cur.chunks.put(self.parent.allocator, c.*, {});&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  try p.deinit(self);&#xA;        &#xA;        &#xA;          &#xA;                  return true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return false;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          writePageToDisk.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;An important observation about writing to the disk is that coalescing writes can have a huge impact on performance. Instead of having to go to the disk multiple times, we can schlepp the data there just once. The amount of the data we write is actually far less significant than what you may expect. You can see that the first thing that we do is to try to merge the pages (both forward and backward). If we find a candidate, we expand our own WriteState and release the one that subsumed. This is an important aspect, because the writes we send to the disk don&#x2019;t necessarily match the old / young&#xA0;generations division. If we evicted a page that is adjacent to another modified page, we&#x2019;ll write them both to the disk. That is even if the second page is in the old generation (and that will evict the page from the write cache). In practice, databases exhibit a lot of locality, so I don&#x2019;t expect that to be an actual issue.&#xA;The last thing we do before actually submitting the I/O operation is to register the write in the inflight record. This is basically a sorted list (by the first page for that write) which we&#x2019;ll check on any future writes. We also increment the number of background writes we have so we&#x2019;ll know to wait for them to complete. Note that if we fail to submit the I/O, we decrement the number of backgroundWrites, we use this value to wait for async operations (for example, during shutdown). And since such errors are probably fatal, we are heading that way soon.&#xA;The actual I/O happens in the background and we&#x2019;ll call the callback function when that is done (either successfully or with an error). So far, all the code we saw was single threaded and protected by the lock mutex. The callback, on the other hand, is running without any such protections. Furthermore, the callback thread is running all the notifications we have. We want to do as little as possible there. Here is what I ended up with:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn completeFlushCallback(work: *PagerRing.Work) void {&#xA;        &#xA;        &#xA;          &#xA;              // this is called from background thread, without the lock!&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // we need to do minimal amount of work here&#xA;        &#xA;        &#xA;          &#xA;              var ws = @intToPtr(*WriteState, work.context);&#xA;        &#xA;        &#xA;          &#xA;              var self = ws.writer;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  ws.next = @atomicLoad(?*WriteState, &amp;self.completed, .Acquire);&#xA;        &#xA;        &#xA;          &#xA;                  const result = @cmpxchgWeak(?*WriteState, &amp;self.completed, ws.next, ws, .AcqRel, .Acquire);&#xA;        &#xA;        &#xA;          &#xA;                  if (result == null) {&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  // failed to update, need to retry&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // now can wake any waiters...&#xA;        &#xA;        &#xA;          &#xA;              _ = self.backgroundWrites.fetchSub(1, .Release);&#xA;        &#xA;        &#xA;          &#xA;              std.Thread.Futex.wake(&amp;self.backgroundWrites, std.math.maxInt(u32));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          completeFlushCallback.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We register the completed write in the completed linked list and wake any pending waiters. Any actual processing, of course, is moved to the part of the process where we actually run under lock and don&#x2019;t have to worry about concurrency and multi threading. The actual behavior around completing writes is implemented in the drainCompleted() call that is part of the write() call.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn drainCompleted(self: *Writer) !bool {&#xA;        &#xA;        &#xA;          &#xA;              var hasAny = false;&#xA;        &#xA;        &#xA;          &#xA;              while (@atomicLoad(?*WriteState, &amp;self.completed, .Acquire)) |done| {&#xA;        &#xA;        &#xA;          &#xA;                  if (@cmpxchgWeak(?*WriteState, &amp;self.completed, done, done.next, .AcqRel, .Acquire)) |_| {&#xA;        &#xA;        &#xA;          &#xA;                      // failed to update, need to retry&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  hasAny = true;&#xA;        &#xA;        &#xA;          &#xA;                  _ = self.inflight.remove(done);&#xA;        &#xA;        &#xA;          &#xA;                  if (done.err) |err| {&#xA;        &#xA;        &#xA;          &#xA;                      done.deinit(self) catch {&#xA;        &#xA;        &#xA;          &#xA;                          // return the original error, if it happened&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                      return err; // we abort on the first error&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  try done.deinit(self);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return hasAny;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          drainCompleted.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Even though we are under lock, the I/O completion may compete with us on the completed list, so we&#x2019;re using lock free methods to iterate through the list of completed actions. The actual behavior is straightforward, we remove the write from the list of inflight writes and return an error if the write had a problem. Note that we have to deal with potentially nested errors as well.&#xA0; Aside from calling this as part of the write call(), we may also want to explicitly wait for all the pending operations to complete. This is done using the waitForWrites() call:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn waitForWrites(self: *Writer, timeout: ?u64) !bool {&#xA;        &#xA;        &#xA;          &#xA;              var hasAny = false;&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  if (try self.drainCompleted()) {&#xA;        &#xA;        &#xA;          &#xA;                      hasAny = true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var pending = self.backgroundWrites.load(.Acquire);&#xA;        &#xA;        &#xA;          &#xA;                  if (pending == 0)&#xA;        &#xA;        &#xA;          &#xA;                      return hasAny;&#xA;        &#xA;        &#xA;          &#xA;                  try std.Thread.Futex.wait(&amp;self.backgroundWrites, pending, timeout);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          waitForWrites.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We drain all the completed writes and then wait for any pending ones to complete as well. We repeat this until there are no more backgroundWrites. Note that we run this under the lock, so we know that there can never be additional writes happening.&#xA;In special circumstances, we may want to ask the writer to push everything to the disk, we do that by calling the checkpoint() method:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn checkpoint(self: *Writer, timeout: ?u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              // first, clear all pending writes to disk...&#xA;        &#xA;        &#xA;          &#xA;              while (self.cache.evictYoungest()) |ws| {&#xA;        &#xA;        &#xA;          &#xA;                  try self.writePageToDisk(ws);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // now wait for them to complete&#xA;        &#xA;        &#xA;          &#xA;              _ = try self.waitForWrites(timeout);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          checkpoint.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is almost nothing there, I&#x2019;m happy to say, we are almost done. We evict pages from the cache from the youngest to the oldest, using the same write coalescing as before. Given write locality, that is likely to produce good results. We complete the process by waiting for all those writes to complete, and we are done.&#xA;There is just one last topic that I want to cover: Shutting&#xA0; down:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn deinit(self: *Writer, allocator: std.mem.Allocator) void {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  self.waitForWrites(null) catch {&#xA;        &#xA;        &#xA;          &#xA;                      // if we are here, the waitForWrites returned an error&#xA;        &#xA;        &#xA;          &#xA;                      // however, we still need to drain the whole queue of async&#xA;        &#xA;        &#xA;          &#xA;                      // operations, otherwise, we may have a memory leak.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      // an error at this stage on the write isn&#x27;t something that we&#xA;        &#xA;        &#xA;          &#xA;                      // *can* handle, and we are tearing down the writer anyway&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // we just discard the pending writes at this point, caller should either&#xA;        &#xA;        &#xA;          &#xA;              // call checkpoint() or will run recovery on startup&#xA;        &#xA;        &#xA;          &#xA;              while (self.cache.evictYoungest(allocator)) |e| {&#xA;        &#xA;        &#xA;          &#xA;                  e.deinit(self) catch {&#xA;        &#xA;        &#xA;          &#xA;                      // nothing that we can do about this&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.cache.deinit(allocator);&#xA;        &#xA;        &#xA;          &#xA;              self.inflight.deinit(allocator);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          deinit.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Shutting down turns out to be a fairly involved process. This is especially the case if we are shutting down because of an error. We need to wait until all the pending writes have been completed (to do otherwise is to invite Use-After-Free bugs). That is why we call the waitForWrites() until it completes successfully. At worst, each time this is called will process a single write.&#xA;On shutdown, we can&#x2019;t really start writing to the disk (after all, we may be shutting down because of the disk). We just discard the data in this case. That is something that we are okay to do, because we assume that any important data can be restored when we run recovery. This is one of those cases where the fact that we are building a database makes our life easier. We don&#x2019;t need to try very hard to persist to disk, we can assume that as a given.&#xA;I&#x2019;m pretty happy with how all this turned out. The full code for the pager is now at around 1,500 lines of code. I think that at this point we are pretty much at or near what you&#x2019;ll need to replace the mmap() based pager that I demonstrated earlier in this series. This is the sort of code that needs a metric ton of tests, of course, and a lot of actual experience throwing stuff at it. The nice thing about this approach is that this is entirely in our hands. We can now implement whatever policies we want. The actual behavior is more or less done, but we can play with the exact mechanics and what will trigger what at will. In some cases, that can give us a great deal of power and flexibility.</p>
        </article>
        <article id="article-779">
            <a href="https://ayende.com/blog/196289-C/dont-assume-the-result-of-read" target="_blank">
                <h2 class="title mb-6" id="article-779">Don&#x2019;t assume the result of read()</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 20, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I read this post and it took me very little time to spot a pretty nasty bug. Here is the relevant section:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          loop {&#xA;        &#xA;        &#xA;          &#xA;              let read_count = encrypted_file.read(&amp;mut buffer)?;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if read_count == BUFFER_LEN {&#xA;        &#xA;        &#xA;          &#xA;                  let plaintext = stream_decryptor&#xA;        &#xA;        &#xA;          &#xA;                      .decrypt_next(buffer.as_slice())&#xA;        &#xA;        &#xA;          &#xA;                      .map_err(|err| anyhow!(&quot;Decrypting large file: {}&quot;, err))?;&#xA;        &#xA;        &#xA;          &#xA;                  dist_file.write(&amp;plaintext)?;&#xA;        &#xA;        &#xA;          &#xA;              } else if read_count == 0 {&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              } else {&#xA;        &#xA;        &#xA;          &#xA;                  let plaintext = stream_decryptor&#xA;        &#xA;        &#xA;          &#xA;                      .decrypt_last(&amp;buffer[..read_count])&#xA;        &#xA;        &#xA;          &#xA;                      .map_err(|err| anyhow!(&quot;Decrypting large file: {}&quot;, err))?;&#xA;        &#xA;        &#xA;          &#xA;                  dist_file.write(&amp;plaintext)?;&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          bug.rs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The bug is on line #4. The code assumes that a call to read() will return less than the requested number of bytes only at the end of the file. The problem with that approach is that this is explicitly documented to not work this way:&#xA;&#xA;It is not an error if the returned value n is smaller than the buffer size, even when the reader is not at the end of the stream yet. This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.&#xA;&#xA;This is a super common error in many cases. And in the vast majority of the cases, that would work. Except when it wouldn&#x2019;t.&#xA;The underlying implementation of File::read() will call read() or ReadFile(). ReadFile() (Windows) is documented to read as much as you requested, unless you hit the end of file. The read() call, on Unix, is documented to allow returning less than requested:&#xA;&#xA;It is not an error if this number is smaller than the number of bytes requested&#xA;&#xA;Aside from signals, the file system is free to do a partial read if it has some of the data in memory and some not. I&#x2019;m not sure if this is implemented in this manner, but it is allowed to do so. And the results for the code above in this case are absolutely catastrophic (decryption will fail, encryption will emit partial information with no error, etc).&#xA;I&#x2019;m writing this blog post because reading the code made the error jump at me. Was bitten by this assumption too many times.</p>
        </article>
        <article id="article-780">
            <a href="https://ardalis.com/generate-ssh-rsa-keys-windows-wsl/" target="_blank">
                <h2 class="title mb-6" id="article-780">Generate SSH RSA Key Pairs on Windows with WSL</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 20, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Secure Shell Protocol (SSH) keys provide an alternate way to authenticate with many services like GitHub. Creating them on Windows is simple&#x2026;Keep Reading &#x2192;</p>
        </article>
        <div class="button flex justify-between">
            <a href="77.html"><span class="back arrow"></span></a>

            <a href="79.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>