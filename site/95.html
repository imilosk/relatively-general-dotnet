
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 95 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-941">
            <a href="https://ayende.com/blog/196289-C/dont-assume-the-result-of-read" target="_blank">
                <h2 class="title mb-6" id="article-941">Don&#x2019;t assume the result of read()</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 20, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I read this post and it took me very little time to spot a pretty nasty bug. Here is the relevant section:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          loop {&#xA;        &#xA;        &#xA;          &#xA;              let read_count = encrypted_file.read(&amp;mut buffer)?;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if read_count == BUFFER_LEN {&#xA;        &#xA;        &#xA;          &#xA;                  let plaintext = stream_decryptor&#xA;        &#xA;        &#xA;          &#xA;                      .decrypt_next(buffer.as_slice())&#xA;        &#xA;        &#xA;          &#xA;                      .map_err(|err| anyhow!(&quot;Decrypting large file: {}&quot;, err))?;&#xA;        &#xA;        &#xA;          &#xA;                  dist_file.write(&amp;plaintext)?;&#xA;        &#xA;        &#xA;          &#xA;              } else if read_count == 0 {&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              } else {&#xA;        &#xA;        &#xA;          &#xA;                  let plaintext = stream_decryptor&#xA;        &#xA;        &#xA;          &#xA;                      .decrypt_last(&amp;buffer[..read_count])&#xA;        &#xA;        &#xA;          &#xA;                      .map_err(|err| anyhow!(&quot;Decrypting large file: {}&quot;, err))?;&#xA;        &#xA;        &#xA;          &#xA;                  dist_file.write(&amp;plaintext)?;&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          bug.rs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The bug is on line #4. The code assumes that a call to read() will return less than the requested number of bytes only at the end of the file. The problem with that approach is that this is explicitly documented to not work this way:&#xA;&#xA;It is not an error if the returned value n is smaller than the buffer size, even when the reader is not at the end of the stream yet. This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.&#xA;&#xA;This is a super common error in many cases. And in the vast majority of the cases, that would work. Except when it wouldn&#x2019;t.&#xA;The underlying implementation of File::read() will call read() or ReadFile(). ReadFile() (Windows) is documented to read as much as you requested, unless you hit the end of file. The read() call, on Unix, is documented to allow returning less than requested:&#xA;&#xA;It is not an error if this number is smaller than the number of bytes requested&#xA;&#xA;Aside from signals, the file system is free to do a partial read if it has some of the data in memory and some not. I&#x2019;m not sure if this is implemented in this manner, but it is allowed to do so. And the results for the code above in this case are absolutely catastrophic (decryption will fail, encryption will emit partial information with no error, etc).&#xA;I&#x2019;m writing this blog post because reading the code made the error jump at me. Was bitten by this assumption too many times.</p>
        </article>
        <article id="article-942">
            <a href="https://ardalis.com/generate-ssh-rsa-keys-windows-wsl/" target="_blank">
                <h2 class="title mb-6" id="article-942">Generate SSH RSA Key Pairs on Windows with WSL</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 20, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Secure Shell Protocol (SSH) keys provide an alternate way to authenticate with many services like GitHub. Creating them on Windows is simple&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-943">
            <a href="https://ayende.com/blog/196257-C/implementing-a-file-pager-in-zig-write-behind-policies" target="_blank">
                <h2 class="title mb-6" id="article-943">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 19, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post I outlined some ideas about how to implement a more efficient write behind. The idea is that whenever we write pages to the Pager, we&#x2019;ll not trigger an immediate write to the disk. Instead, we&#x2019;ll keep the data in memory and only write to the disk when we hit a certain threshold. In many write scenarios, there are certain pages that are modified a lot (like the root page in a B&#x2B;Tree) and pages that are modified rarely (a leaf page that got entries and will not be modified again). There is no point in writing the popular page to the disk, we&#x2019;ll likely get another write to them shortly anyway. That calls to a Least Frequently Modified approach.&#xA;We don&#x2019;t need to use a more complex approach, (like the Clock Sweep algorithm we use for the Pager), because we don&#x2019;t have to deal with the same scenarios. There are not likely to be cases similar to scans, which throws a lot of complexities of buffer pool implementations. Writes operations are far more predictable in general and follow a pretty strict power law distribution. The task is simple: we have the list of pages that were modified, and at capacity, we&#x2019;ll select some to send to the disk. The question is how to make that decision.&#xA;The simplest option is to go with the least recently used model. That is trivial to implement, The idea is that we have the following sequence of writes (assuming we have a capacity of 4 pages):&#xA;&#xA;1, 2, 3, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 4, 4, 2, 1, 6&#xA;&#xA;In this case, the page that will be selected for eviction is #3, since it wasn&#x2019;t modified the longest. The other alternative is to use least frequently used, in which case we have the following frequency table:&#xA;&#xA;&#xA;&#xA;Page&#xA;Usages&#xA;&#xA;&#xA;1&#xA;4&#xA;&#xA;&#xA;2&#xA;5&#xA;&#xA;&#xA;3&#xA;4&#xA;&#xA;&#xA;4&#xA;3&#xA;&#xA;&#xA;6&#xA;1&#xA;&#xA;&#xA;&#xA;In this case, we&#x2019;ll want to select page #4 for eviction. Since it is the one least used. (We don&#x27;t consider #6 because it is the one we just inserted). I can make arguments for both sides, to be frank. It makes&#xA0;sense that the least frequently used is going to be the most relevant, right? The problem is that we need to also account for decaying usage over time. What do I mean by this?&#xA;We may have a page that is very hot, it gets used a lot for a certain period of time. After that point, however, it is no longer being written to, but because it was frequently used, it will take a long time to evict from the pool. A good example of such a scenario is when we have a B&#x2B;Tree and we are inserting values in ascending orders. All the values for the tree are going to be placed in the same page, so if we have a lot of inserts, that page is going to be hot. Once it is full, however, we&#x2019;ll start using another page as the target and then the page will reside in memory until some other page will have more usage.&#xA0; A good discussion of least frequency used implementation is in this blog post.&#xA;A nice way to deal with the issue of decaying priorities over time in an LFU setup is to use the following formula to compute the priority of the pages:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const NodePriority = struct &#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            prevAccess: u64, &#xA;        &#xA;        &#xA;          &#xA;            deltaSum  : u64,&#xA;        &#xA;        &#xA;          &#xA;            usages    : u64,&#xA;        &#xA;        &#xA;          &#xA;            priority  : u64&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            fn computePriority(self: *NodePriority) void {&#xA;        &#xA;        &#xA;          &#xA;               var now = @intCast(u64, std.time.milliTimestamp());&#xA;        &#xA;        &#xA;          &#xA;               if(self.prevAccess == 0) {&#xA;        &#xA;        &#xA;          &#xA;                    self.prevAccess = now - std.time.ms_per_s * 60;&#xA;        &#xA;        &#xA;          &#xA;               }&#xA;        &#xA;        &#xA;          &#xA;               var delta = now - self.prevAccess;&#xA;        &#xA;        &#xA;          &#xA;               self.deltaSum &#x2B;= delta;&#xA;        &#xA;        &#xA;          &#xA;               self.usages &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;               &#xA;        &#xA;        &#xA;          &#xA;               self.priority = now - (self.deltaSum / self.usages);&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          priority.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is that we compute the priority of the page based on the last access, so we are very close to the most recently used option. However, note that we compute the distance between accesses to the page. A page that is infrequently accessed will have low usages and a high delta sum. That will reduce its priority. Conversely, a page that is heavily used will have a low delta sum and high usage, so its value will be near the top.&#xA;Another option is to go with another clock sweep option. In this case, we use a simple least recently used model, but we keep count of the frequency of usages. In that case, if we have to evict a page that is heavily used, we can reduce its usages and give it another chance. The advantage here is that this is a far simpler model to work with, but gives roughly the same results. Another option we have is to use the midpoint insertion LRU.&#xA;There is also another consideration to take. The I/O cost isn&#x2019;t linear. If I&#x2019;m writing page #3 to disk, it is basically free from my perspective to write nearby pages. It is the same exact cost, after all, so why not do that?&#xA;We&#x2019;ll need to write our own doubly linked list. The Zig&#x2019;s standard library only contains a single linked list. It doesn&#x2019;t take long to write such a data structure, but it is fun to do so. I absolutely get why implementing linked lists used to be such a common practice in interviews:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn DoublyLinkedList(comptime T: type) type {&#xA;        &#xA;        &#xA;          &#xA;              return struct {&#xA;        &#xA;        &#xA;          &#xA;                  const Self = @This();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub const Node = struct {&#xA;        &#xA;        &#xA;          &#xA;                      next: ?*Node,&#xA;        &#xA;        &#xA;          &#xA;                      prev: ?*Node,&#xA;        &#xA;        &#xA;          &#xA;                      item: T,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      pub fn removeFromSiblings(node: *Node) void {&#xA;        &#xA;        &#xA;          &#xA;                          if (node.prev) |prev| {&#xA;        &#xA;        &#xA;          &#xA;                              prev.next = node.next;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          if (node.next) |next| {&#xA;        &#xA;        &#xA;          &#xA;                              next.next = node.prev;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  head: ?*Node = null,&#xA;        &#xA;        &#xA;          &#xA;                  tail: ?*Node = null,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn deinit(self: *Self, allocator: std.mem.Allocator) void {&#xA;        &#xA;        &#xA;          &#xA;                      while (self.head) |n| {&#xA;        &#xA;        &#xA;          &#xA;                          self.head = n.next;&#xA;        &#xA;        &#xA;          &#xA;                          allocator.destroy(n);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn prepend(self: *Self, allocator: std.mem.Allocator, item: T) !*Node {&#xA;        &#xA;        &#xA;          &#xA;                      var node = try allocator.create(Node);&#xA;        &#xA;        &#xA;          &#xA;                      errdefer allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                      node.* = .{ .next = self.head, .prev = null, .item = item };&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head) |head| {&#xA;        &#xA;        &#xA;          &#xA;                          head.prev = node;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail == null) {&#xA;        &#xA;        &#xA;          &#xA;                          self.tail = node;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      self.head = node;&#xA;        &#xA;        &#xA;          &#xA;                      return node;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn append(self: *Self, allocator: std.mem.Allocator, item: T) !*Node {&#xA;        &#xA;        &#xA;          &#xA;                      var node = try allocator.create(Node);&#xA;        &#xA;        &#xA;          &#xA;                      errdefer allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                      node.* = .{ .next = null, .prev = self.tail, .item = item };&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail) |tail| {&#xA;        &#xA;        &#xA;          &#xA;                          tail.next = node;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head == null) {&#xA;        &#xA;        &#xA;          &#xA;                          self.head = node;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      self.tail = node;&#xA;        &#xA;        &#xA;          &#xA;                      return node;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn moveFirst(self: *Self, node: *Node) void {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head == node)&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail == node) {&#xA;        &#xA;        &#xA;          &#xA;                          self.tail = node.prev;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      node.removeFromSiblings();&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head) |h| {&#xA;        &#xA;        &#xA;          &#xA;                          h.prev = node;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      node.next = self.head;&#xA;        &#xA;        &#xA;          &#xA;                      self.head = node;&#xA;        &#xA;        &#xA;          &#xA;                      node.prev = null;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn moveLast(self: *Self, node: *Node) void {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail == node)&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head == node) {&#xA;        &#xA;        &#xA;          &#xA;                          self.head = node.next;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      node.removeFromSiblings();&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail) |t| {&#xA;        &#xA;        &#xA;          &#xA;                          t.next = node;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      node.prev = self.tail;&#xA;        &#xA;        &#xA;          &#xA;                      self.tail = node;&#xA;        &#xA;        &#xA;          &#xA;                      node.next = null;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn remove(self: *Self, allocator: std.mem.Allocator, node: *Node) void {&#xA;        &#xA;        &#xA;          &#xA;                      defer allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                      node.removeFromSiblings();&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head == node) {&#xA;        &#xA;        &#xA;          &#xA;                          self.head = node.next;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail == node) {&#xA;        &#xA;        &#xA;          &#xA;                          self.tail = node.prev;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub const IteratorDirection = enum { forward, backward };&#xA;        &#xA;        &#xA;          &#xA;                  pub const Iterator = struct {&#xA;        &#xA;        &#xA;          &#xA;                      it: ?*Node,&#xA;        &#xA;        &#xA;          &#xA;                      direction: IteratorDirection,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      pub fn next(self: *Iterator) ?T {&#xA;        &#xA;        &#xA;          &#xA;                          if (self.it) |cur| {&#xA;        &#xA;        &#xA;          &#xA;                              self.it = if (self.direction == .forward) cur.next else cur.prev;&#xA;        &#xA;        &#xA;          &#xA;                              return cur.item;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          return null;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn iterate(self: *Self, direction: IteratorDirection) Iterator {&#xA;        &#xA;        &#xA;          &#xA;                      return .{&#xA;        &#xA;        &#xA;          &#xA;                          .direction = direction,&#xA;        &#xA;        &#xA;          &#xA;                          .it = if (direction == .forward) self.head else self.tail,&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn popLast(self: *Self, allocator: std.mem.Allocator) ?T {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.tail) |t| {&#xA;        &#xA;        &#xA;          &#xA;                          var item = t.item;&#xA;        &#xA;        &#xA;          &#xA;                          self.remove(allocator, t);&#xA;        &#xA;        &#xA;          &#xA;                          return item;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      return null;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn popFirst(self: *Self, allocator: std.mem.Allocator) ?T {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.head) |h| {&#xA;        &#xA;        &#xA;          &#xA;                          var item = h.item;&#xA;        &#xA;        &#xA;          &#xA;                          self.remove(allocator, h);&#xA;        &#xA;        &#xA;          &#xA;                          return item;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      return null;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          DoublyLinkedList.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There isn&#x2019;t really much to discuss here, to be honest. There is a bunch of code here, but it is fairly simple. I just had to implement a few operations. The code itself is straightforward. It is a lot more interesting when we see it being used to implement the LRU:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn Lru(comptime T: type) type {&#xA;        &#xA;        &#xA;          &#xA;              return struct {&#xA;        &#xA;        &#xA;          &#xA;                  const Self = @This();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  const Item = struct { val: T, usage: usize };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  list: DoublyLinkedList(Item) = .{},&#xA;        &#xA;        &#xA;          &#xA;                  map: std.AutoHashMapUnmanaged(T, *DoublyLinkedList(Item).Node) = .{},&#xA;        &#xA;        &#xA;          &#xA;                  capacity: usize,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn init(capacity: usize) Self {&#xA;        &#xA;        &#xA;          &#xA;                      return .{ .capacity = std.math.max(capacity, 2) };&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn deinit(self: *Self, allocator: std.mem.Allocator) void {&#xA;        &#xA;        &#xA;          &#xA;                      self.list.deinit(allocator);&#xA;        &#xA;        &#xA;          &#xA;                      self.map.deinit(allocator);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn push(self: *Self, allocator: std.mem.Allocator, val: T) !?T {&#xA;        &#xA;        &#xA;          &#xA;                      if (self.map.get(val)) |existing| {&#xA;        &#xA;        &#xA;          &#xA;                          existing.item.usage &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;                          self.list.moveFirst(existing);&#xA;        &#xA;        &#xA;          &#xA;                          return null;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      var node = try self.list.prepend(allocator, .{ .val = val, .usage = 1 });&#xA;        &#xA;        &#xA;          &#xA;                      try self.map.put(allocator, val, node);&#xA;        &#xA;        &#xA;          &#xA;                      if (self.map.count() &lt;= self.capacity)&#xA;        &#xA;        &#xA;          &#xA;                          return null;&#xA;        &#xA;        &#xA;          &#xA;                          &#xA;        &#xA;        &#xA;          &#xA;                      while (self.list.tail) |last| {&#xA;        &#xA;        &#xA;          &#xA;                          if (last.item.usage &gt; 1 or last == node) { // let&#x27;s give it another try...&#xA;        &#xA;        &#xA;          &#xA;                              last.item.usage /= 2;&#xA;        &#xA;        &#xA;          &#xA;                              self.list.moveFirst(last);&#xA;        &#xA;        &#xA;          &#xA;                              continue;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          var dropped = last.item.val;&#xA;        &#xA;        &#xA;          &#xA;                          self.list.remove(allocator, last);&#xA;        &#xA;        &#xA;          &#xA;                          _ = self.map.remove(dropped);&#xA;        &#xA;        &#xA;          &#xA;                          return dropped;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      unreachable;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Lru.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The push() method is where it all happens. We have two options here:&#xA;&#xA;We have a page already inside the LRU. In that case, we increment its usage counter and move it to the front of the list.&#xA;This is a new page, so we have to add it to the LRU. If there is enough capacity, we can just add it to the front of the list and be done with it.&#xA;&#xA;However, things get interesting when we are at capacity. At that point, we actually need to select a page to evict. How can we do that? We scan the end of the list (the oldest page) and check its usage. If it has more than a single usage, we half its usage counter and move it to the front. We continue to work on the tail in this manner. In essence, high usage counter will get reset rather quickly, but this will still give us a fairly balanced approach, with more popular pages remaining in the pool for longer.&#xA;When we evict a page, we can return it back to the caller, which can then write it to the disk. Of course, you probably don&#x2019;t want to just write a single page. We need to check if we have additional pages nearby, so we can consolidate all of them at once to the disk.&#xA;I&#x2019;ll touch on that in my next post.</p>
        </article>
        <article id="article-944">
            <a href="https://ayende.com/blog/196225-C/implementing-a-file-pager-in-zig-write-durability-and-concurrency" target="_blank">
                <h2 class="title mb-6" id="article-944">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 18, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the last blog post I presented the manner in which the Pager can write data to disk. Here is a reminder:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var w = pager.acquireWriter();&#xA;        &#xA;        &#xA;          &#xA;          defer w.release();&#xA;        &#xA;        &#xA;          &#xA;          try w.write(0, buffer);&#xA;        &#xA;        &#xA;          &#xA;          try w.flushWrites();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We acquire the writer (and a lock on it), call write on the pages we want to write on (passing the buffer to write on them), and finalize the process by calling flushWrites() to actually write the data to disk. As a reminder, we assume that the caller of the Pager is responsible for coordination. While we are writing to a specific page, it is the responsibility of the caller to ensure that there are no reads to that page.&#xA;The API above is intentionally simplistic , it doesn&#x2019;t give us a lot of knobs to play with. But that is sufficient to do some fairly sophisticated things. One of the interesting observations is that we split the process of updating the data file into discrete steps. There is the part in which we are updating the in memory data, which allows other threads to immediately observe it (since they&#x2019;ll read the new details from the Pager&#x2019;s cache). Separately, there is the portion in which we write to the disk. The reason that I built the API in this manner is that it provides me with the flexibility to make decisions.&#xA;Here are some of the things that I can do with the current structure:&#xA;&#xA;I can decide not to write the data to the disk. If the amount of modified pages is small (very common if I&#x2019;m continuously modifying the same set of pages) I can skip the I/O costs entirely and do everything in memory.&#xA;Flushing the data to disk can be done in an asynchronous manner. In fact, it is already done in an asynchronous manner, but we are waiting for it to complete. That isn&#x2019;t actually required.&#xA;&#xA;The way the Pager works, we deposit the writes in the pager, and at some future point the Pager will persist them to disk. The durability aspect of a database is not reliant on the Pager, it is a property of the Write Ahead Log, usually.&#xA;If I wanted to implement a more sophisticated approach for writing to the disk, I could implement a least recently used cache for the written pages. When the number of pages in memory exceeds a certain size, we&#x2019;ll start writing the oldest to disk. That keeps the most used pages in memory and avoids needless I/O.&#xA0; At certain points, we can ask the Pager to flush everything to the disk, this gives us a checkpoint, where we can safely trim the Write Ahead Log. A good place to do that is whenever we reach the file size limit of the log and need to create a new one.&#xA;So far, by the way, you&#x2019;ll notice that I&#x2019;m not actually talking about durability, just writing to the disk. The durability aspect is coming from something we did long ago, but didn&#x2019;t really pay attention to. Let&#x2019;s look at how we are opening files, shall we:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const PagerFile = struct {&#xA;        &#xA;        &#xA;          &#xA;              chunks: *FileChunks,&#xA;        &#xA;        &#xA;          &#xA;              fd: std.os.fd_t,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn init(allocator: std.mem.Allocator, file: []const u8) !PagerFile {&#xA;        &#xA;        &#xA;          &#xA;                  var chunks = try FileChunks.init(allocator);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer chunks.deinit();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var fd = try std.os.open(&#xA;        &#xA;        &#xA;          &#xA;                      file,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.O.RDWR | std.os.O.CREAT | std.os.O.CLOEXEC | std.os.O.DIRECT | std.os.O.DSYNC,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.S.IRUSR | std.os.S.IWUSR,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return PagerFile{&#xA;        &#xA;        &#xA;          &#xA;                      .chunks = chunks,&#xA;        &#xA;        &#xA;          &#xA;                      .fd = fd,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn deinit(self: *PagerFile) void {&#xA;        &#xA;        &#xA;          &#xA;                  self.chunks.deinit();&#xA;        &#xA;        &#xA;          &#xA;                  std.os.close(self.fd);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PagerFile.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Take a look at the flags that we pass to the open() command, we are asking the OS to use direct I/O (bypassing the buffer pool, since we&#x2019;ll use our own) as well as using DSYNC write mode. The two together means that the write will skip any buffering / caching along the way and hit the disk in a durable manner. The fact that we are using async I/O means that we need to ensure that the buffers we write are not modified while we are saving them. As we currently have the API, there is a strong boundary for consistency. We acquire the writer, write whatever pages we need and flush immediately.&#xA;A more complex system would be needed to manage higher performance levels. The issue is that in order to do that, we have to give up a level of control. Instead of knowing exactly where something will happen, we can have a more sophisticated approach, but&#xA0; we&#x2019;ll need to be aware that we don&#x2019;t really know at which point the data will be persisted.&#xA;At this point, however, there is a good reason to ask, do we even need to write durably? If we are limiting the consistency of the data to specific times requested by the caller (such as when we replace the Write Ahead Log), we can just call fsync() at the appropriate times, no? That would allow us to use buffered writes from most I/O.&#xA;I don&#x2019;t think that this would be a good idea. Remember that we are using multiple files. If we&#x2019;ll use buffered I/O and fsync(), we&#x2019;ll need to issue multiple fsync() calls, which can be quite expensive. It also means higher memory usage on the system because of the file system cache, for data we determine is no longer in memory. It is simpler to use direct I/O for the whole thing, after all.&#xA;In the next post, I&#x2019;m going to show how to implement a more sophisticated write-behind algorithm and discuss some of the implications of such a design.</p>
        </article>
        <article id="article-945">
            <a href="https://ardalis.com/guard-clauses-and-exceptions-or-validation/" target="_blank">
                <h2 class="title mb-6" id="article-945">Guard Clauses and Exceptions or Validation?</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 18, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Guard Clauses provide an elegant way to ensure code inputs are valid, typically by throwing exceptions. Validation provides a solution to a&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-946">
            <a href="https://andrewlock.net/creating-a-source-generator-part-6-saving-source-generator-output-in-source-control/" target="_blank">
                <h2 class="title mb-6" id="article-946">Saving source generator output in source control</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 18, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 6</p>
        </article>
        <article id="article-947">
            <a href="https://ayende.com/blog/196193-C/implementing-a-file-pager-in-zig-writing-data" target="_blank">
                <h2 class="title mb-6" id="article-947">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 17, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">At long last, we are now at the point where we can write data back to the disk.&#xA0; Before we can do that, however, we need to figure out what sort of writes we want to allow. The idea that I have in mind for the Pager is to follow the same path as Voron does. In other words, for writes, we can make the following assumptions:&#xA;&#xA;There is only a single thread doing writes to the pager.&#xA;There are no readers for the writes until the write is completed.&#xA;There is a distinction between writing the data to the pager and writing the data to the disk.&#xA;&#xA;Let&#x2019;s break those assumptions apart and see what they bring to the table. The fact that we can assume only a single writer thread at any given point is pretty important. It means that the level of complexity that we have to face is greatly reduced. In the same sense, the fact that we don&#x2019;t need to deal with concurrent readers or any consistency boundary for the data while it is being written will greatly simplify things for us. Finally, we make a distinction between writing to the pager and writing to the disk. Writing to the disk is _slow_, so we want to avoid doing that at any critical areas and push that to the background.&#xA;Finally, there is another aspect to consider. Internally, the Pager works with 2MB chunks, but to the outside world, it is using 8KB pages. When we write, we always write at the 8KB pages, not chunks. How would that work for the Pager?&#xA;The Pager itself is concurrent, but we only allow a single writer at a time, we can achieve this by centralizing all the write activities in the Writer struct, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // inside Pager&#x27;s struct...&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn acquireWriter(self: *Pager) *Writer {&#xA;        &#xA;        &#xA;          &#xA;              self.writer.lock.lock();&#xA;        &#xA;        &#xA;          &#xA;              return &amp;self.writer;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub const Writer = struct {&#xA;        &#xA;        &#xA;          &#xA;                  writeResults: std.ArrayListUnmanaged(anyerror),&#xA;        &#xA;        &#xA;          &#xA;                  writtenPages: std.AutoArrayHashMapUnmanaged(u64, u32),&#xA;        &#xA;        &#xA;          &#xA;                  loadedChunksForWrites: ChunksSet,&#xA;        &#xA;        &#xA;          &#xA;                  writeFlushCompleted: std.atomic.Atomic(u32),&#xA;        &#xA;        &#xA;          &#xA;                  lock: std.Thread.Mutex,&#xA;        &#xA;        &#xA;          &#xA;                  parent: *Pager,&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;                  pub fn release(self: *Writer) void {&#xA;        &#xA;        &#xA;          &#xA;                      self.lock.unlock();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Writer.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For now, I&#x2019;m going to ignore the fields in the Writer struct, we&#x2019;ll touch on them in detail later. In order to use the writer, you need to acquire it, write as many pages as you need, then release it. Here is a usage example:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var w = pager.acquireWriter();&#xA;        &#xA;        &#xA;          &#xA;          defer w.release();&#xA;        &#xA;        &#xA;          &#xA;          try w.write(0, buffer);&#xA;        &#xA;        &#xA;          &#xA;          try w.flushWrites();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The basic idea is fairly simple. With the writer, we operate at the page boundary to write as many pages as we need, once we are done, the call to flushWrites() persists the data to disk and then we can release the writer. Let&#x2019;s dig a bit deeper and see how that works, shall we?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn write(self: *Writer, page: u64, buffer: []align(mem.page_size) u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              std.debug.assert(buffer.len % FileChunks.PageSize == 0);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var count = @intCast(u32, buffer.len / FileChunks.PageSize);&#xA;        &#xA;        &#xA;          &#xA;              var dst = try self.parent.getPage(&amp;self.loadedChunksForWrites, page, count, .{ .forWrites = true });&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, dst, buffer);&#xA;        &#xA;        &#xA;          &#xA;              try self.writtenPages.put(self.parent.allocator, page, count);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          write.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The write() call is about as basic as you can get. We use the getPage()&#xA0;function to get the right page, memcpy the data and that is about it, right? There are only two other things here that are important:&#xA;&#xA;We record which chunk (the 2MB chunk of memory, out of which we carve the 8KB pages) at the writer&#x2019;s level, is using the loadedChunksForWrites value.&#xA;We remember which pages we wrote to using the writtenPages hash table.&#xA;&#xA;This is intentionally bare bones, because that is actually sufficient for our needs. The&#xA0; fact that we remember which chunks we loaded (and keep a reference to them) will prevent us from reclaiming them, so even though we just wrote to memory, another thread can get the data and start using it without waiting for the disk. Of course, we still need to hit the disk eventually, that is what flushWrites() is about.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn flushWrites(self: *Writer) !void {&#xA;        &#xA;        &#xA;          &#xA;              var count = self.writtenPages.count();&#xA;        &#xA;        &#xA;          &#xA;              if (count == 0)&#xA;        &#xA;        &#xA;          &#xA;                  return;&#xA;        &#xA;        &#xA;          &#xA;              var tmp = try self.parent.allocator.alloc(u64, count);&#xA;        &#xA;        &#xA;          &#xA;              defer self.parent.allocator.free(tmp);&#xA;        &#xA;        &#xA;          &#xA;              for (self.writtenPages.keys()) |i, p| {&#xA;        &#xA;        &#xA;          &#xA;                  tmp[i] = p;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              try self.writeResults.ensureTotalCapacity(self.parent.allocator, count);&#xA;        &#xA;        &#xA;          &#xA;              std.sort.sort(u64, tmp, {}, comptime std.sort.asc(u64));&#xA;        &#xA;        &#xA;          &#xA;              var page = tmp[0];&#xA;        &#xA;        &#xA;          &#xA;              var fileIdx = page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              var len = self.writtenPages.get(page) orelse unreachable;&#xA;        &#xA;        &#xA;          &#xA;              var index: usize = 1;&#xA;        &#xA;        &#xA;          &#xA;              while (index &lt; tmp.len) : (index &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  if (page &#x2B; len == tmp[index] and fileIdx == (tmp[index] / FileChunks.PagesInFile)) {&#xA;        &#xA;        &#xA;          &#xA;                      // consecutive and in same file, just increase...&#xA;        &#xA;        &#xA;          &#xA;                      len &#x2B;= self.writtenPages.get(page) orelse unreachable;&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  try self.writePageToDisk(page, len);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // last one...&#xA;        &#xA;        &#xA;          &#xA;              try self.writePageToDisk(page, len);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.waitForAllDiskWritesToComplete();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          flushWrites.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is a lot that is going on here, let&#x2019;s break it up. We start by allocating a temporary array and copying the keys from the writtenPages hash table to it. We then sort the array. This is done so we&#x2019;ll be able to process the writes in a sequential manner, which is likely to be faster, even with async I/O. We then scan the list of pages in order, trying to merge writes together. The idea is to issue the minimum number of write calls. Finally, we&#x2019;ll wait for all the writes to complete. Okay, maybe it isn&#x2019;t that complex.&#xA0; There is a bunch of code here, but it is mostly straightforward. Note that we also prepare the writeResults list to accept the results of the write to the disk.&#xA;As for writing to the disk, this is done using the PagerRing we previously looked at:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn writePageToDisk(self: *Writer, page: u64, count: u32) !void {&#xA;        &#xA;        &#xA;          &#xA;              var fileIdx = page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              var file = self.parent.files[fileIdx] orelse return error.FileIsNotLoaded;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var pageBuffer = try self.parent.getPage(&amp;self.loadedChunksForWrites, page, count, .{});&#xA;        &#xA;        &#xA;          &#xA;              _ = self.writeFlushCompleted.fetchAdd(1, .Release);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.parent.ring.submit(.{&#xA;        &#xA;        &#xA;          &#xA;                  .tag = .Write,&#xA;        &#xA;        &#xA;          &#xA;                  .fd = file.fd,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = pageBuffer,&#xA;        &#xA;        &#xA;          &#xA;                  .offset = page % FileChunks.PagesInFile,&#xA;        &#xA;        &#xA;          &#xA;                  .context = @ptrToInt(self),&#xA;        &#xA;        &#xA;          &#xA;                  .callback = completeFlush,&#xA;        &#xA;        &#xA;          &#xA;              });&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn completeFlush(work: *PagerRing.Work) void {&#xA;        &#xA;        &#xA;          &#xA;              var self = @intToPtr(*Pager.Writer, work.context);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (work.result.err) |err| {&#xA;        &#xA;        &#xA;          &#xA;                  // need to report the error before releasing waiters&#xA;        &#xA;        &#xA;          &#xA;                  self.writeResults.appendAssumeCapacity(err);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (self.writeFlushCompleted.fetchSub(1, .Release) == 1) {&#xA;        &#xA;        &#xA;          &#xA;                  std.Thread.Futex.wake(&amp;self.writeFlushCompleted, std.math.maxInt(u32));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          writePageToDisk.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;To write a buffer to the disk, we simply get the buffer from the Pager (reusing all the work we did in getPage()), increment the number of outstanding writes and then submit the work for the ring for processing. We setup the completeFlush as the callback function on completion. The PagerRing will call us when it is done writing to the disk. If there is an error, we&#x2019;ll record it and reduce the number of outstanding writes. If there are no more outstanding writes, we&#x2019;ll wake any waiters. That part is handled in the waitForAllDiskWritesToComplete().&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn waitForAllDiskWritesToComplete(self: *Writer) !void {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var cur = self.writeFlushCompleted.load(.Acquire);&#xA;        &#xA;        &#xA;          &#xA;                  if (cur == 0) // no outstanding writes...&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;                  try std.Thread.Futex.wait(&amp;self.writeFlushCompleted, cur, null);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.writtenPages.shrinkRetainingCapacity(0);&#xA;        &#xA;        &#xA;          &#xA;              var it = self.loadedChunksForWrites.keyIterator();&#xA;        &#xA;        &#xA;          &#xA;              while (it.next()) |chunk| {&#xA;        &#xA;        &#xA;          &#xA;                  try self.parent.releaseChunk(chunk.*);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.loadedChunksForWrites.clearRetainingCapacity();&#xA;        &#xA;        &#xA;          &#xA;              defer self.writeResults.clearRetainingCapacity();&#xA;        &#xA;        &#xA;          &#xA;              if (self.writeResults.items.len != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return self.writeResults.items[0];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          waitForAllDiskWritesToComplete.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We start by waiting for the outstanding writes to complete, waiting if needed. Then we can reset the state of the Writer. We start by resetting the written pages and then iterate over all the loaded chunks and release them. After the call, the Pager may decide to remove them from memory. This is fine, since they were already written to disk.&#xA;Except&#x2026; if there was an error. You might have noticed that we are gathering the errors on each individual write operation we send, but we are actually only looking at the first one. For that matter, we clear the state of the Writer regardless if there were errors or not.&#xA;In general, an I/O error from the disk is not something that is recoverable. What you can do at this stage is to raise the error higher and run whatever recovery you have on startup.&#xA;In the next post, I&#x2019;m going to be talking about durability and the overall expected performance of the system under this sort of model.</p>
        </article>
        <article id="article-948">
            <a href="https://ardalis.com/why-use-datetimeoffset/" target="_blank">
                <h2 class="title mb-6" id="article-948">Why Use DateTimeOffset</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 17, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Raise your hand if you&#x27;ve stored entity values in a database as DateTime. Ok, everybody has their hand up. You can put your hand down - you&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-949">
            <a href="https://www.meziantou.net/deleting-github-actions-artifacts-using-the-github-rest-api.htm" target="_blank">
                <h2 class="title mb-6" id="article-949">Deleting GitHub Actions artifacts using the GitHub REST API</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 17, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">GitHub Actions supports sharing data between jobs in any workflow as artifacts. This is very convenient but the storage is limited (or you have to pay for it). If you use too much storage, you may get one of those notifications:You&#x27;ve used 75% of included services for GitHub Storage (GitHub Actions</p>
        </article>
        <article id="article-950">
            <a href="https://ayende.com/blog/196161-C/re-are-you-sure-you-want-to-use-mmap-in-your-database-management-system" target="_blank">
                <h2 class="title mb-6" id="article-950">re</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 14, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I was pointed to this paper on twitter: Are You Sure You Want to Use MMAP in Your Database Management System?&#xA;As you can imagine, this is a topic near and dear to my heart. This is especially the case since I am currently writing the Implementing a file pager in Zig posts series. I implemented the same low level mechanics using mmap, using mmap, I have &lt; 100 lines of code and can start building higher level concepts almost immediately. Writing my own pager is currently a 10 posts series and the end doesn&#x2019;t seem to be in sight.&#xA;I&#x2019;m going to use this post to respond to the article. As a reminder, I&#x2019;m the founder of RavenDB and I wrote Voron, a mmap based storage engine, and has been running that across hundreds of clients and literally tens of millions of instances in production. I am also writing a book about building a storage engine that uses mmap internally.&#xA;The paper itself does a great job of outlining the issue of using mmap as the buffer pool in DBMS. What it doesn&#x2019;t cover, however, is the alternative. I will touch on specific points from the paper shortly, but I want to point out that the article compares apples to camels in the benchmarks and conclusions. Note that I don&#x2019;t necessarily disagree with some of the statements, mmap certainly has challenges that you need to deal with, but if you avoid that, you can&#x2019;t have wave everything that it brings to the table.&#xA;When building a database, using mmap has the following advantages, the OS will take care of:&#xA;&#xA;Reading the data from disk&#xA;Concurrency between different threads reading the same data&#xA;Caching and buffer management&#xA;Eviction of pages from memory&#xA;Playing nice with other processes in the machine&#xA;Tracking dirty pages and writing to disk*&#xA;&#xA;I put an asterisk on the last one because it probably requires your attention as well.&#xA;If you aren&#x2019;t using mmap, on the other hand, you still need to handle all those issues. That is a key point that I believe isn&#x2019;t addressed in the paper. Solving those issues properly (and efficiently) is a seriously challenging task. Given that you are building a specialized solution, you can probably do better than the generic mmap, but it will absolutely have a cost. That cost is both in terms of runtime overhead as well as increased development time.&#xA;The comparison that was made by the paper was done using fio benchmark tool, which is great if you want to test your storage system, but is pretty much irrelevant if you are trying to benchmark a buffer pool. Consider the following:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // pool.h&#xA;        &#xA;        &#xA;          &#xA;          void* getPage(pool* p, long id);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // mmap_pool.c&#xA;        &#xA;        &#xA;          &#xA;          void* getPage(pool* p, long id){&#xA;        &#xA;        &#xA;          &#xA;             return p-&gt;base_ptr &#x2B; (id * PAGE_SIZE); &#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // fio_pool.c&#xA;        &#xA;        &#xA;          &#xA;          void* getPage(pool* p, long id) {&#xA;        &#xA;        &#xA;          &#xA;            // * lookup if the page is in memory&#xA;        &#xA;        &#xA;          &#xA;            // * if not, schedule its load&#xA;        &#xA;        &#xA;          &#xA;            // *** block the current thread? return an error and have it try later?&#xA;        &#xA;        &#xA;          &#xA;            // *** other threads that need this page should not initiate another load&#xA;        &#xA;        &#xA;          &#xA;            // * record that the page is used (to handle evictions later)&#xA;        &#xA;        &#xA;          &#xA;            // * record that this page is in use (to avoid evicting a page while it is in use)&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          buffer_pool.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For the mmap version, we need to compute the address of the page and that is pretty much it. For the manual buffer pool, the list of tasks that we need to handle is long. And some of them require us to be thread safe. For example, if we handed a page to a transaction, we need to keep track of that page status as being in use. We cannot evict this page until the transaction is done with it. That means that we probably need to do atomic reference counting, which can have very high costs. There are other alternatives, of course, but they all have even higher degrees of complexity.&#xA;In practice, data access within a database isn&#x2019;t actually random, even if you are doing random reads. There are pages that are going to almost always be referenced. The root page in the B&#x2B;Tree is a good example. It is always going to be used. Under atomic reference counting, that page is going to be a bottleneck.&#xA;Ignoring such overhead of the buffer pool management means that you aren&#x2019;t actually comparing equivalent structures. I should also point out that I&#x2019;m probably forgetting a few other tasks that the buffer pool needs to manage as well, which complicate its life significantly. Here is an example of such a buffer pool implementation from what is effectively a random GitHub repository. You can see what the code is trying to do here. The reason I point to this is that there is a mutex there (and I/O under the lock), which is fairly typical for many buffer pools. And not accounting for the overhead of buffer pool management is seriously skewing the results of the paper.&#xA;All of this said, I absolutely agree that mmap can be challenging. The paper outlines 4 different problems, which I want to address.&#xA;Problem #1 &#x2013; Transactional safety&#xA;A database needs to know when the data is persisted to disk. When using mmap, we explicitly give up that knowledge. That can be a challenge, but I don&#x2019;t see that as a seriously different one from not using mmap. Let&#x2019;s consider the manner in which Postgres is working. It has its own buffer pool, and may modify the pages as a result of a write. Postgres may need to evict modified pages to disk before the transaction that modified them is committed. The overhead of managing that is just&#x2026; part of the challenge that we need to deal with.&#xA;For RavenDB, as the paper points out, we modify the pages outside of the mmap memory. This is actually not done for the reason the paper describes. I don&#x2019;t actually care if the data is written to memory behind my back. What I care about is MVCC (a totally separate concern than buffer management). The fact that I&#x2019;m copying the modified data to the side means that I Can support concurrent transactions with far greater ease. In a similar fashion, Postgres handles MVCC using multiple entries for the same row in the same page.&#xA;When the transaction commits and older transactions no longer need the old version of the data, I can push the data from the modified buffers to the mmap region. That tends to be fairly fast (given that I&#x2019;m basically doing memcpy(), which runs at memory speed) unless I have to page data in, more on that later.&#xA;The paper mentions the issue of single writer in LMDB, and I wanted to point out that a single writer model is actually far more common (and again, not really related to the buffer pool issue). Off the top of my head, most embedded databases implement a single writer model.&#xA;&#xA;LMDB&#xA;Voron (RavenDB&#x2019;s storage engine)&#xA;LevelDB&#xA;Lucene&#xA;&#xA;The one that I can think that doesn&#x2019;t have a single writer is RocksDB(where allow_concurrent_memtable_write is for writes to the memtable, not related to file I/O).&#xA;The reason this matters is that embedded systems can typically assume that all operations in a transaction will complete as a unit. Compare to Postgres, where we may have a transaction spanning multiple network calls, interleaving writes is a must. If we could avoid such concurrency, that would be far preferable. You can get additional concurrency by having sharding writes, but that is usually not needed.&#xA;Problem #2 &#x2013; I/O Stalls&#xA;The paper points out, quite correctly, that not having control over the I/O means that you may incur a page fault at any time. In particular, you may end up blocked on I/O without really noticing. This can be a killer especially if you are currently holding a lock and blocked on page fault. Indeed, I consider this to be the most serious issue that you have to deal with mmap based systems.&#xA;In practice, however, the situation isn&#x2019;t so clear cut. Until quite recently, the state of asynchronous I/O on Linux was quite iffy. Until the arrival of io_uring, certain operations that you expected to be async would block occasionally, ruining your day. The paper mentions that you can use async I/O to issue I/O requests to load the next pages (non sequentially) from the disk when you are performing certain operations. You can do the same with mmap as well, and RavenDB does just that. When you start a scan on a B&#x2B;Tree, RavenDB will ask the OS to ensure that the memory we are interested in is in memory before we actually get to it. On Linux, this is done with madvise(WILL_NEED) call. That call may be blocking, so we actually have a dedicated thread that is meant to handle such a scenario.&#xA0; In practice, this isn&#x2019;t really that different from how you&#x2019;ll handle it with async I/O.&#xA;Another consideration to deal with is the cost of mapping at the kernel level. I&#x2019;m not talking about the I/O cost, but if you have many threads that are faulting pages, you&#x2019;ll run into problems with the page table lock. We have run into that before, this is considered an OS level bug, but it obviously has an impact on the database. In practice, however, the overhead of memory management is the same in most cases. If you are reading via mmap or allocating directly, you&#x2019;ll need to orchestrate things. Note that the same page table lock is also in effect if you are heavily allocating / freeing, since you&#x2019;re also modifying the process page table.&#xA;Problem #3 &#x2013; Error Handling&#xA;Error handling is a serious concern for a database. The paper points out that databases such as SQL Server may run a checksum when reading data from disk. When you use a buffer pool, the boundary of reading from the disk is obvious and you can easily validate the read from the disk. Voron is using mmap exclusively, and we do have checksums. We validate the page from the disk the first time that we access it (there is an internal bitmap that is used for that).&#xA0; There isn&#x2019;t a big difference between the two anyway. We only check a given page once per run, because to do otherwise is meaningless. When you use read() to get data from the disk, you have no guarantees that the data wasn&#x2019;t fetched from a cache along the way. So you may validate the data you read is &#x201C;correct&#x201D;, while the on disk representation is broken. For that reason, we only do the check once, instead of each time.&#xA;A far greater issue to deal with is I/O errors. What do you do when a read or a write fails? If you are using system calls to manage that, you get a return code and can react accordingly. If you are using mmap, the system will generate a SIGBUS that you&#x2019;ll have to (somehow) handle.&#xA;For a database, dealing with I/O errors has a single correct answer. Crash and then run recovery from scratch. If the I/O system has returned an error, there is no longer any way to know what the state of that is. See: fsync-gate. The only way to recover is to stop, reload everything (apply the WAL, run recovery, etc) and get back into a stable state. SIGBUS isn&#x2019;t my cup of tea with regards to handling this, but error handling for I/O error isn&#x2019;t actually something that you do, so just restarting the process ends up more acceptable than you might initially think.&#xA;Problem #4 &#x2013; Performance issues&#xA;The paper points out three common reasons for performance issues with mmap usage:&#xA;&#xA;page table contention&#xA;single threaded page eviction&#xA;TLB shootdowns&#xA;&#xA;The first issue is something that I have run into in the past. It was a bug in the operating system which was fixed. There is no longer a single page table in both Windows and Linux.&#xA;The single threaded eviction, on the other hand, is something that we never run into. When using Voron, we map the memory using MAP_SHARED, and most of the time, the memory isn&#x2019;t dirty. If the system needs memory, it can do that when it assigns a page by just discarding the memory of an unmodified shared page. In this model, we typically see most of the memory as shared, clean. So there isn&#x2019;t a lot of pressure to evict things, and it can be done on as needed basis.&#xA;The TLB shootdown issue is not something that we ever run into as a problem. We have run TB range databases on Raspberry PI with 4GB of RAM and hammered that in benchmarks (far exceeding the memory capacity). The interesting thing here is that the B&#x2B;Tree nature means that the upper tiers of the tree were already in memory, so we mostly ended up with a single page fault per request. In order to actually observe the cost of TLS Shootdown in a significant manner, you need to have:&#xA;&#xA;really fast I/O&#xA;working set that significantly exceeds memory&#xA;no other work that needs to be done for processing a request&#xA;&#xA;In practice, if you have really fast I/O, you spent money on that, you&#x2019;ll more likely get more RAM as well. And you typically need to do something with the data you read, which means that you won&#x2019;t notice the TLB shootdown as much.&#xA;Finally, going back to how I started this post. This assumes that there are no other costs of not using mmap and using direct IO. The benchmark doesn&#x2019;t account for those extra costs. For example, without mmap, who is doing evictions? In practice, that will lead to the same sort of considerations that you&#x2019;ll have when dealing with mmap. This is especially the case with TLS shootdown when we start talking about high memory traffic (which likely modifies page allocations for the process, leading to the same scenario).&#xA;The paper has been quite interesting to read and it has presented a number of real problems that occur with mmap based systems, but I&#x2019;m afraid that it doesn&#x2019;t present the alternatives properly and vastly underestimates both costs and complexity of not using mmap and writing your own buffer pool.</p>
        </article>
        <div class="button flex justify-between">
            <a href="94.html"><span class="back arrow"></span></a>

            <a href="96.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>