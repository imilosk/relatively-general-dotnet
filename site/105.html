
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 105 &#x2022; Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="/pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">
<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline underline"
               href="index.html"> Home </a><a
                aria-current="" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline " href="about.html">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>


<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-1041">
            <a href="https://ardalis.com/what-are-abstractions-in-software-development/" target="_blank">
                <h2 class="title mb-6" id="article-1041">What are Abstractions in Software Development</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 05, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Software developers deal with abstractions every day. But just what is an abstraction? There are differing definitions that can sometimes&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-1042">
            <a href="https://ayende.com/blog/195969-A/implementing-a-file-pager-in-zig-rethinking-my-approach" target="_blank">
                <h2 class="title mb-6" id="article-1042">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 04, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After writing the post about handling chunk metadata, I started thinking about the overall approach. Both the method using compressed pointers and the baseline computation felt&#x2026; off to me. They were certainly workable, but it was too complex and felt fragile.&#xA;I don&#x2019;t like dealing with a high level of complexity, I would rather put a lot of effort into simplifying the solution. The overall approach may be complex, but the system should be nice to work with. Usually, we can get away with a great deal of simplification if we accept some constraints on what we want to do with the system. For now, I&#x2019;m going to assume the following constraints:&#xA;&#xA;We are using 64 bits OS (and can assume effectively unlimited address space).&#xA;We want to go with a file pager (instead of the memory mapped one) because I want to be able to control the I/O behavior better.&#xA;The files we use are limited to 8 GB in size (can use more than a single file, of course).&#xA;&#xA;The last one deserves some additional words. When thinking about a storage solution, accepting a maximum size is generally a bad idea (640KB, anyone?). However, if we decide that our storage solution is going to be composed of files of specific size, we can combine them to reach any size needed.&#xA;But why accept this limitation? Why say that a single file will not exceed 8 GB? It turns out that this has several advantages.&#xA;Let&#x2019;s assume that we have a dataset that is 100GB in size, using 8 GB files, that would be 13 files to a total of 104 GB of used disk space. Now we want to delete some of that data. What do we do with the actual used disk space? It is actually quite hard to release disk space back to the operating system if you have a single file. You might need to run compaction of the data, or use advanced API such as hole punching (see FALLOC_FL_PUNCH_HOLE). Advanced API is something that I would like to avoid, too easy to fall into some pitfall that no one else has run into. Working with sparse files (with holes in them) also typically requires you to utilize dedicated tools and can be awkward.&#xA0; If we split the data into separate files, we can retain most of the same benefits, and give ourselves a simpler environment for the user to work with.&#xA;With the 8GB limitation in place, I can choose to manage the paging using the following manner:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const FileChunks = struct {&#xA;        &#xA;        &#xA;          &#xA;              pub const MaxFileSize = 8 * 1024 * 1024 * 1024; // 8 GB&#xA;        &#xA;        &#xA;          &#xA;              pub const ChunkSize = 2 * 1024 * 1024; // 2 MB&#xA;        &#xA;        &#xA;          &#xA;              pub const MaxChunksInFile = MaxFileSize / ChunkSize; // 4096&#xA;        &#xA;        &#xA;          &#xA;              pub const PageSize = 8 * 1024; // 8 KB&#xA;        &#xA;        &#xA;          &#xA;              pub const PagesInChunk = ChunkSize / PageSize; // 256&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub const ChunkMetadata = packed union {&#xA;        &#xA;        &#xA;          &#xA;                  pub const Tag = enum(u2) {&#xA;        &#xA;        &#xA;          &#xA;                      Empty = 0b00,&#xA;        &#xA;        &#xA;          &#xA;                      Error = 0b01,&#xA;        &#xA;        &#xA;          &#xA;                      Loading = 0b10,&#xA;        &#xA;        &#xA;          &#xA;                      Value = 0b11,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  raw: u64,&#xA;        &#xA;        &#xA;          &#xA;                  futex: packed struct {&#xA;        &#xA;        &#xA;          &#xA;                      value: u32, // tag &amp; version&#xA;        &#xA;        &#xA;          &#xA;                      references: u32, // ignored&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;                  v: packed struct {&#xA;        &#xA;        &#xA;          &#xA;                      version: u30,&#xA;        &#xA;        &#xA;          &#xA;                      tag: Tag,&#xA;        &#xA;        &#xA;          &#xA;                      // references == 0 - this is unused&#xA;        &#xA;        &#xA;          &#xA;                      // references == 1 - just the pager is holding this&#xA;        &#xA;        &#xA;          &#xA;                      // refereces  &gt;= 2 - external entity is holding this&#xA;        &#xA;        &#xA;          &#xA;                      references: u32,&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              comptime {&#xA;        &#xA;        &#xA;          &#xA;                  if (@sizeOf(ChunkMetadata) != @sizeOf(u64)) {&#xA;        &#xA;        &#xA;          &#xA;                      @compileError(&quot;ChunkMetadata should be exactly 64 bits in length&quot;);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              chunks: [MaxChunksInFile]ChunkMetadata,&#xA;        &#xA;        &#xA;          &#xA;              ptr: []align(mem.page_size) u8,&#xA;        &#xA;        &#xA;          &#xA;              allocator: mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FileChunks.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is pretty simple. Instead of trying to stitch together the memory for the file, we are going to just allocate a single 8GB range of virtual memory. This can be done using the following command:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var ptr = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;              null,&#xA;        &#xA;        &#xA;          &#xA;              MaxFileSize,&#xA;        &#xA;        &#xA;          &#xA;              os.PROT.NONE,&#xA;        &#xA;        &#xA;          &#xA;              os.MAP.ANONYMOUS | os.MAP.PRIVATE,&#xA;        &#xA;        &#xA;          &#xA;              -1,&#xA;        &#xA;        &#xA;          &#xA;              0,&#xA;        &#xA;        &#xA;          &#xA;          );&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          mmap.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This reserves (but does not use) 8GB of address space. We can now allocate ranges from that safely. This is important because if we have a request to two sequential chunks, they will reside in memory right next to one another. Note that we also don&#x2019;t need to handle any pointers, since we can rely on a stable base address for the whole file. The nice thing about this is that we aren&#x2019;t actually allocating memory, just reserving it.&#xA;Let&#x2019;s see how that will work? The chunks array is used to control references to the chunks in the file. The chunk metadata is a 64 bits value that has several responsibilities at the same time. It stores the tag of a chunk, which indicate its status (loaded, error, empty, etc) and the number of outstanding references to the chunk. That uses up 34 bits in the value, the rest of the bits are used as a version field, which is incremented on each change. That allows us to avoid the ABA problem. The actual data, of course, is managed using the ptr value.&#xA;Here is how we can get a chunk from this struct:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn tryGet(self: *FileChunks, chunk: u64) !?[]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.getTag()) {&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; return null,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return @intToError(@intCast(u16, copy.v.references)),&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; return error.ValueIsLoading,&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef();&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      var offset = chunk * ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                      return self.ptr[offset..(offset &#x2B; ChunkSize)];&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          tryGet.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What we are doing here is checking that the value is loaded to memory, and if it is, we increment the reference and then return it. This code runs in a loop, because we assume that multiple threads may run it in the same time. This handles just getting data that is already loaded. If the data isn&#x2019;t loaded, what will happen? We&#x2019;ll get a null back. Here is the blocking version of this method:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn getBlocking(self: *FileChunks, chunk: u64, timeout: ?u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var maybechunk = self.tryGet(chunk) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;                      if (e == error.ValueIsLoading) {&#xA;        &#xA;        &#xA;          &#xA;                          var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                          if (copy.getTag() == .Empty) {&#xA;        &#xA;        &#xA;          &#xA;                              try self.chunks[chunk].wait(copy, timeout);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      return e;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  if (maybechunk) |c| {&#xA;        &#xA;        &#xA;          &#xA;                      return c;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  return error.ValueIsNotLoading;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getBlocking.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Just based on those two methods, you should be able to draw some conclusions. If the value isn&#x2019;t loaded, we&#x2019;ll always return null, but there is this Loading stage as well, in that case, we may want to wait for it. How is that going to work?&#xA;This works using two important functions: markLoading() and markLoaded(), the idea is that we&#x2019;ll first try to call tryGet() to load a chunk, if there is no value, we need to load it from disk. At that point, remember, there may be multiple threads accessing the relevant chunk. So all of them would be competing on the markLoading function, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn markLoading(self: *FileChunks, chunk: u64) !?[]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; return error.ValueAlreadyExists,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return error.ValueInErrorState,&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; return null, // already marked..&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  copy.setTag(.Loading);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      var offset = chunk * ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                      const c = self.ptr[offset..(offset &#x2B; ChunkSize)];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      _ = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;                          c.ptr,&#xA;        &#xA;        &#xA;          &#xA;                          ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                          os.PROT.READ | os.PROT.WRITE,&#xA;        &#xA;        &#xA;          &#xA;                          os.MAP.ANONYMOUS | os.MAP.PRIVATE | os.MAP.FIXED,&#xA;        &#xA;        &#xA;          &#xA;                          -1,&#xA;        &#xA;        &#xA;          &#xA;                          0,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      return c;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          markLoading.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The code itself is pretty simple, we are updating the tag of the chunk and try to update it optimistically. We are moving the state of the chunk from Empty to Loading in a thread safe manner. If we are successful in doing so, we know that we are the only thread that owns the loading portion of the chunk. Note that part of the markLoading process is to ask the OS to give us the memory for the chunk (in the range that we previously allocated).&#xA;At this point, we can load the data from disk somehow and then we&#x2019;ll call the markLoaded function, which completes the process:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn markLoaded(self: *FileChunks, chunk: u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; return error.ValueAlreadyExists,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return error.ValueInErrorState,&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; return error.ValueIsNotLoading,&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  copy.setTag(.Value);&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef(); // ownership by the pager&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef(); // ownership by the caller&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      return self.getLoadedChunk(chunk);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          markLoaded.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is that we are splitting the responsibility for managing the chunks references from how we load the data to memory.&#xA;In other words, the expected usage of this struct is something like this:&#xA;&#xA;Call tryGet() a page in a given chunk.&#xA;If successful, do the work you wanted to do.&#xA;If not successful, compete to be the loader for this data by calling markLoading().&#xA;If you lost, call getBlocking() to wait for the winner to get the data.&#xA;Somehow, load the data from the disk and call markLoaded().&#xA;Proceed to make use of the data.&#xA;&#xA;Another important aspect that we have to deal with is when we want to discard the data. Basically, if we filled our memory budget and we need to load a value from the disk, what can we do then? The answer is that we need to evict the data somehow, before we can do that, we need to know what data is currently in use. That is why we have the calls to addRef() and release(). We use those (using atomic operations) to track the usage of the various chunks. When we need to evict data from memory, we&#x2019;ll need to have some sort of a policy to do so. I&#x2019;m deferring the actual policy to a later point in time, right now I want to discuss how do we know what we can evict and how that is going to work.&#xA;Here is the code to handle eviction, currently implementing a policy of simple scanning (not ideal by a long shot):&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn tryClaimOwnership(self: *FileChunks, index: u64) ?ChunkMetadata {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[index];&#xA;        &#xA;        &#xA;          &#xA;                  if (copy.mayReclaim() == false)&#xA;        &#xA;        &#xA;          &#xA;                      return null;&#xA;        &#xA;        &#xA;          &#xA;                  var modified = copy.reset(.Loading); // means that we own it for the duration...&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[index].tryUpdate(copy, modified))&#xA;        &#xA;        &#xA;          &#xA;                      return modified;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn trySetToEmpty(self: *FileChunks, index: u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var modified = self.chunks[index];&#xA;        &#xA;        &#xA;          &#xA;                  if (modified.getTag() != .Loading) {&#xA;        &#xA;        &#xA;          &#xA;                      // someone else modified it while we where releasing the memory&#xA;        &#xA;        &#xA;          &#xA;                      return error.ValueIsNotLoading;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var released = modified.reset(.Empty);&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[index].tryUpdate(modified, released))&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn reclaim(self: *FileChunks) !u64 {&#xA;        &#xA;        &#xA;          &#xA;              var reclaimed: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              var index: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (index &lt; self.chunks.len) : (index &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  var modified: ChunkMetadata = undefined;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.tryClaimOwnership(index)) |m| {&#xA;        &#xA;        &#xA;          &#xA;                      // at this point, m is owned by us, and no one else can use it...&#xA;        &#xA;        &#xA;          &#xA;                      modified = m;&#xA;        &#xA;        &#xA;          &#xA;                  } else {&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  reclaimed &#x2B;= ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                  _ = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;                      self.getLoadedChunk(index).ptr,&#xA;        &#xA;        &#xA;          &#xA;                      ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                      os.PROT.NONE,&#xA;        &#xA;        &#xA;          &#xA;                      os.MAP.ANONYMOUS | os.MAP.PRIVATE | os.MAP.FIXED,&#xA;        &#xA;        &#xA;          &#xA;                      -1,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.trySetToEmpty(index);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return reclaimed;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          eviction.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In the reclaim method, we are scanning through the chunks. To be able to reclaim a chunk, the following conditions need to hold:&#xA;&#xA;The chunk holds a value.&#xA;There are no outstanding references to the chunk, only the pager is holding a reference to the chunk.&#xA;&#xA;Note that in order to do this safely, we have to assume that while we are trying to reclaim a chunk, another thread is trying to use it. This behavior complicates our lives a bit. We handle that by doing&#xA0; a racy update of the chunk, trying to move it to a loading state. The idea is that the Loading state is meant to be used as a busy signal. While the chunk is in Loading state, the rest of the system knows that it cannot use this and needs to wait. Note that this means that we have the following transitions:&#xA;&#xA;Most of the code that we have in the struct is there to handle concurrency from multiple threads dealing with the system at once, note. The actual behavior is fairly simple. We check if we can reclaim the chunk (no one is looking), we take a lock on by trying to move its state to Loading. Then we can discard the memory by calling mmap on the chunk&#x2019;s memory with PROT_NONE.&#xA;For fun, we are using 2MB chunks because that fits well into huge pages. On a properly setup system, we can significantly reduce the paging metadata overhead inside the kernel by allocating a single 2MB page for each chunk.&#xA;You can see the entire implementation here. In the next post, I want to look into handling the I/O portion of reading the data from the disk. After that we&#x2019;ll talk about how we can implement a proper eviction policy.</p>
        </article>
        <article id="article-1043">
            <a href="https://andrewlock.net/creating-a-source-generator-part-4-customising-generated-code-with-marker-attributes/" target="_blank">
                <h2 class="title mb-6" id="article-1043">Customising generated code with marker attributes</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 04, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 4</p>
        </article>
        <article id="article-1044">
            <a href="https://ayende.com/blog/195937-A/production-postmortem-an-error-on-the-first-act-will-lead-to-data-corruption-on-the-second-act" target="_blank">
                <h2 class="title mb-6" id="article-1044">Production postmortem</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 03, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The topic of this post is a bug in RavenDB, a pretty serious one. The end result is that a user reported that they got an error from RavenDB that they are unable to read a stored document. In some cases, RavenDB needs to read a document on startup, which means that it wasn&#x2019;t able to start up if that document had this behavior.&#xA;As you can imagine, this is one of those issues that gets our full and immediate attention. The error itself gave us a lot of information:&#xA;&#xA; Dictionary mismatch on Dic #375&#xA;   at Voron.Data.Tables.ZstdLib.AssertSuccess(UIntPtr v, CompressionDictionary dictionary)&#xA;&#xA;This is related to RavenDB&#x2019;s document compression behavior. In order to get a great compression ratio from our documents, we train RavenDB on the recent documents that you have and generate a compression dictionary. The problem at hand is that the compression dictionary we have and the compression dictionary that was actually used are different. As you can see from the error, we are using zstd as the compression algorithm. When zstd generates a dictionary it will (by default) generate an id from that document that is mostly based on the xxhash64 of its content, rounded to 32 bits. You can see the relevant part here. This is pretty nice, since it means that there is a good chance that we&#x2019;ll detect the wrong dictionary.&#xA;So now we know what is going on, but we don&#x2019;t understand why.&#xA;When we wrote this feature, we were quite aware that we&#x2019;ll not be able to make any sort of sense from the documents if we don&#x2019;t have the right dictionary. For that reason, we store the dictionaries three times. Once inside of RavenDB itself and twice in ancillary files, which we can use during recovery. This sort of error should be utterly impossible. And yet, we had run into that in production, so we have to dig deeper still.&#xA;The primary suspect was the dictionary training portion. One of the things that RavenDB does on a continuous basis is measure the compression ratio of the documents, if we aren&#x2019;t able to hit a good compression ratio, RavenDB will try to generate a new dictionary from the most recent documents and see if that new dictionary can do better. This can be very helpful in maintaining good compression rates. As your documents change, RavenDB will detect that and realize that it can do better, retrain on the recent data and compress even further. The problem is that this code path is also quite tricky, we first compress the document using the current dictionary, then we try generating a new dictionary and see if compressing with the new dictionary is better. If that is the case, we can install the new dictionary for future operations, otherwise, we need to discard it.&#xA;I suspected that the issue was somewhere around that area, we might not be handling the rejection of the new dictionary properly. So I went into the code and started digging, but I found absolutely nothing. The entire process is covered in tests and has been in production for close to 18 months, so this isn&#x2019;t something that obvious.&#xA;After spending quite a bit of time on the issue, I decided that the code is perfect, it handled everything properly and taken into account all the right behaviors.&#xA;Clearly the fault was elsewhere. Before setting out to blame the nearest cat (you can never trust those), I had an idea, what if the problem wasn&#x2019;t during the training process, but afterward?&#xA;Well, that doesn&#x2019;t really matter, does it? RavenDB is a transactional database, if we had a failure after the training process, we&#x2019;ll have to discard some of the data, for sure, but that would be about it. Unless, what if we have some state that wasn&#x2019;t transactional? As part of looking at the compression training code, I ran into just such a scenario. Running the training to generate a new compression dictionary is an expensive proposition, so we don&#x2019;t want to do that often. As such, we&#x2019;ll do that for only about 1K document changes where we exceed the desired compression ratio by over 10%. How do we know to act every 1K documents? Well, we have a counter that we increment on every change. That value is incremented using Interlocked.Increment() and isn&#x2019;t part of the transactional state. If the transaction is aborted, the value is still incremented.&#xA0; The actual value doesn&#x2019;t matter, mind, only that it is moving forward, so that isn&#x2019;t an issue.&#xA;I mentioned the dictionary id before, but I should clarify that this is the zstd&#x2019;s dictionary id. Internally, RavenDB uses a different value. That value is simply the sequence number of the dictionary, RavenDB counts the number of generated dictionaries and gives the new dictionary the next available value. That value, by the way, is part of the transaction. If we rollback a transaction, we&#x2019;ll use the same dictionary id. But that doesn&#x2019;t matter, of course.&#xA;When using compression dictionaries, we need to load them from a buffer. There is quite a bit of work that is involved in that, there is memory allocation, entropy tables to load, etc. In order to save repeated work, RavenDB caches the compression dictionaries (after all, their whole point is to be used repeatedly). That cache can be used by multiple transactions at the same time (two read transactions using the same dictionary will use the same instance).&#xA;Given all of this information, here is the sequence of events that we need to get the error in question:&#xA;&#xA;The user enabled documents compression.&#xA;The user runs a transaction with at least four commands, which needs to satisfy the following conditions.&#xA;A document write as the first action.&#xA;Then a write to document whose compression ratio exceeded the expected ratio by over 10%, as a result, RavenDB tried to train a new compression dictionary.&#xA;That dictionary had a better compression ratio and was accepted as the new default compression dictionary.&#xA;RavenDB persisted the new dictionary and used that to compress the new document.&#xA;Another command (in the same transaction) had stored a document in the same collection, now RavenDB will read the new dictionary and store that in a cache.&#xA;A third command runs, but this one throws an error (such as optimistic concurrency violation).&#xA;&#xA;At this point, RavenDB will rollback the entire transaction and return the error to the user. Let&#x2019;s say the user has chosen to submit the same two documents again, shall we?&#xA;For the first command, we&#x2019;ll again discover that the compression ratio (of the old compression dictionary) is insufficient. We will not generate a new compression dictionary, why is that? Remember the counter that we increment using Interlocked? That one was not rolled back, so we&#x2019;ll need to wait for another 1K documents for the stars to properly align for us. That doesn&#x2019;t impact correctness in any way, shape or form, however.&#xA;At this stage, the stage is set, but everything is still okay. The problem will happen on the next time that we&#x2019;ll trigger a new dictionary. At that point, we&#x2019;ll again scan the most recent documents, build a dictionary, etc. However, the dictionary id that RavenDB will use will be identical to the dictionary id that we previously discarded. The data that dictionary was trained on, however, will almost certainly be different. We persist the new dictionary to disk and everyone is happy, the new document that we wrote will use the new compression dictionary and we are perfectly fine.&#xA;The next write for this collection, however, will run into a problem. It will need to use the current (the new one) dictionary when we want to make a write. In order to do that, it will load the value using the cache, but there is already a value for that dictionary in the cache, the same dictionary that was discarded. At this point, RavenDB will start compressing documents using the in memory dictionary while the on disk dictionary is different.&#xA;If you&#x2019;ll try to access the document which triggered the new dictionary, you&#x2019;ll get an error, but documents that were modified later will continue working with no issue. Until you restart, of course.&#xA;On restart, we&#x2019;ll read the dictionary from disk, where we wrote the new dictionary, at this point, all those documents that we wrote will give us the error above. Note that the sequence of events has to be very exact, you need to have a dictionary training as part of a multi act transaction which failed after the dictionary training has been successful and wrote additional documents. In a year and a half of production usage and very heavy load, that happened only a couple of times, it seems.&#xA;The issue has been fixed, of course and we&#x2019;ll be rolling it out to both users and cloud customers. We&#x2019;ll now rollback such in memory state on a transaction rollback as well, avoiding this issue entirely. It is amazing to me that despite very careful planning, it wasn&#x2019;t the code itself that caused a problem, but a sequence of independent operations and failure modes that we never even considered about this.</p>
        </article>
        <article id="article-1045">
            <a href="https://ayende.com/blog/195905-C/beating-fizzbuzz-for-detecting-qualified-candidates" target="_blank">
                <h2 class="title mb-6" id="article-1045">Beating FizzBuzz for detecting qualified candidates</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 31, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">FizzBuzz is a well known test to show that you can program. To be rather more exact, it is a simple test that does not tell you if you can program well, but if you cannot do FizzBuzz, you cannot program. This is a fail only kind of metric. We need this thing because sadly, we see people that fail FizzBuzz coming to interviews.&#xA;I have another test, which I feel is simpler than FizzBuzz, which can significantly reduce the field of candidates. I show them this code and ask them to analyze what is going on here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public class ControllerBase : Controller&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;               public static bool IsAdminUser;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          snap.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Acceptable answers include puking, taking a few moments to breathe into a paper bag and mild to moderate professional swearing.&#xA;This is something that I actually run into (about 15 years ago, in the WebForms days) and I have used it ever since. That is a great way to measure just how much a candidate knows about the environment in which they operate.</p>
        </article>
        <article id="article-1046">
            <a href="https://ayende.com/blog/195874-C/code-review-horror-in-4-lines-of-code" target="_blank">
                <h2 class="title mb-6" id="article-1046">Code review horror in 4 lines of code</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 30, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I run into the following code during code review and had an immediate and visceral reaction.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private readonly List&lt;string&gt; _messages;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public IReadOnlyList&lt;string&gt; Messages&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              get&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  lock (this)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      return _messages;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          horror.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is a (bad) attempt to add thread safety, because you are getting a value through a read only interface, but there is still the mutable instance to work with at the source, and now you have someone that observes the instance while it is being mutated, outside the lock.&#xA;The proper way to handle this is to copy the list (under the lock) and return a distinct copy.</p>
        </article>
        <article id="article-1047">
            <a href="https://ayende.com/blog/195873-C/a-year-or-monitoring-production" target="_blank">
                <h2 class="title mb-6" id="article-1047">A year or monitoring production</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 29, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The end of the year is closing fast, and I run into the following metric (below). What you can see here is one of our RavenDB production instances over the past year. We are continuously dogfooding our own software, and there is a clear indication of the results.What you can see here is the total memory used by RavenDB (production load, fairly constant over time)&#xA0; for the past year. As we update RavenDB, we benefit from various optimizations, and the trend line is very encouraging.Around August, we had a change that saved us a single allocation in some cases, here is the chance, you can see the impact it had:We also started using a new feature in production around December, and that seems to have an additional memory cost, so we optimized that as well:You can see the new build deployed around the 17th of the month.</p>
        </article>
        <article id="article-1048">
            <a href="https://ayende.com/blog/195745-C/implementing-a-file-pager-in-zig-managing-chunk-metadata" target="_blank">
                <h2 class="title mb-6" id="article-1048">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 28, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The file pager needs to know what values it has in memory and what it needs from the disk. Instead of tracking values on a per page level, we are going to do that on a chunk basis, where each chunk in 2MB (256 pages). A single file is going to be limited to 8 GB in size, so we have a maximum of 4,096 chunks in a file. We can allocate a simple array of metadata for the entire file in a single shot. That means that we don&#x2019;t have to do reallocation when we grow the size of the file (up to the 8GB maximum). Let&#x2019;s consider what metadata we need to know about the chunks we have:&#xA;&#xA;What is the status of the chunk (in memory, on the disk, being loaded or errored).&#xA;How many outstanding references we have for a chunk?&#xA;Where do we find the actual chunk data in memory, when it is loaded?&#xA;&#xA;The whole thing is made complex because we have to consider concurrency. Multiple threads may try to load a chunk at the same time, we may need to release the memory of a chunk to make room for loading another, etc. We also need to consider issues such as I/O failures, optimizing I/O patterns, etc. For now, I/O will be handled by another post. I want to focus just on how we will deal with the metadata.&#xA;A major PITA with concurrency is how to handle reference tracking. If a thread is reading from a chunk, we cannot release it. That leads us to reference counting, but that is tough to do atomically. You have to deal with the ABA problem, to start with. For that reason, we want to limit chunk metadata to 8 bytes in total. This will allow us to use atomic instructions to modify the metadata safely.&#xA;Using just 8 bytes is a very low amount. We know that the chunks we&#x2019;ll use are 2MB in size. We can assume that we&#x2019;ll also align them on 2MB boundary. That means that the lower 20 bits are unused, we can repurpose them. On x64 and ARM64, the top 16 bits are also unused (not always true, since from 2019 we have IceLake that has PML5, which uses 57 bits, but very likely to be the case). In most systems, the 47th bit will be used for kernel vs. user memory, so that will be cleared as well. That means that we actually only need 64 &#x2013; 17 &#x2013; 20 = 27 bits to store the pointer value. We can repurpose the other 37 bits.&#xA;There are actually several ways in which we can do this. The compressed pointer method is just one of them. I decided to not go that route. Instead, we are going to have the following structure:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          packed struct { // 64 bits in total &#xA;        &#xA;        &#xA;          &#xA;              tag: enum(u2) {&#xA;        &#xA;        &#xA;          &#xA;                  Empty = 0b00,&#xA;        &#xA;        &#xA;          &#xA;                  Error = 0b01,&#xA;        &#xA;        &#xA;          &#xA;                  Loading = 0b10,&#xA;        &#xA;        &#xA;          &#xA;                  Value = 0b11,&#xA;        &#xA;        &#xA;          &#xA;              },&#xA;        &#xA;        &#xA;          &#xA;              version: u16,&#xA;        &#xA;        &#xA;          &#xA;              references: u20,&#xA;        &#xA;        &#xA;          &#xA;              offsetInPages: u26,&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          metadata_struct.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is a packed bit field struct which can fit into a 64 bits value. Note that we have fields for the type of the value, the version (for ABA) and the number of references. In addition to that, we also have the actual value, which is specified in offsetInPages. Let&#x2019;s talk about sizes here.&#xA;&#xA;The tag field has four options, as you can see.&#xA;The version field is 16 bits, which means that it can have 65,536 possible values. It will be incremented on every change to the value and used to avoid false successes when updating the value concurrently.&#xA;The references field is 20 bits in size, giving us 1 million values here. That is the number of concurrent references that it can support. That looks like big enough value that we shouldn&#x2019;t care about it.&#xA;The offsetInPages field is 26 bits in size. Assuming 4 KB pages, we can reference up to 256 GB of memory. We&#x2019;ll want to support machines with higher memory than that, which is why we&#x2019;ll also add the concept of base. For a single file, all the allocations must come in the same 256 GB range. I don&#x2019;t expect that to be a big problem, and different files can have different bases.&#xA;&#xA;The fact that all of that fits in 64 bits means that we can use simple Compare &amp; Swap atomic operations and avoid the need for 128 bits atomic instructions. To be fair, cmpxchg16b has been around forever. I believe that you can do that on ARM as well, but I&#x2019;m not sure how.&#xA;At any rate, let&#x2019;s look at the ChunkMetadata struct in all its glory, then we&#x2019;ll discuss what is going on:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const ChunkMetadata = packed union {&#xA;        &#xA;        &#xA;          &#xA;              v: packed struct {&#xA;        &#xA;        &#xA;          &#xA;                  tag: enum(u2) {&#xA;        &#xA;        &#xA;          &#xA;                      Empty = 0b00,&#xA;        &#xA;        &#xA;          &#xA;                      Error = 0b01,&#xA;        &#xA;        &#xA;          &#xA;                      Loading = 0b10,&#xA;        &#xA;        &#xA;          &#xA;                      Value = 0b11,&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;                  version: u16,&#xA;        &#xA;        &#xA;          &#xA;                  references: u20,&#xA;        &#xA;        &#xA;          &#xA;                  offsetInPages: u26,&#xA;        &#xA;        &#xA;          &#xA;              },&#xA;        &#xA;        &#xA;          &#xA;              raw: u64,&#xA;        &#xA;        &#xA;          &#xA;              half: u32,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              comptime {&#xA;        &#xA;        &#xA;          &#xA;                  if (@sizeOf(ChunkMetadata) != @sizeOf(u64)) {&#xA;        &#xA;        &#xA;          &#xA;                      @compileError(&quot;ChunkMetadata must be 64 bits in size! was &quot; &#x2B; @sizeOf(ChunkMetadata));&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn get(self: *ChunkMetadata, base: usize) !?*u8 {&#xA;        &#xA;        &#xA;          &#xA;                  while (true) {&#xA;        &#xA;        &#xA;          &#xA;                      var cur = self;&#xA;        &#xA;        &#xA;          &#xA;                      switch (cur.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                          .Empty =&gt; return null,&#xA;        &#xA;        &#xA;          &#xA;                          .Error =&gt; return @intToError(@intCast(u16, cur.v.offsetInPages)),&#xA;        &#xA;        &#xA;          &#xA;                          .Loading =&gt; return error.ValueIsLoading,&#xA;        &#xA;        &#xA;          &#xA;                          .Value =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      if (cur.v.offsetInPages == 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.ValueIsInvalid;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var val = @intToPtr(*u8, @intCast(u64, cur.v.offsetInPages) * std.mem.page_size &#x2B; base);&#xA;        &#xA;        &#xA;          &#xA;                      var updated = cur;&#xA;        &#xA;        &#xA;          &#xA;                      if (updated.v.references == std.math.maxInt(@TypeOf(updated.v.references))) {&#xA;        &#xA;        &#xA;          &#xA;                          // more than 255K concurrent references is unlikley&#xA;        &#xA;        &#xA;          &#xA;                          return error.ChunkReferencesOverflow;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      updated.v.references &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;                      updated.v.version &#x2B;%= 1;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var result = @cmpxchgWeak(u64, &amp;self.raw, cur.raw, updated.raw, .Monotonic, .Monotonic);&#xA;        &#xA;        &#xA;          &#xA;                      if (result == null)&#xA;        &#xA;        &#xA;          &#xA;                          return val; // successfully incremented the ref count&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn trySetError(self: *ChunkMetadata, err: anyerror) !void {&#xA;        &#xA;        &#xA;          &#xA;                  return trySet(self, null, err);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub const PtrWithBase = struct { ptr: *u8, base: usize };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn trySetValue(self: *ChunkMetadata, value: PtrWithBase) !void {&#xA;        &#xA;        &#xA;          &#xA;                  return trySet(self, &amp;value, null);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn tryLoading(self: *ChunkMetadata) !void {&#xA;        &#xA;        &#xA;          &#xA;                  return trySet(self, null, null);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              fn trySet(self: *ChunkMetadata, value: ?*const PtrWithBase, err: ?anyerror) !void {&#xA;        &#xA;        &#xA;          &#xA;                  while (true) {&#xA;        &#xA;        &#xA;          &#xA;                      var cur = self;&#xA;        &#xA;        &#xA;          &#xA;                      switch (cur.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                          .Error =&gt; return @intToError(@intCast(u16, cur.v.offsetInPages)),&#xA;        &#xA;        &#xA;          &#xA;                          .Value =&gt; return error.ValueIsAlreadySet,&#xA;        &#xA;        &#xA;          &#xA;                          .Loading =&gt; {&#xA;        &#xA;        &#xA;          &#xA;                              if (value == null and err == null) {&#xA;        &#xA;        &#xA;          &#xA;                                  return error.ValueIsAlreadyLoading;&#xA;        &#xA;        &#xA;          &#xA;                              }&#xA;        &#xA;        &#xA;          &#xA;                          },&#xA;        &#xA;        &#xA;          &#xA;                          .Empty =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var updated = cur;&#xA;        &#xA;        &#xA;          &#xA;                      updated.v.references = 1;&#xA;        &#xA;        &#xA;          &#xA;                      updated.v.version &#x2B;%= 1;&#xA;        &#xA;        &#xA;          &#xA;                      if (value) |val| {&#xA;        &#xA;        &#xA;          &#xA;                          updated.v.tag = .Value;&#xA;        &#xA;        &#xA;          &#xA;                          var v = (@ptrToInt(val.ptr) - val.base) / std.mem.page_size;&#xA;        &#xA;        &#xA;          &#xA;                          if ((try std.math.mod(usize, @ptrToInt(val.ptr), std.mem.page_size)) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                              return error.ValuePtrMustBePageAligned;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          if (v == 0) {&#xA;        &#xA;        &#xA;          &#xA;                              return error.ValuePtrCannotBeNullOrSamePageAsBase;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          if (v &gt; std.math.maxInt(@TypeOf(updated.v.offsetInPages))) {&#xA;        &#xA;        &#xA;          &#xA;                              return error.ValuePtrIsTooFarFromBase;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          updated.v.offsetInPages = @intCast(@TypeOf(updated.v.offsetInPages), v);&#xA;        &#xA;        &#xA;          &#xA;                      } else if (err) |e| {&#xA;        &#xA;        &#xA;          &#xA;                          updated.v.tag = .Error;&#xA;        &#xA;        &#xA;          &#xA;                          updated.v.offsetInPages = @errorToInt(e);&#xA;        &#xA;        &#xA;          &#xA;                      } else {&#xA;        &#xA;        &#xA;          &#xA;                          updated.v.tag = .Loading;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var result = @cmpxchgWeak(u64, &amp;self.raw, cur.raw, updated.raw, .Monotonic, .Monotonic);&#xA;        &#xA;        &#xA;          &#xA;                      if (result == null) {&#xA;        &#xA;        &#xA;          &#xA;                          std.Thread.Futex.wake(self.futexPtr(), std.math.maxInt(u32));&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn release(self: *ChunkMetadata) void {&#xA;        &#xA;        &#xA;          &#xA;                  while (true) {&#xA;        &#xA;        &#xA;          &#xA;                      var cur = self;&#xA;        &#xA;        &#xA;          &#xA;                      var updated = cur;&#xA;        &#xA;        &#xA;          &#xA;                      if (updated.v.tag != .Value) {&#xA;        &#xA;        &#xA;          &#xA;                          @panic(&quot;Attempted to release a chunk whose tag isn&#x27;t set to Value.&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (updated.v.references == 0) {&#xA;        &#xA;        &#xA;          &#xA;                          @panic(&quot;Attempted to release the chunk more times than you got it&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      updated.v.references -= 1;&#xA;        &#xA;        &#xA;          &#xA;                      updated.v.version &#x2B;%= 1;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var result = @cmpxchgWeak(u64, &amp;self.raw, cur.raw, update.raw, .Monotonic, .Monotonic);&#xA;        &#xA;        &#xA;          &#xA;                      if (result == null) {&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn waitForValue(self: *ChunkMetadata, base: usize, timeout: ?u64) !?*u8 {&#xA;        &#xA;        &#xA;          &#xA;                  while (true) {&#xA;        &#xA;        &#xA;          &#xA;                      var cur = self;&#xA;        &#xA;        &#xA;          &#xA;                      if (cur.v.tag != .Loading) {&#xA;        &#xA;        &#xA;          &#xA;                          return try self.get(base);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      try std.Thread.Futex.wait(self.futexPtr(), cur.half, timeout);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              fn futexPtr(self: *ChunkMetadata) *std.atomic.Atomic(u32) {&#xA;        &#xA;        &#xA;          &#xA;                  // this covers the tag, version &amp; some of the references fields&#xA;        &#xA;        &#xA;          &#xA;                  // given that the version field always changing, it is a good futex value&#xA;        &#xA;        &#xA;          &#xA;                  return @ptrCast(*std.atomic.Atomic(u32), &amp;self.half);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          metadata.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The ChunkMetadata can be in one of four states:&#xA;&#xA;Empty &#x2013; there is no value&#xA;Error &#x2013; we tried to load the chunk, but failed for some reason. In that case, the actual error code is stored in offsetInPages.&#xA;Loading &#x2013; we are currently loading the chunk, and callers can decide to wait for this or try again later.&#xA;Value &#x2013; there is a value in the chunk and it is available immediately.&#xA;&#xA;When we get() a value we check what the current state of the metadata is and in all but the Value case we&#x2019;ll return immediately. If there is a value, we can&#x2019;t just return it to the caller. We need to increment the reference count. That is most of the code in the get() method. We increment the references, do a wrapping increment for the version (so each change will be unique) and then use an atomic operation to update the value. The idea is that two concurrent threads getting the value at the same time will always increment or decrement the references properly. That will be quite important later on.&#xA;After you are done with the chunk, you can release() it, which will decrement the reference count. Note that reference count of 0 is wrong, we aren&#x2019;t handling actual releasing of values yet. That will come in another post.&#xA;The trySet() function is responsible for the other side, it will set the value or the error, taking care of the concurrency aspects of the ChunkMetadata. Of particular interest here, however, is the Futex.wake() call. That deserves some detail.&#xA;Consider the sequence of events for accessing a chunk. We may have two threads that try to get a chunk, but they find that it is not resident in memory. It needs to be loaded, but we don&#x2019;t want both threads to do so at once. Therefore, the threads will compete on moving the chunk from the Empty state to the Loading state. After which, the thread that won the race will need to schedule the actual I/O. What does the other thread do in the meantime? It needs to wait until the I/O is completed. This is done using the waitForValue() method, where we interpret the first half of the chunk metadata (the one holding the version field) as a Futex.wait&#xA0; value. In other words, the thread will sleep until the trySet() call will wake it.&#xA;That is enough talking about the ChunkMetadata, I think. We went over that in detail, for my next post, I want to talk about how we deal with what is likely to be the most interesting bit of the file pager, managing the actual chunks.</p>
        </article>
        <article id="article-1049">
            <a href="https://ayende.com/blog/195713-B/implementing-a-file-pager-in-zig-overall-design" target="_blank">
                <h2 class="title mb-6" id="article-1049">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 27, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I showed how we can get a pretty nice pager (important for building a storage system) in under 100 lines of code using mmap(). If that was all of it, it would be a pretty short series of posts. However, I want to explore what it would take to take ownership of that part of the storage system and build our own from scratch. Let&#x2019;s see what it would take to build a pager when we are doing the I/O.&#xA;In the mmap() implementation, I didn&#x2019;t really have a lot of states. Just the mapping and that was pretty much it. When building our own, we need to track a whole lot more states. Off the top of my head, we need to:&#xA;&#xA;Track what pages we handed out to callers.&#xA;Track usage of pages so we&#x2019;ll know when to release them.&#xA;Manage concurrency explicitly between threads.&#xA;Handle several scenarios that were just&#x2026; working on the mmap() implementation.&#xA;&#xA;For example, let&#x2019;s talk about what kind of state I need. Zig comes with a hash table (and does that beautifully for an unmanaged language), so I can do this, right?&#xA;&#xA;pages: std.AutoHashMap(u64, Page),&#xA;&#xA;That would be a mapping between the pages in memory and the memory we allocated for them. Except&#x2026; that it doesn&#x2019;t quite work like that. One of the key issues that we have to deal with is the fact that while most of the time we will ask for a page, we can also ask for a continuous run of pages.&#xA;We can safely assume that the caller is responsible for ensuring that there is no duplication. In other words, the following sequence of calls is invalid:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var p1 = try pager.tryGet(5, 4); // get 4 pages, from the 5th page (32KB)&#xA;        &#xA;        &#xA;          &#xA;          var p2 = try pager.tryGet(6, 1); // get the 6th page, overlapping with p1&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          invalid.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;That is a very important limit to how much complexity we have to deal with, I have to note. Another thing to deal with is concurrency. How do we deal with scenarios where two threads want to get pages (which may or may not be the same)?&#xA;Anther consideration is about reduce the overall cost of I/O, we don&#x2019;t want to issue too many operations, both for reads and for writes. That pushes us toward batching operations as much as possible. Here is the overall design that I have for the file pager:&#xA;&#xA;&#xA;&#xA;In other words, even though we are dealing with 8KB pages, the pager itself will issue work with chunks of 2MB in size each time. The idea is that we can&#xA0; amortize the cost of going to the disk by ensuring that we&#x2019;ll do bulk I/O. That, in turn, means that we have to consider some aspects of our system very early on.&#xA;In the case of the mmap pager, we didn&#x2019;t really need to think about caching, that was the responsibility of the operating system. In the case of this pager, we must&#xA0;have a cache, and if we cache a chunk, we can probably benefit greatly from locality of reference, which is always nice.&#xA;The 2MB chunk size design decision complicate our lives. The pager needs to handle both single pages access and work with values that may span multiple pages. As long as they reside in a single chunk, that is pretty easy. But we need to consider how we&#x2019;ll manage to work with values that are bigger than 2MB in size. It&#x2019;s interesting, because even at this very early stage, a design decision on how big the size we fetch from the disk will have impact for the implementation of the entire system.&#xA;As early as we are, we can make the following assumption / requirements from our callers:&#xA;&#xA;Most of the access is going to be for single pages.&#xA;Some of the accesses will be for multiple pages, but under the 2 MB chunk limit.&#xA;Few accesses will need to work with multiple pages over the 2 MB limit.&#xA;&#xA;That is important because it impacts the way we think about the system. Earlier in this post, I mentioned using a hash map to store the references to the pages. With chunks, we can probably adjust slightly and be done with it, right?&#xA;Except that we really can&#x2019;t. One of the primary issues that we have to deal with is the fact that this is meant to be concurrent. A hash map isn&#x2019;t going to support that and will need to be protected by a lock. Interestingly, most concurrent data structures pretty much require garbage collection of some sort and building them with an unmanaged system is quite complex.&#xA;How do we deal with this issue? It turns out that it is far simpler to have an array to hold those references and access each element using atomic instructions. Here we run into another design decision. Are we going to have a single file or multiple files? That matters because if we have a single file, we need to deal with increasing the file size on the fly. That means that the array of references would need to grow, and that is also complex with concurrent access. If we have multiple files, we can just create a completely new file as needed. We can allocate a single array at the maximum file size and not worry about it. There are other reasons why we might want to use multiple files (such as making it easier to release space back to the file system), so we&#x2019;ll go with multiple files.&#xA;That means that we can reasonably set the maximum file size at 8GB (remember the big values issue, I think it is reasonable to set the max size of a value at 2GB, so 8GB is plenty). With 8GB files, we are talking about 4,096 chunks of 2 MB each. Assuming that we&#x2019;ll use an 8 bytes struct to hold the data about each chunk, that means that we can safely allocate the maximum size of 32Kb upfront. If we need to increase the size of the file, we already allocated the place for its metadata. That gives us a far simpler system (no need to try to manage concurrent accesses) at a small memory cost.&#xA;Now, we can require that page allocations that are below 2 MB in size will always be aligned inside a page boundary. But what happens when we have a value whose size exceeds 2MB? The answer to that is that we are going to require the calling code to follow specific patterns for that. We require that any value that is greater than 2MB will be aligned on a 2MB boundary from the end of the final chunk. Here is what this looks like, the yellow marked pages are allocated on two separate chunks, and you can see how we aligned this on the end:&#xA;&#xA;The nice thing about this approach is that we know that the caller will not do partial calls. If we asked for pages 5 - 10, there can be no call to page 6 on an independent basis. As such, when we ask for a value that is bigger than a single chunk, it will always be expressed as a load from the starting chunk to the end. That means that we can load the full value in a single I/O call.&#xA0; Here, again, we have very low level concerns affecting how we lay out the data on disk.&#xA;There are other aspects that we need to consider, such as eviction policies, how to handle concurrency, etc. But that is enough for one post, I intentionally want to limit the scope of what we do to avoid getting mired in the details. Expect more in the next post in the series.</p>
        </article>
        <article id="article-1050">
            <a href="https://ayende.com/blog/195588-B/implementing-a-file-pager-in-zig-using-mmap" target="_blank">
                <h2 class="title mb-6" id="article-1050">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 24, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Now that we know what we want to implement, let&#x2019;s dig a bit deeper and see how to do it. An interesting way to implement a file pager is to&#x2026; not do that. Instead, we can rely on the OS&#x2019; memory mapping to do most of the heavy lifting. Let&#x2019;s see how we can do that.&#xA;The first thing that we need to manage is the setup and teardown of the pager, which you can see here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const MmapPager = struct {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub const PageSize = 8 * 1024;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              ptr: []align(std.mem.page_size) u8,&#xA;        &#xA;        &#xA;          &#xA;              len: u64,&#xA;        &#xA;        &#xA;          &#xA;              allocator: *std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              pub fn init(fd: std.os.fd_t, allocator: *std.mem.Allocator) !MmapPager {&#xA;        &#xA;        &#xA;          &#xA;                  var stats = try std.os.fstat(fd);&#xA;        &#xA;        &#xA;          &#xA;                  var ptr = try std.os.mmap(&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      @intCast(usize, stats.size),&#xA;        &#xA;        &#xA;          &#xA;                      std.os.PROT_READ | std.os.PROT_WRITE,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.MAP_SHARED,&#xA;        &#xA;        &#xA;          &#xA;                      fd,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;                  return MmapPager{&#xA;        &#xA;        &#xA;          &#xA;                      .ptr = ptr,&#xA;        &#xA;        &#xA;          &#xA;                      .len = @intCast(u64, stats.size),&#xA;        &#xA;        &#xA;          &#xA;                      .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn deinit(self: *MmapPager) void {&#xA;        &#xA;        &#xA;          &#xA;                  std.os.munmap(self.ptr);&#xA;        &#xA;        &#xA;          &#xA;                  self.ptr = undefined;&#xA;        &#xA;        &#xA;          &#xA;                  self.len = 0;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There isn&#x2019;t much here, we simply call mmap() and that is about&#x2026; it. Let&#x2019;s see how we can implement the actual pager behavior. We&#x2019;ll start with the easy pieces here getting and releasing the memory from the pager:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn getBlocking(self: *MmapPager, page: u64, count: u32) !Page {&#xA;        &#xA;        &#xA;          &#xA;              return Page{&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = self.ptr[page * PageSize .. (page * PageSize &#x2B; count * PageSize)],&#xA;        &#xA;        &#xA;          &#xA;                  .numberOfPages = count,&#xA;        &#xA;        &#xA;          &#xA;                  .page = page,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          pub fn release(self: *MmapPager, page: Page) void {&#xA;        &#xA;        &#xA;          &#xA;              _ = self;&#xA;        &#xA;        &#xA;          &#xA;              // we don&#x27;t need to actually release anything here&#xA;        &#xA;        &#xA;          &#xA;              page.buffer = undefined;&#xA;        &#xA;        &#xA;          &#xA;              page.numberOfPages = undefined;&#xA;        &#xA;        &#xA;          &#xA;              page.page = undefined;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          get_release.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;You&#x2019;ll notice that we don&#x2019;t actually have anything here? Even the act of checking that the page is within the bound of the mapped memory is done by slicing the ptr directly. What about the blocking part? How do we actually move the data to memory? The answer is that we aren&#x2019;t. When you access the pointer we return from the get(), we&#x2019;ll just get a page fault and the OS will read the data from the disk.&#xA0; The release() function also doesn&#x2019;t need to do much, all the behavior is inside the mmap() implementation, after all.&#xA;A bit more complex is the part where we try to get the pages from the disk, here is the tryGet() implementation:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn tryGet(self: *MmapPager, page: u64, count: u32) !?Page {&#xA;        &#xA;        &#xA;          &#xA;              const buf = try self.allocator.alloc(u8, count);&#xA;        &#xA;        &#xA;          &#xA;              defer self.allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.set(u8, buf, 0);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              const start = self.ptr[page * PageSize ..];&#xA;        &#xA;        &#xA;          &#xA;              const size = count * PageSize;&#xA;        &#xA;        &#xA;          &#xA;              const rc = c.mincore(&amp;start[0], size, &amp;buf[0]);&#xA;        &#xA;        &#xA;          &#xA;              if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return @intToError(@intCast(u16, std.os.errno(rc)));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (buf) |b| {&#xA;        &#xA;        &#xA;          &#xA;                  if (b &amp; 1 == 0) {&#xA;        &#xA;        &#xA;          &#xA;                      try std.os.madvise(@ptrCast([*]u8, start), size, std.os.MADV_WILLNEED);&#xA;        &#xA;        &#xA;          &#xA;                      return null; // not all in memory&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // can return to the caller immediately&#xA;        &#xA;        &#xA;          &#xA;              return try getBlocing(self, page, count);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          tryGet.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;That is quite a bit of code for not much in practice. We create a temporary array and then call mincore() on the range of memory that we&#x2019;ll return. If the entire range is not already in memory, we&#x2019;ll call madvice() to load it in the background and return null. If the range is already in memory, just return it.&#xA;This isn&#x2019;t 100% safe to do, by the way, there may be race conditions that would cause us to think that the data is in memory just as it is swapped to disk, but that is good enough for our needs. Especially because the whole thing is quite simple overall.&#xA;The next stage is to handle writes and syncing to disk. This is simplicity itself, in this model.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn write(self: *MmapPager, page: Page) !void {&#xA;        &#xA;        &#xA;          &#xA;              // nothing to do, the data is already written to&#xA;        &#xA;        &#xA;          &#xA;              // the memory map&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          pub fn sync(self: *MmapPager) !void {&#xA;        &#xA;        &#xA;          &#xA;              if (c.msync(&amp;self.ptr[0], self.ptr.len, c.MS_SYNC) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return @intToError(@intCast(u16, std.os.errno(rc)));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          write_sync.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Since we handed out a buffer from the memory map itself, we don&#x2019;t need to do any copying, we already modified that range of memory. And when we sync to the file, we can do that by a single msync() call. There are a few things to note here, though:&#xA;&#xA;Because we are writing directly to the memory mapped file, it is possible that our changes will show up in the file before write and sync are called.&#xA;The msync() will sync the entire range, if we have smaller changes that we made, we can try to reduce the amount of memory that is synced by remembering what parts we have written to, but it ends up being quite a chore. And since the OS is already doing that for us, we can shell that to it directly.&#xA;&#xA;And that is pretty much it. The whole pager is under 100 lines of code.&#xA;There are some things that I don&#x2019;t handle, such as what happens if we want to extend the size of the file. That requires us to re-wire the mapping, if we are going by the strict reading of the API. But in both Linux &amp; Windows, you can define a memory mapping that is greater than the file and that will automatically adjust as you grow the file. That is quite a nice feature for us and can save us a lot of management overhead internally.&#xA;With that out of the way, we can start implementing higher level functions in a storage system. But notice how we moved pretty much everything to the OS? What would it look like if we wanted to build that ourselves?</p>
        </article>
        <div class="button flex justify-between">
            <a href="104.html"><span class="back arrow"></span></a>

            <a href="106.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>

<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;🚀&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="about.html"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="/pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>
