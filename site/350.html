
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 350 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-3491">
            <a href="https://ayende.com/blog/169825/excerpts-from-the-ravendb-performance-team-report-optimizing-memory-compare-copy-costs" target="_blank">
                <h2 class="title mb-6" id="article-3491">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 26, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Note, this post was written by Federico. Where I had notes or stuff to extend, I explicitly marked it as such. TLDR: Optimizing at this level is really hard. To achieve gains of 20%&#x2B; for Compare and from 200% to 6% in Copy (depending on the workload) we will need to dig very deep at the IL level.  Another area we looked deeply into is, how do we move and access the memory. This type of optimization work is especially relevant if you are using Voron to handle big workloads. With small databases the improvements can be felt, but where they shine is when dealing with multi-gigabyte databases or high-throughput key-value retrieves and put workloads (did anyone thought Bulk-Inserts?).  Using FreeDB as in this previous post we build an experiment which we could use to pinpoint the pain points making sure we could also repro it every single time (no indexes, no extra call around). Under the microscope 2 pain points were evident when dealing with memory. Comparing and moving memory around.  We usually compare memory straight from the mmaped unmanaged memory when looking for a particular document in Voron Trees; and to copy from and to Voron pages when storing and retrieving documents. These are very core operations for any storage engine, Voron is not an special case. Before we started the optimization effort we already had a pretty optimized routine.  What this method does is:   If the memory blocks have zero size, there is no doubt they are equal. If the memory blocks are bigger than the size of a word (32 bits) we do a pre-compare over the aligned memory blocks (for performance) in order to rule out all the equals. As we cannot use words to calculate the output (handling the Endianness would cost us), we do a byte by byte comparison for the final check.&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   For our insert workload we were roughly in the 97.5 nanoseconds per memory compare in average. To put in context, if each assembler instruction could be executed in exactly 1 cycle (which usually is not true) then 3 instruction is an entire nanosecond, therefore our average instruction budget is 291 instructions. Remember this idealized processor, we will use this same comparison later for more complex analysis.  Memory compares can be of different sizes that is why controlling the environment is very important for this type of optimization work.  To deal with that and we were using many tricks from the optimization book. From ensuring that memory alignment is optimal to batch compares with bigger primitive sizes to pointer arithmetic. At first sight this one is the kind of method you won&#x27;t optimize at all, it is pretty damn tight.  Ayende&#x2019;s node &#x2013; We have already done a optimization step on memory comparisons. We initially just shelled out to the native memcmp method, but the cost of doing a pinvoke call ended up being noticable, and we wrote the previously optimized version (and had several rounds of that) to alleviate that cost.  However, we took to the challenge because the payoff can be huge. For a very small bulk insert of 50,000 documents inserted in an empty database, we are talking about in the ballpark of 5 million compares (yeah you read it right). Even if we manage to squeeze 1% off, the sheer volume of calls will make it worthwhile. To achieve that we had to do the unthinkable, we had to resort to dig into the MSIL that method was generating. Armed with ILSpy we found out we may have a way to shave off some inefficiencies. Here is the what this look like when we start actually putting analysis to action. You can see the method code (after decompilation, so we can be closer to the IL) as well as the issues that were discovered in the process.     Because of the size of the method the fastest way was to resort to use a C# decompile, even though we then matched it with the generated IL. The trick to use the C# decompiled version requires that we use a decompiler that is not too smart when dealing with the code. If the decompiler would have understood what was the original code intention and acted upon it, we would have never spotted some of the optimizations at this level. For example, the last loop decompiled with JetBrains dotPeek would look like this:    Always keep around an old version of a decompiler just in case you may need it .  Ayende&#x2019;s note: In most cases, you can select the level of details that a decompiler can give you. With Reflector, for example, you can select how deeply it will decompile things, but even so, doing stupid decompilation can be very beneficial by showing us what is actually going on.  Understanding where the inefficiencies may be, is one thing, being able to prove them is another matter. And we will tackle all of them in future posts. We will also leave the memcpy analysis for later because it builds on the optimizations used in memcmp and also requires a deep analysis of the Buffer.Memcpy method already available in the .Net Framework (for internal use of course).   If what we did to the poor Etags was evil. You are now arriving at the gates of the underworld.  Ayende&#x2019;s note: This is a pretty complex topic, and it goes on for quite a while. In order to maintain interest, and to avoid having people getting lost in the details, I broke it apart for several posts. In the meantime, given the details in this post, how would you suggest improving this?</p>
        </article>
        <article id="article-3492">
            <a href="https://ayende.com/blog/169800/excerpts-from-the-ravendb-performance-team-report-expensive-headers-and-cache-effects" target="_blank">
                <h2 class="title mb-6" id="article-3492">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 23, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This ended up being a pretty obvious, in retrospect. We noticed in the profiler that we spent a lot of time working with headers. Now, RavenDB is using REST as the communication layer, so it is doing a lot with that, but we should be able to do better. Then Tal dug into the actual implementation and found:  public string GetHeader(string key)&#xA;{&#xA;&#x9;if (InnerHeaders.Contains(key) == false)&#xA;&#x9;&#x9;return null;&#xA;&#x9;return InnerHeaders.GetValues(key).FirstOrDefault();&#xA;}&#xA;&#xA;public List&lt;string&gt; GetHeaders(string key)&#xA;{&#xA;&#x9;if (InnerHeaders.Contains(key) == false)&#xA;&#x9;&#x9;return null;&#xA;&#x9;return InnerHeaders.GetValues(key).ToList();&#xA;}&#xA;&#xA;&#xA;public HttpHeaders InnerHeaders&#xA;{&#xA;&#x9;get&#xA;&#x9;{&#xA;&#x9;&#x9;var headers = new Headers();&#xA;&#x9;&#x9;foreach (var header in InnerRequest.Headers)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (header.Value.Count() == 1)&#xA;&#x9;&#x9;&#x9;&#x9;headers.Add(header.Key, header.Value.First());&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;headers.Add(header.Key, header.Value.ToList());&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (InnerRequest.Content == null)&#xA;&#x9;&#x9;&#x9;return headers;&#xA;&#xA;&#x9;&#x9;foreach (var header in InnerRequest.Content.Headers)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (header.Value.Count() == 1)&#xA;&#x9;&#x9;&#x9;&#x9;headers.Add(header.Key, header.Value.First());&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;headers.Add(header.Key, header.Value.ToList());&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;return headers;&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;To be fair, this implementation was created very early on, and no one ever actually spent any time looking it since (why would they? it worked, and quite well). The problem is the number of copies that we have, and the fact that to pull a since header, we have to copy all the headers, sometimes multiple times. We replaced this with code that wasn&#x2019;t doing stupid stuff, and we couldn&#x2019;t even find the cost of working with headers in the profiler any longer.&#xA;But that brings up a really interesting question. How could we not know about this sort of thing? I mean, this isn&#x2019;t the first time that we are doing a performance pass on the system. So how come we missed this?&#xA;The answer is that in this performance pass, we are doing something different. Usually we perf-test RavenDB as you would when using it on your own systems. But for the purpose of this suite of tests, and in order to find more stuff that we can optimize, we are actually working with a stripped down client, no caching, no attempt to optimize things across the entire board. In fact, we have put RavenDB in the worst possible situation, all new work, and no chance to do any sort of optimizations, then we start seeing how all of those code paths that were rarely hit started to light up quite nicely.</p>
        </article>
        <article id="article-3493">
            <a href="https://ayende.com/blog/169799/excerpts-from-the-ravendb-performance-team-report-the-long-tale-of-a-lambda" target="_blank">
                <h2 class="title mb-6" id="article-3493">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 22, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This nugget was discovered by Tal, who was measuring write throughput and noticed that a lot of the time wasn&#x2019;t being handled in the proper code path, but on something on the side that seemed&#x2026; off.  prefetchingQueue.Aggregate(0, (x,c) =&gt; x &#x2B; SelectSerializedSizeOnDiskIfNotNull(c)) &gt; context.Configuration.AvailableMemoryForRaisingBatchSizeLimit) This piece of code is responsible for heuristics deep inside the bowels of RavenDB. In fact, it is the piece that decide whatever we have enough memory to index directly from memory or do we need to start dumping stuff and pay the I/O cost of them later.  As a result, this piece of code is called once for every document save. It was also quite wildly inefficient. The Aggregate implementation was pretty much as you imagined it, and it took three times as much time as actually process the rest of the request. The underlying reason was that we kept doing a foreach and a delegate invocation on each an every call. The more documents we had coming in, the more work we had to do. Shlemiel the painter at his best. We first saw a major improvement by just removing the Aggregate() call in favor of a purpose built function that summed all those details for us directly. Next, we changed things so instead of doing O(N) work per request, we could do an O(1) work by doing this work one bit at a time and aggregating it on the fly. So whenever we added or removed something to the prefetching queue, we would also make sure to add / remove that from the global tally. Once that is done, we saw almost 18% improvement in high write scenarios, because we weren&#x2019;t just busy counting how much stuff we have in memory to figure out if we can put things in memory. I can&#x2019;t emphasize enough how important it is that the work throughout was done using a profiler (in our case, the excellent dotTrace) because if dotTrace wouldn&#x2019;t have point a big finger at this line of code, we would have never have considered this to be problematic.</p>
        </article>
        <article id="article-3494">
            <a href="https://ayende.com/blog/169798/excerpts-from-the-ravendb-performance-team-report-dates-take-a-lot-of-time" target="_blank">
                <h2 class="title mb-6" id="article-3494">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 21, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">RavenDB uses a lot of dates, from the last modified metadata on a document to the timestamp of an index or when a query was started or&#x2026; you get the point, lots and lots of dates. Dates in RavenDB are usually formatted in the following manner:   2015-01-15T00:41:16.6616631 This is done using the following date time format:  yyyy&#x27;-&#x27;MM&#x27;-&#x27;dd&#x27;T&#x27;HH&#x27;:&#x27;mm&#x27;:&#x27;ss.fffffff This is pretty awesome. It generate readable dates that are lexicographically sorted. There is just one problem with that, this is really expensive to do. How expensive? Well, outputting 10 million dates using the following manner:  dateTime.ToString(Default.DateTimeFormatsToWrite, CultureInfo.InvariantCulture) This takes 13.3 seconds, or just about 750 dates per millisecond. The costs here are partly the allocations, but mostly it is about the fact that the format provider needs to first parse the format specifier, then do quite a bit of work to get it working. And DateTime itself isn&#x2019;t very cheap. The solution presented is ugly, but it works, and it is fast.  public unsafe static string GetDefaultRavenFormat(this DateTime dt, bool isUtc = false)&#xA;{&#xA;    string result = new string(&#x27;Z&#x27;, 27 &#x2B; (isUtc ? 1 : 0));&#xA;&#xA;    var ticks = dt.Ticks;&#xA;&#xA;    // n = number of days since 1/1/0001&#xA;    int n = (int)(ticks / TicksPerDay);&#xA;    // y400 = number of whole 400-year periods since 1/1/0001&#xA;    int y400 = n / DaysPer400Years;&#xA;    // n = day number within 400-year period&#xA;    n -= y400 * DaysPer400Years;&#xA;    // y100 = number of whole 100-year periods within 400-year period&#xA;    int y100 = n / DaysPer100Years;&#xA;    // Last 100-year period has an extra day, so decrement result if 4&#xA;    if (y100 == 4) y100 = 3;&#xA;    // n = day number within 100-year period&#xA;    n -= y100 * DaysPer100Years;&#xA;    // y4 = number of whole 4-year periods within 100-year period&#xA;    int y4 = n / DaysPer4Years;&#xA;    // n = day number within 4-year period&#xA;    n -= y4 * DaysPer4Years;&#xA;    // y1 = number of whole years within 4-year period&#xA;    int y1 = n / DaysPerYear;&#xA;    // Last year has an extra day, so decrement result if 4&#xA;    if (y1 == 4) y1 = 3;&#xA;    // If year was requested, compute and return it&#xA;    var year = y400 * 400 &#x2B; y100 * 100 &#x2B; y4 * 4 &#x2B; y1 &#x2B; 1;&#xA;&#xA;    // n = day number within year&#xA;    n -= y1 * DaysPerYear;&#xA;    // Leap year calculation looks different from IsLeapYear since y1, y4,&#xA;    // and y100 are relative to year 1, not year 0&#xA;    bool leapYear = y1 == 3 &amp;&amp; (y4 != 24 || y100 == 3);&#xA;    int[] days = leapYear ? DaysToMonth366 : DaysToMonth365;&#xA;    // All months have less than 32 days, so n &gt;&gt; 5 is a good conservative&#xA;    // estimate for the month&#xA;    int month = n &gt;&gt; 5 &#x2B; 1;&#xA;    // m = 1-based month number&#xA;    while (n &gt;= days[month]) month&#x2B;&#x2B;;&#xA;    // If month was requested, return it&#xA;&#xA;    // Return 1-based day-of-month&#xA;    var day = n - days[month - 1] &#x2B; 1;&#xA;&#xA;    fixed (char* chars = result)&#xA;    {&#xA;        var v = _fourDigits[year];&#xA;        chars[0] = v[0];&#xA;        chars[1] = v[1];&#xA;        chars[2] = v[2];&#xA;        chars[3] = v[3];&#xA;        chars[4] = &#x27;-&#x27;;&#xA;        v = _fourDigits[month];&#xA;        chars[5] = v[2];&#xA;        chars[5 &#x2B; 1] = v[3];&#xA;        chars[7] = &#x27;-&#x27;;&#xA;        v = _fourDigits[day];&#xA;        chars[8] = v[2];&#xA;        chars[8 &#x2B; 1] = v[3];&#xA;        chars[10] = &#x27;T&#x27;;&#xA;        v = _fourDigits[(ticks / TicksPerHour) % 24];&#xA;        chars[11] = v[2];&#xA;        chars[11 &#x2B; 1] = v[3];&#xA;        chars[13] = &#x27;:&#x27;;&#xA;        v = _fourDigits[(ticks / TicksPerMinute) % 60];&#xA;        chars[14] = v[2];&#xA;        chars[14 &#x2B; 1] = v[3];&#xA;        chars[16] = &#x27;:&#x27;;&#xA;        v = _fourDigits[(ticks / TicksPerSecond) % 60];&#xA;        chars[17] = v[2];&#xA;        chars[17 &#x2B; 1] = v[3];&#xA;        chars[19] = &#x27;.&#x27;;&#xA;&#xA;        long fraction = (ticks % 10000000);&#xA;        v = _fourDigits[fraction / 10000];&#xA;        chars[20] = v[1];&#xA;        chars[21] = v[2];&#xA;        chars[22] = v[3];&#xA;&#xA;        fraction = fraction % 10000;&#xA;&#xA;        v = _fourDigits[fraction];&#xA;        chars[23] = v[0];&#xA;        chars[24] = v[1];&#xA;        chars[25] = v[2];&#xA;        chars[26] = v[3];&#xA;    }&#xA;&#xA;    return result;&#xA;}&#xA;&#xA;We use the same general pattern that we used with etags as well, although here we are also doing a lot of work to figure out the right parts of the date. Note that we don&#x2019;t have any allocations, and we again use the notion of a lookup table to all the pre-computed 4 digits number. That allows us to process 10,000,000 dates in just over 2 seconds (2,061 ms, to be exact). Or roughly 4,850 dates per millisecond. In other words, we are about 15% of the speed of the original implementation.&#xA;This code is ugly, in fact, the last few posts has contained pretty much ugly code, that is hard to understand. But it is significantly faster than the alternative, and what is even more important, those pieces of code are actually being used in RavenDB&#x2019;s hot path. In other words, that means that we have actually seen significant performance improvement when introducing them to the codebase.</p>
        </article>
        <article id="article-3495">
            <a href="https://ayende.com/blog/169797/excerpts-from-the-ravendb-performance-team-report-etags-and-evil-code-part-ii" target="_blank">
                <h2 class="title mb-6" id="article-3495">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 20, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my previous post, I talked about how we improved the performance of Etag parsing from 5 etags/ms to 3,500 etags/ms. In this post, I want to talk about the exact opposite problem, how we take an Etag and turn it into a string. Here is the original code that we had:  public unsafe override string ToString()&#xA;{&#xA;    var sb = new StringBuilder(36);&#xA;    var buffer = stackalloc byte[8];&#xA;&#xA;    *((long*)buffer) = restarts;&#xA;&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[7]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[6]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[5]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[4]]);&#xA;    sb.Append(&#x27;-&#x27;);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[3]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[2]]);&#xA;    sb.Append(&#x27;-&#x27;);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[1]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[0]]);&#xA;    sb.Append(&#x27;-&#x27;);&#xA;&#xA;    *((long*)buffer) = changes;&#xA;&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[7]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[6]]);&#xA;    sb.Append(&#x27;-&#x27;);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[5]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[4]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[3]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[2]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[1]]);&#xA;    sb.Append(GenericUtil.ByteToHexAsStringLookup[buffer[0]]);&#xA;&#xA;    var etagAsString = sb.ToString();&#xA;    Debug.Assert(etagAsString.Length == 36); //prevent stupid bugs if something is refactored&#xA;&#xA;    return etagAsString;&#xA;}&#xA;&#xA;As you can see, we already optimized this a bit. It is using a string builder, it is using a lookup table to avoid costly byte to string. Note also that we use a stackalloc value, so there isn&#x2019;t an actual allocation, but we are able to copy the values once, and then just directly access it. Which is cheaper than trying to do a lot of bit shifting. &#xA;So far so good. Running on 10 million Etags, this completes in 8.9 seconds. That is good, this gives us 1,125 Etags per milliseconds. &#xA;Here is the optimized version:&#xA;&#xA;&#xA;public unsafe override string ToString()&#xA;{&#xA;    var results = new string(&#x27;-&#x27;, 36);&#xA;&#xA;    fixed (char* buf = results)&#xA;    {&#xA;        var buffer = stackalloc byte[8];&#xA;        *((long*)buffer) = restarts;&#xA;        var duget = GenericUtil.ByteToHexAsStringLookup[buffer[7]];&#xA;        buf[0] = duget[0];&#xA;        buf[1] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[6]];&#xA;        buf[2] = duget[0];&#xA;        buf[3] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[5]];&#xA;        buf[4] = duget[0];&#xA;        buf[5] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[4]];&#xA;        buf[6] = duget[0];&#xA;        buf[7] = duget[1];&#xA;        //buf[8] = &#x27;-&#x27;;&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[3]];&#xA;        buf[9] = duget[0];&#xA;        buf[10] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[2]];&#xA;        buf[11] = duget[0];&#xA;        buf[12] = duget[1];&#xA;        //buf[13] = &#x27;-&#x27;;&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[1]];&#xA;        buf[14] = duget[0];&#xA;        buf[15] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[0]];&#xA;        buf[16] = duget[0];&#xA;        buf[17] = duget[1];&#xA;        //buf[18] = &#x27;-&#x27;;&#xA;&#xA;        *((long*)buffer) = changes;&#xA;&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[7]];&#xA;        buf[19] = duget[0];&#xA;        buf[20] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[6]];&#xA;        buf[21] = duget[0];&#xA;        buf[22] = duget[1];&#xA;        //buf[23] = &#x27;-&#x27;;&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[5]];&#xA;        buf[24] = duget[0];&#xA;        buf[25] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[4]];&#xA;        buf[26] = duget[0];&#xA;        buf[27] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[3]];&#xA;        buf[28] = duget[0];&#xA;        buf[29] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[2]];&#xA;        buf[30] = duget[0];&#xA;        buf[31] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[1]];&#xA;        buf[32] = duget[0];&#xA;        buf[33] = duget[1];&#xA;        duget = GenericUtil.ByteToHexAsStringLookup[buffer[0]];&#xA;        buf[34] = duget[0];&#xA;        buf[35] = duget[1];&#xA;&#xA;        return results;&#xA;    }&#xA;}&#xA;&#xA;Note that here we don&#x2019;t bother with a string builder, we directly manipulate the string. And we still use all the other tricks (the lookup table, the no allocation, the works). This code managed to get to 5.5 seconds for 10,000,000 etags, or roughly 1,800 etags per millisecond. Roughly 37.5% improvement to a pretty important piece of code.&#xA;Do you see anything else that we can do to reduce the cost even further?</p>
        </article>
        <article id="article-3496">
            <a href="https://ayende.com/blog/169796/excerpts-from-the-ravendb-performance-team-report-etags-and-evil-code-part-i" target="_blank">
                <h2 class="title mb-6" id="article-3496">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 19, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">As part of the performance work we have been doing, we focused on the Etag class we use as a performance hot spot. For this post, I&#x2019;m going to talk about Etag.Parse(string) and what we did to improve its performance.&#xA;&#xA;&#x9;Etag is a core type in RavenDB, it is how we represent changes in the database, and we deal with it a lot. As such, it turned up as a performance hot spot in our profiling. This post is based mostly around Maxim&#x2019;s work to improve the overall performance.&#xA;&#xA;&#x9;One of the things that we do with Etag is to take a string and turn that into an instance of an Etag. An Etag looks just like a Guid, but its structure has meaning that we care about. Here is what a typical Etag looks like:&#xA;&#xA;&#x9;&#xA;&#x9;&#x9;01000000-0000-0005-0000-00000000012C&#xA;&#xA;&#xA;&#x9;We send them over the wire as strings for a lot of purposes. Here is the initial code that we used for parsing Etags:&#xA;&#xA;&#x9;&#xA;&#x9;&#x9;public static Etag Parse2(string str)&#xA;{&#xA;    if (string.IsNullOrEmpty(str))&#xA;        throw new ArgumentException(&quot;str cannot be empty or null&quot;);&#xA;    if (str.Length != 36)&#xA;        throw new ArgumentException(string.Format(&quot;str must be 36 characters (Etag::Parse is {0})&quot;, str));&#xA;&#xA;    var buffer = new byte[16]&#xA;    {&#xA;        byte.Parse(str.Substring(16, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(14, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(11, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(9, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(34, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(32, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(30, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(28, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(26, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(24, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(21, 2), NumberStyles.HexNumber),&#xA;        byte.Parse(str.Substring(19, 2), NumberStyles.HexNumber)&#xA;    };&#xA;&#xA;    return new Etag&#xA;    {&#xA;        restarts = BitConverter.ToInt64(buffer, 0),&#xA;        changes = BitConverter.ToInt64(buffer, 8)&#xA;    };&#xA;}&#xA;&#xA;&#x9;&#xA;&#xA;&#xA;&#x9;You can note several things here. First, we are being kinda funky here with the order of parsing. This is because we read the string in Big Endian format, to allow direct comparisons of the bytes strings.&#xA;&#xA;&#x9;The other issue is the shear number of allocations and calls we are making. Because this is such a small code base, we created 10,000 etags and parsed them a million times .That took 17.3 seconds. For a throughput of roughly 5 Etags per millisecond.&#xA;&#xA;&#x9;Then we sat down and re-wrote it using a lot of somewhat nasty tricks.&#xA;&#xA;&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;private readonly static int[] _asciisOfHexToNum = CreateHexCharsToNumsTable();&#xA;&#xA;private static int[] CreateHexCharsToNumsTable()&#xA;{&#xA;    var c = new int[&#x27;z&#x27; &#x2B; 1];&#xA;    for (var i = &#x27;0&#x27;; i &lt;= &#x27;9&#x27;; i&#x2B;&#x2B;)&#xA;    {&#xA;        c[i] = (char)(i - &#x27;0&#x27;);&#xA;    }&#xA;    for (var i = &#x27;A&#x27;; i &lt;= &#x27;Z&#x27;; i&#x2B;&#x2B;)&#xA;    {&#xA;        c[i] = (char)((i - &#x27;A&#x27;) &#x2B; 10);&#xA;    }&#xA;    for (var i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; i&#x2B;&#x2B;)&#xA;    {&#xA;        c[i] = (char)((i - &#x27;a&#x27;) &#x2B; 10);&#xA;    }&#xA;&#xA;    return c;&#xA;}&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;public unsafe static Etag Parse(string str)&#xA;{&#xA;    if (str == null || str.Length != 36)&#xA;        throw new ArgumentException(&quot;str cannot be empty or null&quot;);&#xA;&#xA;    fixed (char* input = str)&#xA;    {&#xA;        var etag = new Etag();&#xA;        int fst = ((byte)(_asciisOfHexToNum[input[0]] * 16 &#x2B; _asciisOfHexToNum[input[1]])) &lt;&lt; 24 |&#xA;            ((byte)(_asciisOfHexToNum[input[2]] * 16 &#x2B; _asciisOfHexToNum[input[3]])) &lt;&lt; 16 |&#xA;            ((byte)(_asciisOfHexToNum[input[4]] * 16 &#x2B; _asciisOfHexToNum[input[5]])) &lt;&lt; 8 |&#xA;            (byte)(_asciisOfHexToNum[input[6]] * 16 &#x2B; _asciisOfHexToNum[input[7]]);&#xA;        int snd = ((byte)(_asciisOfHexToNum[input[9]] * 16 &#x2B; _asciisOfHexToNum[input[10]])) &lt;&lt; 24 |&#xA;            ((byte)(_asciisOfHexToNum[input[11]] * 16 &#x2B; _asciisOfHexToNum[input[12]])) &lt;&lt; 16 |&#xA;            ((byte)(_asciisOfHexToNum[input[14]] * 16 &#x2B; _asciisOfHexToNum[input[15]])) &lt;&lt; 8 |&#xA;            ((byte)(_asciisOfHexToNum[input[16]] * 16 &#x2B; _asciisOfHexToNum[input[17]]));&#xA;        etag.restarts = (uint)snd | ((long)fst &lt;&lt; 32);&#xA;&#xA;&#xA;        fst = ((byte)(_asciisOfHexToNum[input[19]] * 16 &#x2B; _asciisOfHexToNum[input[20]])) &lt;&lt; 24 |&#xA;            ((byte)(_asciisOfHexToNum[input[21]] * 16 &#x2B; _asciisOfHexToNum[input[22]])) &lt;&lt; 16 |&#xA;            ((byte)(_asciisOfHexToNum[input[24]] * 16 &#x2B; _asciisOfHexToNum[input[25]])) &lt;&lt; 8 |&#xA;            ((byte)(_asciisOfHexToNum[input[26]] * 16 &#x2B; _asciisOfHexToNum[input[27]]));&#xA;        snd = ((byte)(_asciisOfHexToNum[input[28]] * 16 &#x2B; _asciisOfHexToNum[input[29]])) &lt;&lt; 24 |&#xA;            ((byte)(_asciisOfHexToNum[input[30]] * 16 &#x2B; _asciisOfHexToNum[input[31]])) &lt;&lt; 16 |&#xA;            ((byte)(_asciisOfHexToNum[input[32]] * 16 &#x2B; _asciisOfHexToNum[input[33]])) &lt;&lt; 8 |&#xA;            ((byte)(_asciisOfHexToNum[input[34]] * 16 &#x2B; _asciisOfHexToNum[input[35]]));&#xA;        etag.changes = (uint)snd | ((long)fst &lt;&lt; 32);&#xA;        return etag;&#xA;    }&#xA;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#xA;&#xA;&#xA;&#x9;Here is what we did. We created a translation table, so every possible byte is pre calculated. That means that for the cost of actually parsing the string is basically doing a lookup into an array, which is constant type. There are no allocations, nor is there anything expensive going on. On the same machine the previous code took 17.3 to run, this code can process a million Etags in just 287 milliseconds. Or close to 3,500 Etag per milliseconds.&#xA;&#xA;&#x9;I leave the rate of improvement as an exercise for the reader. Also, can you think of any way in which we can improve this code even further? We weren&#x2019;t able to figure out anything, but you never knows.</p>
        </article>
        <article id="article-3497">
            <a href="https://enterprisecraftsmanship.com/posts/how-to-increase-your-value-as-developer/" target="_blank">
                <h2 class="title mb-6" id="article-3497">How to increase your value as a developer</h2>
            </a>
            <p class="mb-2">by Vladimir Khorikov</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 17, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Did you think about what traits make developers great? Which one is the most valuable for the companies they are working for?&#xA;&#xA;&#xA;While there might be quite a few of them, I believe there&#x2019;s one that employers value the most. I also believe getting that characteristic can drastically increase your value as a software developer.</p>
        </article>
        <article id="article-3498">
            <a href="https://ayende.com/blog/169794/excerpts-from-the-ravendb-performance-team-report-voron-vs-esent" target="_blank">
                <h2 class="title mb-6" id="article-3498">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 16, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Another thing that turned up in the performance work was the Esent vs. Voron issue. We keep testing everything on both, and trying to see which one can outdo the other, fix a hotspot, then try again. When we run the YCSB benchmark we also compared between Esent vs. Voron as storage for our databases and we found that Voron was very good in read operation while Esent was slightly better in write operation. During the YCSB tests we found out one of the reason why Voron was a bit slower than Esent for writing, it was consuming 4 times the expected disk-space. The reason for this high disk-space consumption was that the benchmark by default generates documents of exactly 1KB, with meta-data the actual size was 1.1KB. Voron internal implementation uses a B&#x2B; tree where the leafs are 4KB in size, 1KB was the threshold in which we decide not to save data to the leaf but to reference on it and save it on a new page. We ended up creating a new 4KB page to hold 1.1KB documents for each document that we saved. The benchmark actually hit the worst case scenario for our implementation, and caused us to use 4 times more disk space and write 4 times more data than we needed.&#xA0; Changing this threshold reduce the disk-space consumption to the expected size, and gave Voron a nice boost.  We are also testing our software on a wide variety of systems, and with Voron specifically with run into an annoying issue. Voron is a write ahead log system, and we are very careful to write to the log in a very speedy manner. This is one of the ways in which we are getting really awesome speed for Voron. But when running on slow I/O system, and putting a lot of load on Voron, we started to see very large stalls after a while. Tracing the issue took a while, but eventually we figured out what was going on. Writing to the log is all well and good, but we need to also send the data to the actual data file at some point. The way Voron does it, it batch a whole bunch of work, write it to the data file, then sync the data file to make sure it is actually persisted on disk. Usually, that isn&#x2019;t really an issue. But on slow I/O, and especially under load, you get results like this:  Start to sync data file (8:59:52 AM). Written but unsynced data size 309 MBFlushViewOfFile duration 00:00:13.3482163. FlushFileBuffers duration: 00:00:00.2800050.End of data pager sync (9:00:05 AM). Duration: 00:00:13.7042229 Note that this is random write, because we may be doing writes to any part of the file, but that is still way too long. What was worse, and the reason we actually care is that we were doing that while holding the transaction lock. We were able to re-design that part so even under slow I/O, we can take the lock for a very short amount of time, update the in memory data structure and then release the lock and spend some quality time gazing at our navel in peace while the I/O proceeded in its own pace, but now without blocking anyone else.</p>
        </article>
        <article id="article-3499">
            <a href="https://ayende.com/blog/169793/excerpts-from-the-ravendb-performance-team-report-routing" target="_blank">
                <h2 class="title mb-6" id="article-3499">Excerpts from the RavenDB Performance team report</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 15, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We have been quite busy lately doing all sort of chores. The kind of small features that you don&#x2019;t really notice, but make a lot of difference over time. One of the ways that we did that was to assign a team for the sole purpose of improving the performance of RavenDB. This is done by writing a lot of stress tests, running under profilers and in general doing very evil things to the code to get it to work much faster. The following is part of the results that we have found so far, written mostly by Tal.&#xA;&#xA;&#x9;We decided to use Yahoo! Cloud Service Benchmark (AKA YCSB) for that purpose, while YCSB is great in creating stress on the target database servers it does not offer complex interface to stress complex scenario, and seems to be targeting key value solutions. YCSB allows you to basically control some parameters to the workload engine and implementation of five basic operation: Insert, Update, Read, Scan and Delete of a single record, in a single table/collection.&#xA;&#xA;&#x9;&#xA;&#x9;&#x9;Note: I think that this is because it focused (at least initially) primarily on the Big Table type of NoSQL solutions.&#xA;&#xA;&#xA;&#x9;This very thin interface allows us to mainly stress the PUT/GET document. The first thing we found is that running with indexes actually slowed us down since we are &#x201C;wasting&#x201D; precious CPU time on indexing and not doing any querying, that is enough to show you the true face of benchmark miracle, since where have you ever seen a database that you didn&#x2019;t wish to run a query upon?&#xA0; But this is a topic for another post&#x2026; lets go back to performance.&#xA;&#xA;&#x9;The second thing we found was a hotspot in the route data retrieval&#xA0; mechanism of the Web API/ While using Web API routing seems to work like magic, when you get to have approximately four hundred endpoints you will start suffering from performance issues retrieving route data. In our case we were spending about 1ms per http request just to retrieve the route data for the request, that may not seems like much but for 1,500 request that took 5 seconds to execute this took 1.5 seconds just for route data retrieval. Please, do not try to extrapolate the throughput of RavenDB from those numbers since we ran this test on a weak machine also under a profiling tool that slow it down significantly.&#xA;&#xA;&#x9;&#xA;&#x9;&#x9;Note: Effectively, for our use case, we were doing an O(400) operation on every request, just to find what code we needed to run to handle this request.&#xA;&#xA;&#xA;&#x9;We decided to cache the routes for each request but just straight forward caching wouldn&#x2019;t really help in our case. The problem is that we have many unique requests that would fill the cache and then wouldn&#x2019;t actually be of use.&#xA;&#xA;&#x9;Our major issue was requests that had a route that looked like so databases/{databaseName}/docs/{*docId}. While we we do want to cache routes such as: databases/{databaseName}/stats. The problem is that we have both types of routes and they are used quite often so we ended up with a greatest common route cache system. That means that /databases/Northwind/docs/Orders/order1 and /databases/Northwind/docs/Orders/order2 will go into the same bucket that is /databases/Northwind/docs.&#xA;&#xA;&#x9;In that way, we would still have to do some work per request, but now we don&#x2019;t have to go through all four hundred routes we have to find the relevant routes.&#xA;&#xA;&#x9;What was the performance impact you wonder? We took off 90% of get route data time that is spending 0.15 seconds instead of 1.5 seconds for those 1,500 requests, reducing the overall runtime to 3.65 seconds, that is 27% less run time.&#xA;&#xA;&#x9;&#xA;&#x9;&#x9;Note: Again, don&#x2019;t pay attention to the actual times, it is the rate of improvement that we are looking at.&#xA;&#xA;&#xA;&#x9;As an aside, another performance improvement that we made with regards to routing was routing discovery. During startup, we scan the RavenDB assembly for controllers, and register the routes. That is all great, as long as you are doing that once. And indeed, in most production scenarios, you&#x2019;ll only do that once per server start. That means that the few dozen milliseconds that you spend on this aren&#x2019;t really worth thinking about. But as it turned out, there was one key scenario that was impacted by this. Tests! In tests, you start and stop RavenDB per test, and reducing this cost is very important to ensuring a pleasant experience. We were able to also optimize the route discovery process, and we were actually able to reduce our startup time from cold boot to below what we had in 2.5.</p>
        </article>
        <article id="article-3500">
            <a href="https://ayende.com/blog/169761/ravendb-indexing-performance-timeline" target="_blank">
                <h2 class="title mb-6" id="article-3500">RavenDB&#x2013;Indexing performance timeline</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 13, 2015
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We get people asking us about the details of RavenDB indexes, why a certain index is busy, what is costly, etc. This is a pretty common set of questions, and while we were always able to give the customer a good answer, I was never truly happy with that. A lot of that was about understanding the system to a very deep level and being able to read fairly obscure to an outsider. Like most things that aren&#x2019;t obvious and easy to use, that bugged me, deeply. Therefor, we spent a few weeks adding internal metrics and exposing everything in a nice and easy fashion. Let me show you the details from one of our production databases:  The Y axis is for different indexes. On the Y axis, you have time. Note that the top part is for map operations, and the bottom part is for reduce operations, and that they are running in parallel. You can also visually see that those the map &amp; reduce are actually running in parallel.  What is even better, you can visually see each individual indexing batch, let us focus on the long indexing batch in the middle:  As you can see, we are indexing 512 documents, but it took us a really long time to index them, why is that? We can see that the reason that this batch took so long is that the Orders/Stats and Products/Stats index were very long. Clicking on them, we can see:  &#xA0;    The Orders/Stats index accepted a 105 documents, and outputted 1,372 map values. And the costly part of this index was to actually commit those (along with the Products/Stats, which also output a similar amount) to the map storage.  Another slow index is exposed here:  In this case, we have an index that is big enough that we need to flush it to disk from RAM. That explains things. I&#x2019;m really excited about this feature.</p>
        </article>
        <div class="button flex justify-between">
            <a href="349.html"><span class="back arrow"></span></a>

            <a href="351.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>