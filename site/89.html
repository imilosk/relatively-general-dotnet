
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 89 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-881">
            <a href="https://ardalis.com/design-patterns-overview/" target="_blank">
                <h2 class="title mb-6" id="article-881">Design Patterns Overview</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 12, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Design patterns provide reusable approaches to common problems and allow for higher level discussions of software design. Learn the basics&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-882">
            <a href="https://andrewlock.net/exploring-dotnet-6-part-5-supporting-ef-core-tools-with-webapplicationbuilder/" target="_blank">
                <h2 class="title mb-6" id="article-882">Supporting EF Core migrations with WebApplicationBuilder</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 12, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Exploring .NET 6 - Part 5</p>
        </article>
        <article id="article-883">
            <a href="https://ayende.com/blog/194945-A/performance-architecture-talk" target="_blank">
                <h2 class="title mb-6" id="article-883">Performance architecture talk</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 11, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I spoke at the Donetos conference about how to design your system for high performance, using RavenDB&#x2019;s story as the backdrop. I think it went great.</p>
        </article>
        <article id="article-884">
            <a href="https://www.meziantou.net/downloading-a-ssl-certificate-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-884">Downloading a SSL/TLS certificate in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 11, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I recently needed to set up an alert when a certificate expires soon or when it uses an insecure signature algorithm. The first step is to get the certificate. In .NET you can use the SslStream class to do the hard job. Then, you can set up a recurring task using Azure Pipelines or GitHub Actions t</p>
        </article>
        <article id="article-885">
            <a href="https://ayende.com/blog/194913-A/a-pki-less-secure-communication-channel-error-handling-at-the-protocol-level" target="_blank">
                <h2 class="title mb-6" id="article-885">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 08, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">One of the things that I find myself paying a lot of attention to is the error handling portion of writing software. This is one of the cases where I&#x2019;m sounding puffy even to my own ears, but from over two decades of experience, I can tell you that getting error handling right is one of the most important things that you can do for&#xA0; your systems. I spend a lot of time on getting errors right. That doesn&#x2019;t just mean error handling, but error reporting and giving enough context that the other side can figure out what we need to do.In a secured protocol, that is a bit harder, because we need to safeguard ourselves from eavesdroppers, but I spent significant amounts of time thinking on how to do this properly. Here are the ground rules I set out for myself:The most common scenario is client failing to connect to the server.We need to properly report underlying issues (such as TCP errors) while also exposing any protocol level issues.There is an error during the handshake and errors during processing of application messages. Both scenarios should be handled.We already saw in the previous post that there is the concept of the data messages and alert messages (of which there can only be one). Let&#x2019;s look how that works for the handshake scenario. I&#x2019;m focusing on the server side here, because I&#x2019;m assuming that this one is more likely to be opaque. A client side issue can be much more easily troubleshooted. And the issue isn&#x2019;t error handling inside the code, it is distributed error handling. In other words, if the server has an issue, how it reports to the client?The other side, where the client wants to report an issue to the server, is of no interest to us. From our perspective, a client can cut off at any point (TCP connection broke, etc), so there is no meaning to trying to do that gracefully or give more data to the server. What would the server do with that? Here is the server portion of establishing a secured connection:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn serverConnection(allocator: *std.mem.Allocator, stream: std.net.Stream, server_keys: crypto.KeyPair) !AuthenticatedConnection {&#xA;        &#xA;        &#xA;          &#xA;              errdefer stream.close();&#xA;        &#xA;        &#xA;          &#xA;              var handshake = protocol.Server.initialize(server_keys);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var reader = stream.reader();&#xA;        &#xA;        &#xA;          &#xA;              var hello: protocol.HelloMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;hello));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try hello.route(&amp;handshake); // no routing supported here&#xA;        &#xA;        &#xA;          &#xA;              var challenge = try hello.challenge(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = stream.writer();&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;challenge));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var resp: protocol.ChallengeResponse = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;resp));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var session = try handshake.generateKey();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var rc: AuthenticatedConnection = undefined;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;rc.pub_key, &amp;handshake.client.long_term_public_key);&#xA;        &#xA;        &#xA;          &#xA;              rc.stream = try crypto.NetworkStream.init(allocator, stream, session);&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;              try resp.completeAuth(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          serverConnection.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I&#x2019;m using Zig to write this code and you can see any potential error in the process marked with a try keyword. Looking at the code, everything up to line 24 (the completeAuth() call) is mechanically sending and receiving data. Any error up to that point is something that is likely network related (so the connection is broken). You can see that the protocol call challenge() can fail as does the call to generateKey() &#x2013; in both cases, there isn&#x2019;t much that I can do about it. If the generateKey() call fails, there is no shared secret (for that matter, it doesn&#x2019;t look like that can fail, but we&#x2019;ll ignore that). As for the challenge() call, the only way that can fail is if the server has failed to encrypt its challenge properly. That is not something that the client can do much about. And anyway, there isn&#x2019;t a failing codepath there either.In other words, aside from network issues, which will break the connection (meaning we cannot send the error to the client anyway), we have to wait until we process the challenge from the client to have our first viable failure. In the code above, I&#x201D;m just calling try, which means that we&#x2019;ll fail the connection attempt, close the socket and basically just hang up on the client. That isn&#x2019;t nice to do at all. Here is what I replaced line 24 with:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          resp.completeAuth(&amp;handshake) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;              // we use the secure channel to send an error to the other side (will also abort the connection there)&#xA;        &#xA;        &#xA;          &#xA;              var msg = &quot;Failed to validate challenge response&quot;.*;&#xA;        &#xA;        &#xA;          &#xA;              rc.stream.send_alert(crypto.AlertTypes.BadChallengeResponse, &amp;msg) catch {&#xA;        &#xA;        &#xA;          &#xA;                  // there is nothing we can do here, ignoring the error&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              return e; // implicitly close the connection&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          serverConnection.err-handling.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;What is going on here is that by the time that I got the challenge response from the client, I have enough information to send derive the shared key. I can use that to send an alert to the other side, letting them know what the failure was. A client will complete the challenge, and if there is a handshake failure, we proceed to fail gracefully with meaning error.But there is another point to this protocol, an alert message doesn&#x2019;t have to show up only in the hand&#xA0; shake part. Consider a long running response that run into an error. Here is how you&#x2019;ll usually handle that in TCP / HTTP scenarios, assume that we are streaming data to the client and suddenly run into an issue:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            &quot;Databases&quot;: [&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                &quot;Name&quot;: &quot;Northwind&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Disabled&quot;: false,&#xA;        &#xA;        &#xA;          &#xA;                &quot;TotalSize&quot;: {&#xA;        &#xA;        &#xA;          &#xA;                  &quot;HumaneSize&quot;: &quot;327.81 MBytes&quot;,&#xA;        &#xA;        &#xA;          &#xA;                  &quot;SizeInBytes&quot;: 343736320&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              },&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                &quot;Name&quot;: &quot;Darksand&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Disabled&quot;: false,&#xA;        &#xA;        &#xA;          &#xA;                &quot;TotalSize&quot;: {&#xA;        &#xA;        &#xA;          &#xA;          Unhandled Exception: System.UnauthorizedAccessException: Access to the path &#x27;/data/darksand&#x27; is denied. ---&gt; System.IO.IOException: Permission denied&#xA;        &#xA;        &#xA;          &#xA;             --- End of inner exception stack trace ---&#xA;        &#xA;        &#xA;          &#xA;             at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)&#xA;        &#xA;        &#xA;          &#xA;             at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.Linux.LinuxLiveDataReader.OpenMemFile()&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.Linux.LinuxLiveDataReader.ReadMemory(UInt64 address, IntPtr buffer, Int32 bytesRequested, Int32&amp; bytesRead)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DacInterface.DacDataTargetWrapper.ReadVirtual(IntPtr self, UInt64 address, IntPtr buffer, Int32 bytesRequested, Int32&amp; bytesRead)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DacLibrary..ctor(DataTarget dataTarget, String dacDll)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DataTarget.ConstructRuntime(ClrInfo clrInfo, String dac)&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          response.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;How do you send an error midstream? Well, you don&#x2019;t. If you are lucky, you&#x2019;ll have the error output and have some way to get the full message and manually inspect it. That is a distressingly common issue, by the way, and a huge problem for proper error reporting with long running responses. With the alert model, we have effectively multiple channels in the same TCP stream that we can utilize to send a clear and independent error for the client. Much nicer overall, even if I say so myself.And it just occurred to me that this mimics quite nicely the same approach that Zig itself uses for error handling .</p>
        </article>
        <article id="article-886">
            <a href="https://ayende.com/blog/194882-A/a-pki-less-secure-communication-channel-implementing-the-record-stream" target="_blank">
                <h2 class="title mb-6" id="article-886">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 07, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We now have managed to do a proper handshake and both client and server has a shared key. The client has also verified that the server is who they thought it should be, the server knows who the client is and can lookup whatever authorization such a client is ought to get. The next step we have to take is actually starting sending data over the wire. I mentioned earlier that while conceptually, we are dealing with a stream of data, in practice, we have to send the data as independent records. That is done so we can properly verify that they weren&#x2019;t meddled with along the way (either via cosmic radiation or malicious intent).We&#x2019;ll start with the writing data, which is simple. We initiate the write side of the connection using CryptoWriter:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: *std.mem.Allocator, stream: TStream, secret_keys: sodium.SecretKeys) !CryptoWriter {&#xA;        &#xA;        &#xA;          &#xA;              var buf = try allocator.alloc(u8, RecordBufferSize * 2);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var self: CryptoWriter = .{&#xA;        &#xA;        &#xA;          &#xA;                  .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = buf,&#xA;        &#xA;        &#xA;          &#xA;                  .writer = stream.writer(),&#xA;        &#xA;        &#xA;          &#xA;                  .padder = null,&#xA;        &#xA;        &#xA;          &#xA;                  .stream = stream,&#xA;        &#xA;        &#xA;          &#xA;                  .state = undefined,&#xA;        &#xA;        &#xA;          &#xA;                  .alert_raised = false,&#xA;        &#xA;        &#xA;          &#xA;                  .buffered = 0,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_init_push(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;secret_keys.transmit[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnableToPushStreamHeader;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.writer.writeAll(self.buffer[0..c.crypto_secretstream_xchacha20poly1305_HEADERBYTES]);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We allocate a buffer that is 32KB in size (16KB x 2). The record size we selected is 16KB. Unlike TLS, this is an inclusive size, so the entire thing must fit in 16KB. We need to allocate 32KB because the API we use does not support in place encryption. You&#x2019;ll note that we reserved some space in the header (5 bytes, to be exact) for our own needs. You&#x2019;ll note that we initialize the stream and send the stream header to the other side in here, that is the only reference for cryptography in the initialization. The actual writing isn&#x2019;t really that interesting, we are pushing all the data to the buffer, until we run out of space, then we call flush(). I&#x2019;ve written this code in plenty of languages, and it is pretty straightforward, if tedious.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn write(self: *CryptoWriter, buffer: []const u8) !usize {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_raised) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AlertAlreadyRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var buf = buffer;&#xA;        &#xA;        &#xA;          &#xA;              var total_size: usize = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var size = std.math.min(buf.len, RecordBufferSize - self.buffered);&#xA;        &#xA;        &#xA;          &#xA;                  total_size &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, self.buffer[self.buffered..RecordBufferSize], buf[0..size]);&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;                  buf = buf[size..];&#xA;        &#xA;        &#xA;          &#xA;                  if (self.buffered == RecordBufferSize) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.flush(RecordTypes.Data);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (buf.len == 0)&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return total_size;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.write.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There isn&#x2019;t anything happening here, until we call to flush(RecordTypes.Data) &#x2013; that is an indication to the other side that this is application data, rather than some protocol level message. The flush() method is where things gets really interesting.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn flush(self: *CryptoWriter, rec_type: RecordTypes) !void {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_raised) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AlertAlreadyRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.buffered &gt; MaxPlainTextSize) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.PlainTextRecordSizeToLarge; // should never happen&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, self.buffer[2..4], @intCast(u16, self.buffered - @sizeOf(u16)), .Little);&#xA;        &#xA;        &#xA;          &#xA;              self.buffer[4] = @enumToInt(rec_type);&#xA;        &#xA;        &#xA;          &#xA;              if (self.padder) |padder| {&#xA;        &#xA;        &#xA;          &#xA;                  var pad_len = padder(self, self.buffered);&#xA;        &#xA;        &#xA;          &#xA;                  if (pad_len &#x2B; self.buffered &gt; MaxPlainTextSize)&#xA;        &#xA;        &#xA;          &#xA;                      return error.InvalidPaddingLengthProvided;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.set(u8, self.buffer[self.buffered..(self.buffered &#x2B; pad_len)], 0);&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered &#x2B;= pad_len;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var len: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              var encrypted = self.buffer[RecordBufferSize..];&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_push(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;encrypted[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;len,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered - @sizeOf(u16),&#xA;        &#xA;        &#xA;          &#xA;                  null,&#xA;        &#xA;        &#xA;          &#xA;                  0,&#xA;        &#xA;        &#xA;          &#xA;                  0,&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnableToPushEncryptedRecord;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (len &gt; RecordBufferSize - @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.EncryptedRecordSizeTooBig; // should never happen&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, encrypted[0..2], @intCast(u16, len &#x2B; @sizeOf(u16)), .Little);&#xA;        &#xA;        &#xA;          &#xA;              try self.writer.writeAll(encrypted[0 .. len &#x2B; @sizeOf(u16)]);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter,flush.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is a lot of code here, I know. Let&#x2019;s see if I can take it in all, there are some preconditions that should be fairly obvious, then we write the size of the plain text value as well as the record type to the header (that part of the header will be encrypted, mind). The next step is interesting, we invoke a callback to get an answer about how much padding we should use. There is a lot of information about padding. In general, just looking at the size of the data can tell you about what is going on, even if there is nothing else you can figure out. If you know that the &#x201C;Attack At Dawn&#x201D;&#xA0; is 14 chars long, and with the encryption overhead that turns to a 37 bytes message, that along can tell you much. Assume that you can&#x2019;t figure out the contents, but can sniff the sizes. That can be a problem. There are certain attacks that rely on leaking the size of messages to work, the BREACH attack, for example, relies on being able to send text that would collide with secret pieces of the message. Analyzing the size of the data that is sent will tell us when we managed to find a match (because the size will be reduced). To solve that, you can define a padding policy. For example, all messages are always exactly 16KB in size, and you&#x2019;ll send an empty message every second if there is no organic traffic. Alternatively, you may select to randomize the message size (to further confuse things). At any rate, this is a pretty complex topic,and not something that I wanted to get too much into. Being able to let the user decide gives me both worlds. This is a match to SSL_CTX_set_record_padding_callback() on OpenSSL.The rest is just calling to libsodium to do the actual encryption, setting the encrypted envelope size and sending it to the other side. Note that we use the other half of the buffer here to store the encrypted portion of the data. In addition to sending application data, we can send alerts to the other side. That is an protocol level error message. I&#x2019;ll actually have a separate post to talk about error handling, but for now, let&#x2019;s see how sending an alert looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn send_alert(self: *CryptoWriter, alert_type: AlertTypes, msg: []u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              defer {&#xA;        &#xA;        &#xA;          &#xA;                  self.alert_raised = true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (msg.len &#x2B; @sizeOf(AlertTypes) &#x2B; @sizeOf(u16) &gt; MaxPlainTextSize) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.PlainTextRecordSizeToLarge;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, self.buffer[(HeaderSize &#x2B; @sizeOf(AlertTypes))..], msg);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, self.buffer[HeaderSize .. HeaderSize &#x2B; @sizeOf(u16)], @enumToInt(alert_type), .Little);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize &#x2B; @sizeOf(AlertTypes) &#x2B; msg.len; // we discard everything else&#xA;        &#xA;        &#xA;          &#xA;              try self.flush(RecordTypes.Alert);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.alert.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Basically, we overwrite whatever there is on the buffer, and we flush it immediately to the other side. We also set the alert_raised flag, which will prevent any further usage of the stream. Once an error was sent, we are done. We aren&#x2019;t closing the stream because that is the job for the calling code, which will get an error and close us during normal cleanup procedures.The reading process is a bit more involved, on the other hand. We start by mirroring the write, pulling the header from the network and initializing the stream:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: *std.mem.Allocator, source: TStream.Reader, secret_keys: sodium.SecretKeys) !CryptoReader {&#xA;        &#xA;        &#xA;          &#xA;              var buf = try allocator.alloc(u8, RecordBufferSize * 2);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;              var self: CryptoReader = .{&#xA;        &#xA;        &#xA;          &#xA;                  .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  .reader = source,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = buf,&#xA;        &#xA;        &#xA;          &#xA;                  .incoming = &amp;[0]u8{},&#xA;        &#xA;        &#xA;          &#xA;                  .incoming_plain_text = &amp;[0]u8{},&#xA;        &#xA;        &#xA;          &#xA;                  .state = undefined,&#xA;        &#xA;        &#xA;          &#xA;                  .alert_code = null,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.reader.readNoEof(self.buffer[0..c.crypto_secretstream_xchacha20poly1305_HEADERBYTES]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_init_pull(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;secret_keys.recieve[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.FailedToInitCryptoStream;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The real fun starts when we need to actually read things, let&#x2019;s take a look at the code and then I&#x2019;ll explain it in details:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn read(self: *CryptoReader, buffer: []u8) !usize {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_code) |_| {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AnAlertWasRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.incoming_plain_text.len &gt; 0) { // read from buffer&#xA;        &#xA;        &#xA;          &#xA;                  return self.read_buffer(buffer);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  while (self.incoming.len &lt; @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.read_from_network();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var env_len = std.mem.readInt(u16, self.incoming[0..2], .Little);&#xA;        &#xA;        &#xA;          &#xA;                  if (env_len == 0 or env_len &gt; RecordBufferSize) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.InvalidCryptoEnvelopeSize;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  while (env_len &gt; self.incoming.len) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.read_from_network(); // read enough bytes from network&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming_plain_text = self.buffer[RecordBufferSize..];&#xA;        &#xA;        &#xA;          &#xA;                  var len: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;                  if (c.crypto_secretstream_xchacha20poly1305_pull(&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.incoming_plain_text[0],&#xA;        &#xA;        &#xA;          &#xA;                      &amp;len,&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.incoming[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                      env_len - @sizeOf(u16),&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.FailedToDecryptRecord;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, self.incoming, self.incoming[env_len..]);&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming = self.incoming[env_len..];&#xA;        &#xA;        &#xA;          &#xA;                  if (len &lt; @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.DecryptedRecordIsTooSmall;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var plain_txt_len = std.mem.readInt(u16, self.incoming_plain_text[0..2], .Little);&#xA;        &#xA;        &#xA;          &#xA;                  if (plain_txt_len == 0) {&#xA;        &#xA;        &#xA;          &#xA;                      continue; // allowed to have empty record&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var record_type = @intToEnum(RecordTypes, self.incoming_plain_text[@sizeOf(u16)]);&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming_plain_text = self.incoming_plain_text[@sizeOf(u16) &#x2B; @sizeOf(u8) .. plain_txt_len];&#xA;        &#xA;        &#xA;          &#xA;                  if (record_type == .Alert) {&#xA;        &#xA;        &#xA;          &#xA;                      self.alert_code = @intToEnum(AlertTypes, std.mem.readInt(u16, self.incoming_plain_text[0..@sizeOf(u16)], .Little));&#xA;        &#xA;        &#xA;          &#xA;                      self.incoming_plain_text = self.incoming_plain_text[@sizeOf(u16)..];&#xA;        &#xA;        &#xA;          &#xA;                      return error.AnAlertWasRaised;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return self.read_buffer(buffer);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.read.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We first check if an alert was raised, if it was, we immediately abort, since the stream is now dead. If there are any plain text bytes, we can return them directly from the buffer. We&#x2019;ll look into that as well as how we read from the network shortly. For now, let&#x2019;s focus on what we are doing here.We read enough from the network to know what is the envelope length that we have to read. That value, if you&#x2019;ll remember, is the first value that we send for a record and is not encrypted (there isn&#x2019;t much point, you can look at the packet information to get that if you wanted to). We then make sure that we read the entire record to the buffer. We decrypt the data from the incoming buffer to the plain_text buffer (that is what the read_buffer()&#xA0; function will use to actually return results).The rest of the code is figuring out what we actually got. We check what is the actual size of the data we received. We may have received a zero length value, so we have to handle this.We check whatever we got a data record or an alert. If the later, we mark it as such and return an error. If this is just the data, we setup the plain text buffer properly and go to the read_buffer() call to return the values.&#xA0; That is a lot of code, but not a lot of functionality. Simple code is best, and this match that scenario. Let&#x2019;s see how we handle the actual buffer and network reads:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn read_buffer(self: *CryptoReader, buffer: []u8) usize {&#xA;        &#xA;        &#xA;          &#xA;              var size = std.math.min(self.incoming_plain_text.len, buffer.len);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, buffer, self.incoming_plain_text[0..size]);&#xA;        &#xA;        &#xA;          &#xA;              self.incoming_plain_text = self.incoming_plain_text[size..];&#xA;        &#xA;        &#xA;          &#xA;              return size;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn read_from_network(self: *CryptoReader) !void {&#xA;        &#xA;        &#xA;          &#xA;              var existing = self.incoming.len; // we may have data already in buffer, but need more...&#xA;        &#xA;        &#xA;          &#xA;              var len = try self.reader.read(self.buffer[existing..(RecordBufferSize - existing)]);&#xA;        &#xA;        &#xA;          &#xA;              if (len == 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnexpectedEndOfStream;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.incoming = self.buffer[0..(existing &#x2B; len)];&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.buffer-net.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Not much here, just need to make sure that we handle partial reads as well as reading multiple records in one shot. We saw that when we get an alert, we return an error. But the question is, how do we get the actual alert? The answer is that we store the message in the plain text buffer and record the alert itself. All future calls will fail with an error. You can then call to the alert()&#xA0; function to get the actual details:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn alert(self: *CryptoReader) !Alert {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_code) |code| {&#xA;        &#xA;        &#xA;          &#xA;                  var rc = Alert{ .alert = code, .msg = self.incoming_plain_text };&#xA;        &#xA;        &#xA;          &#xA;                  return rc;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return error.NoAlertRecieved;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.alert.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This gives us a nice API to use when there are issues with the stream. I think that matches well with the way Zig handles errors, but I can&#x2019;t tell whatever this is idiomatic Zig.That is long enough for now, you can go and read the actual code, of course. And I will welcome any comments. In the next (and likely last) post in the series, I&#x201D;m going to go over error handling at the protocol level.</p>
        </article>
        <article id="article-887">
            <a href="https://ayende.com/blog/194881-A/a-pki-less-secure-communication-channel-coding-the-handshake" target="_blank">
                <h2 class="title mb-6" id="article-887">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 06, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After figuring out the design, let&#x2019;s see what it would take to actually write a secured communication channel, sans PKI, in code. I&#x2019;m going to use Zig as the language of choice here. It is as low level as C, but so much nicer to work with. To actually implement the cryptographic details, I&#x2019;m going to lean on libsodium to do all the heavy lifting. It took multiple iterations of the code to get to this point, but I&#x2019;m pretty happy with how it turned out. I&#x2019;ll start from the client code, which connects to a remote server and establish a secured TCP channel, here is what this looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn clientFn(&#xA;        &#xA;        &#xA;          &#xA;              host: []const u8,&#xA;        &#xA;        &#xA;          &#xA;              port: u16,&#xA;        &#xA;        &#xA;          &#xA;              server_pub_key: [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;              client_kp: crypto.KeyPair,&#xA;        &#xA;        &#xA;          &#xA;          ) !void {&#xA;        &#xA;        &#xA;          &#xA;              var server_key = protocol.Client.ExpectedPublicKey{&#xA;        &#xA;        &#xA;          &#xA;                  .end_public_key = server_pub_key,&#xA;        &#xA;        &#xA;          &#xA;                  .middlebox_public_key = server_pub_key,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              var con = try crypto.clientConnection(&#xA;        &#xA;        &#xA;          &#xA;                  std.heap.page_allocator,&#xA;        &#xA;        &#xA;          &#xA;                  host,&#xA;        &#xA;        &#xA;          &#xA;                  port,&#xA;        &#xA;        &#xA;          &#xA;                  client_kp,&#xA;        &#xA;        &#xA;          &#xA;                  server_key,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              defer con.stream.deinit();&#xA;        &#xA;        &#xA;          &#xA;              var encrypted_stream = con.stream;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var buf: [1024]u8 = undefined;&#xA;        &#xA;        &#xA;          &#xA;              // read normal message&#xA;        &#xA;        &#xA;          &#xA;              var len = try encrypted_stream.reader().read(&amp;buf);&#xA;        &#xA;        &#xA;          &#xA;              std.log.debug(&quot;{s}&quot;, .{buf[0..len]});&#xA;        &#xA;        &#xA;          &#xA;              // handle errors from the other side&#xA;        &#xA;        &#xA;          &#xA;              _ = encrypted_stream.reader().read(&amp;buf) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;                  std.log.debug(&quot;err {s}&quot;, .{@errorName(e)});&#xA;        &#xA;        &#xA;          &#xA;                  var a = try encrypted_stream.alert();&#xA;        &#xA;        &#xA;          &#xA;                  std.log.debug(&quot;{s} {s} {s}&quot;, .{ @errorName(e), @tagName(a.alert), a.msg });&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          client.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The function connects to a server, expecting it to use a particular public key, and will authenticate using a provided key pair. The bulk of the work is done in the crypto.clientConnection() call, where we are following the handshake I outlined here. The result of the call is an AuthenticatedConnection structure, containing both the encrypted stream as well as the public key of the other side. Note that from the client side, if the server doesn&#x2019;t authenticate using the expected key, the call will fail with an error, so for clients, it is usually not important to check the public key, that is already something that we checked.The actual stream we return expose a reader and writer instances that you can use to talk to the other side. Note that we are using buffered data, so writing to the stream will not do anything until the buffer is full (about 16KB) or flush() is called.The other side is the server, of course, which looks like this:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var client : std.net.Connection = try server.accept();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var con = try crypto.serverConnection(std.heap.page_allocator, client.stream, server_kp);&#xA;        &#xA;        &#xA;          &#xA;          std.log.debug(&quot;Connected, I&#x27;m {s} - other side {s}&quot;, .{&#xA;        &#xA;        &#xA;          &#xA;              crypto.KeyPair.keyBase64(server_kp.public),&#xA;        &#xA;        &#xA;          &#xA;              crypto.KeyPair.keyBase64(con.pub_key),&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;        &#xA;          &#xA;          var encrypted_stream = con.stream;&#xA;        &#xA;        &#xA;          &#xA;          defer encrypted_stream.deinit();&#xA;        &#xA;        &#xA;          &#xA;          var w = encrypted_stream.writer();&#xA;        &#xA;        &#xA;          &#xA;          try w.writeAll(&quot;hi there&quot;);&#xA;        &#xA;        &#xA;          &#xA;          try encrypted_stream.flush();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var msg = &quot;Opps, msg&quot;.*;&#xA;        &#xA;        &#xA;          &#xA;          try encrypted_stream.send_alert(crypto.AlertTypes.Badness, &amp;msg);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          server.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;On the server side, we have the crypto.serverConnection() call, it accepts a new connection from a listening socket and starts the handshake process. Note that this code, unlike the client, does not verify that the other side is known to us. Instead, we return that to the caller which can then check the public key of the client. This is intentional, because at this point, we have a secure channel, but not yet authentication. The server can then safely tell the other side that they authorize them (or not) using the channel with not one being able to peek what is going on there.Let&#x2019;s dig a bit deeper into the implementation. We&#x2019;ll start from the client code, which is simpler:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn clientConnection(&#xA;        &#xA;        &#xA;          &#xA;              allocator: *std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;              host: []const u8,&#xA;        &#xA;        &#xA;          &#xA;              port: u16,&#xA;        &#xA;        &#xA;          &#xA;              client_keys: crypto.KeyPair,&#xA;        &#xA;        &#xA;          &#xA;              expected_server_key: ?protocol.Client.ExpectedPublicKey,&#xA;        &#xA;        &#xA;          &#xA;          ) !AuthenticatedConnection {&#xA;        &#xA;        &#xA;          &#xA;              var con = try std.net.tcpConnectToHost(allocator, host, port);&#xA;        &#xA;        &#xA;          &#xA;              errdefer con.close();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var handshake = protocol.Client.init(client_keys, expected_server_key);&#xA;        &#xA;        &#xA;          &#xA;              var hello = try handshake.hello();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = con.writer();&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;hello));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var reader = con.reader();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var msg: protocol.ChallengeMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;msg));&#xA;        &#xA;        &#xA;          &#xA;              var response = try msg.respond(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;response));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var session = try handshake.generateKey();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var rc: AuthenticatedConnection = undefined;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;rc.pub_key, &amp;handshake.server.long_term_public_key);&#xA;        &#xA;        &#xA;          &#xA;              rc.stream = try crypto.NetworkStream.init(allocator, con, session);&#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          clientConnection.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The handshake protocol itself is handled by the protocol.Client. The way I have coded it, we are reading known lengths from the network into in memory structure and using them directly. I can do that because the structures are basically just bunch of packed []u8 (char arrays), so the in memory and network representation are one and the same. That makes things simpler. You can see that I&#x2019;m calling readNoEof on the structures as bytes. That ensure that I get the whole message from the network and then the actual operations that I need to make are handled. Here is the sequence of operations:After sending the hello, the server will respond with a challenge, the client replies and both sides now know that they other side is who they say they are.Let&#x2019;s dig a bit deeper, shall we, and see how we have the hello message:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn hello(self: *Client) !HelloMessage {&#xA;        &#xA;        &#xA;          &#xA;              var req: HelloMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              req.version = Client.ExpectedVersion;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;req.client_session_public_key, &amp;self.session.public);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(&#xA;        &#xA;        &#xA;          &#xA;                  u8,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;req.expected_server_public_key.data,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.server.expected_server_key.end_public_key,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              try req.expected_server_public_key.encrypt(&#xA;        &#xA;        &#xA;          &#xA;                  self.server.expected_server_key.middlebox_public_key,&#xA;        &#xA;        &#xA;          &#xA;                  self.session.secret,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              return req;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn EncryptedBoxBuffer(size: usize) type {&#xA;        &#xA;        &#xA;          &#xA;              return packed struct {&#xA;        &#xA;        &#xA;          &#xA;                  const Self = @This();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  data: [size]u8,&#xA;        &#xA;        &#xA;          &#xA;                  mac: [mac_len]u8,&#xA;        &#xA;        &#xA;          &#xA;                  nonce: [nonce_len]u8,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn encrypt(&#xA;        &#xA;        &#xA;          &#xA;                      self: *Self,&#xA;        &#xA;        &#xA;          &#xA;                      public_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                      secret_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                  ) !void {&#xA;        &#xA;        &#xA;          &#xA;                      c.randombytes_buf(&amp;self.nonce, self.nonce.len);&#xA;        &#xA;        &#xA;          &#xA;                      var rc = c.crypto_box_detached(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.mac,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          size,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.nonce,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;public_key,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;secret_key,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.EncryptionFailure;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  pub fn decrypt(&#xA;        &#xA;        &#xA;          &#xA;                      self: *Self,&#xA;        &#xA;        &#xA;          &#xA;                      public_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                      secret_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                  ) !void {&#xA;        &#xA;        &#xA;          &#xA;                      var rc = c.crypto_box_open_detached(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.mac,&#xA;        &#xA;        &#xA;          &#xA;                          size,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.nonce,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;public_key,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;secret_key,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.DecryptionFailure;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          hello.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There isn&#x2019;t much here, we set the version field to a known value, we copy our own session public key (which was just generated and tells no one nothing about us) and then we copy the expected server public key, but we aren&#x2019;t sending that over the wire in the clear. Instead, we encrypt that. We encrypt it with the client session public key (which we just send over) as well as the expected middlebox key (remember, those might be different). The idea is that the server on the other end may decide to route the request, but at the same time, we want to ensure that we are never revealing any information to 3rd parties. The actual encryption is handled via the EncryptedBoxBuffer structure, you can see that I&#x2019;m using Zig&#x2019;s comptime support to generate a structure with a compile time variant size. That make is trivial to do certain things without really needing to think about the details. It used to be more complex, and be able to support arbitrary embedded structures, but I simplified it to a single buffer. For that matter, for most of the code here, the size I&#x2019;m using is fixed (32 bytes / 256 bits). The key here is that all the details of nonce generation, MAC validation, etc are hidden and handled. I also don&#x2019;t really need to think about the space for that, since this directly part of the structure.It gets more interesting when we look at how the client respond to the challenge from the server:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const ChallengeMessage = packed struct {&#xA;        &#xA;        &#xA;          &#xA;              server_session_public_key: [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;              server_long_term_public_key: crypto.EncryptedBoxKey,&#xA;        &#xA;        &#xA;          &#xA;              long_term_key_proof: crypto.EncryptedBoxKey,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn respond(self: *ChallengeMessage, state: *Client) !ChallengeResponse {&#xA;        &#xA;        &#xA;          &#xA;                  var resp = std.mem.zeroes(ChallengeResponse);&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;state.server.session_public_key, &amp;self.server_session_public_key);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.server_long_term_public_key.decrypt(self.server_session_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;state.server.long_term_public_key, &amp;self.server_long_term_public_key.data);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (state.server.validate_server_key) {&#xA;        &#xA;        &#xA;          &#xA;                      if (!std.crypto.utils.timingSafeEql(&#xA;        &#xA;        &#xA;          &#xA;                          [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;                          state.server.expected_server_key.end_public_key,&#xA;        &#xA;        &#xA;          &#xA;                          state.server.long_term_public_key,&#xA;        &#xA;        &#xA;          &#xA;                      )) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.ExpectedServerPublicKeyMismatch;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.long_term_key_proof.decrypt(state.server.long_term_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (!std.crypto.utils.timingSafeEql([crypto.KeyLength]u8, self.long_term_key_proof.data, state.session.public)) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.LongTermProofValueAndSessionPublicKeyMismatch;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;resp.client_long_term_key.data, &amp;state.long_term.public);&#xA;        &#xA;        &#xA;          &#xA;                  try resp.client_long_term_key.encrypt(state.server.session_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;resp.challenge_answer.data, &amp;state.server.session_public_key);&#xA;        &#xA;        &#xA;          &#xA;                  try resp.challenge_answer.encrypt(state.server.session_public_key, state.long_term.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return resp;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ChallengeMessage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We copy the server&#x2019;s session public key to our own state, then we decrypt the server&#x2019;s long term public key using the public key that we were sent alongside the client&#x2019;s own secret key. Without both of them, we cannot decrypt the information that was sealed using the server&#x2019;s secret key and the client&#x2019;s public key. Remember that we have a very important distinction here:Session key pair &#x2013; generated per connection, transient, meaningless. If you know what the session public key is, you don&#x2019;t get much.Long term key pair &#x2013; used for authentication of the other side. If you know what the long term public key, you may figure out who the client or server are.Because of that, we never send the long term public keys in the clear. However, just getting the public key isn&#x2019;t enough, we need to ensure that the other side actually holds the full keypair, not just saying that it does.We handle that part asking that the server will encrypt the client&#x2019;s public session key using its long term secret key. Because the public session key is something that the client controls, the fact that the server can produce a value that decrypt to that using the stated public key ensures that it holds the secret portion as well. To answer the challenge, we do much the same thing in reverse. In other words, we are encrypting the server&#x2019;s public session key with our own long term key and sending that to the server. The final step is actually generating the symmetric keys for the channel, which is done using:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn generate_client(client: KeyPair, server_public_key: [KeyLen]u8) !SecretKeys {&#xA;        &#xA;        &#xA;          &#xA;              var rc: SecretKeys = undefined;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_kx_client_session_keys(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;rc.recieve[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;rc.transmit[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;client.public[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;client.secret[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;server_public_key[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.FailedToGenerateKey;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          gen_keys.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We are using the client&#x2019;s session key pair as well as the server&#x2019;s public key to generate a shared secret. Actually, a pair of secrets, one for sending and one for receiving. On the other side, you do pretty much the same in reverse. You can see the full source code here. This is only a partial work, of course, we still need to deal with the issue of actually sending data after the handshake, I&#x2019;ll deal with that in my next post.</p>
        </article>
        <article id="article-888">
            <a href="https://ardalis.com/better-faster-demos-with-screencast-videos/" target="_blank">
                <h2 class="title mb-6" id="article-888">Better Faster Demos with Screencast Videos</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 06, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Do you ever need to demo your app to users, customers, or stakeholders? Is it part of your regular software delivery process? What about&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-889">
            <a href="https://andrewlock.net/exploring-dotnet-6-part-4-building-a-middleware-pipeline-with-webapplication/" target="_blank">
                <h2 class="title mb-6" id="article-889">Building a middleware pipeline with WebApplication</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 05, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Exploring .NET 6 - Part 4</p>
        </article>
        <article id="article-890">
            <a href="https://ayende.com/blog/194849-B/a-pki-less-secure-communication-channel-the-record-layer" target="_blank">
                <h2 class="title mb-6" id="article-890">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 04, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I talked a lot about the manner in which both client and server will authenticate one another safely and securely. The reason for all the problem is that we want to ensure that we are talking to the entity we believe we do, protect ourselves from man in the middle, etc. The entire purpose of the handshake exchange is to establish that the person on the other side is the right one and not a malicious actor (like the coffee shop router or the corporate firewall). Once we establish who is on the other side, the rest is pretty easy. Each side of the connection generated a key pair specifically for this connection. They then managed to send each other both the other side&#x2019;s public key as well as prove that they own another key pair (trust in which was established separately, in an offline manner).In other words, on each side, we have:My key pair (public, secret)&#xA;Other side public keyWith those, we can use key exchange to derive a shared secret key. The gist of this is that we know that this statement holds:op(client_secret, server_public) == op(server_secret, client_public)The details on the actual op() aren&#x2019;t important for understanding, but I&#x2019;m using sodium, so this is scalar multiplication over curve 25519. If this tells you anything, great. Otherwise, you can trust that people who do understand the math says that this is safe to do. Diffie-Hellman is the search term to use to understand how this works.Now that we have a shared secret key, we can start sending data to one another, right? It would appear that the answer to that is&#x2026; no. Or at least, not yet. The communication channel that we build here is based is built on top of TCP, providing two way communication for client and server. The TCP uses the stream abstraction to send data over the wire. That does not work with modern cryptographic algorithm.How can that be? After is literally this thing called stream cipher, after all. If you cannot use a stream cipher for stream, what is it for?A stream cipher is a basic building block for modern cryptography. However, it also has a serious problem. It doesn&#x2019;t protect you from modification of the ciphertext. In other words, you will &#x201C;successfully&#x201D; decrypt the value and use it, even though it was modified. Here is a scary scenario of how you can abuse that badly.Because of such issues, all modern cryptographic algorithms uses Authenticated Encryption. In other words, to successfully complete their operation, they require that the cipher stream will match a cryptographic key. In other words, conceptually, the first thing that a modern cipher will do on decryption is something like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          def decrypt(key, nonce, cipher_text):&#xA;        &#xA;        &#xA;          &#xA;            mac = cipher_text[:16] # last 16 bytes are the signature&#xA;        &#xA;        &#xA;          &#xA;            expected_mac = crypto_hash(key, nonce, cipher_text[0:-16])&#xA;        &#xA;        &#xA;          &#xA;            if not timeSafeEql(mac, expected_mac):&#xA;        &#xA;        &#xA;          &#xA;              raise &quot;Invalid cipher text&quot;&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            return actually_decrypt(key, nonce, cipher_text[0:-16])&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          cipher.py&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;That isn&#x2019;t quite how this looks like, but it is close enough to understand what is going on. If you want to look at how a real implementation does it, you can look here. The python code is nicer, but this is basically the same concept.So, why does that matter for us? How does this relate to having to dealing with streams?Consider the following scenario, in this model, in order to successfully decrypt anything, we first need to validate the MAC (message authentication code) for the encrypted value. But in order to do that, we have to have the whole value, not just part of that. In other words, we cannot use a real stream, instead, we need to send the data in chunks. The TLS protocol has the same issue, that is handled via the notion of records, with a maximum size of about 16KB. So a TLS stream is actually composed of records that are processed independently from one another. That also means that before you get to the TLS a buffered stream is a must, otherwise we&#x2019;ll send just a few plain text bytes for a lot of cryptographic envelope. In other words, if you call tls.Write(buffer[0..4]), if you don&#x2019;t have buffering, this will send a packet with a cryptographic envelope that is much bigger than the actual plain text value that you sent.&#xA0; Looking at the TLS record layer, I think that I&#x2019;ll adopt many of the same behaviors. Let&#x2019;s consider a record:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          RecordEnvelope = {&#xA;        &#xA;        &#xA;          &#xA;            Len  : u16,       // Max 16KB, *includes* the size of Len&#xA;        &#xA;        &#xA;          &#xA;            Record : [Len -2]u8  // The cipher text&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          Record = {&#xA;        &#xA;        &#xA;          &#xA;            Len  : u16,        // &lt; RecordEnvelope.Len, includes the size of Len &amp; Data.&#xA;        &#xA;        &#xA;          &#xA;            Type : u8,         // Data | Alert&#xA;        &#xA;        &#xA;          &#xA;            Data : [Len - 3]u8,    // If Alert - Lne &gt;= 3 and Data starts with 16 bits error code, then a string for the error itself.&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Note that padding here is explicitly allowed.&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          record.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;So each record is composed of an envelope, that simply contains the length, then we have the cipher text itself. I&#x2019;m intending to use the libsodium&#x2019;s encrypted stream, because it lets me handle things like re-keying on the fly transparently, etc. We read the record from the network, decrypt and then need to decide what to do. If this is an alert, we raise it to the user (this is critical for good error reporting). Note that in this way I can send (an encrypted) stream to the other side to give a good error for the caller. For data, we just pass it to the caller. Note that there is one very interesting aspect here. We have two Len fields. This is because we allow padding, that can help avoid attacks such as BREACH and mitigate traffic analysis.&#xA0; We ensure that the padding is always set to zero, similar in reason to the TLS model, to avoid mistakes and to force implementation correctness.I think that this is enough theory for now. In my next post, I want to get to actually implementing this.As usual, I would love to hear your feedback and comments.</p>
        </article>
        <div class="button flex justify-between">
            <a href="88.html"><span class="back arrow"></span></a>

            <a href="90.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>