
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 187 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-1861">
            <a href="https://ayende.com/blog/185537-A/recursive-indexing-in-ravendb" target="_blank">
                <h2 class="title mb-6" id="article-1861">Recursive indexing in RavenDB</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 17, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Consider the graph on the right. I already talked about this graph when I wrote about permission based graph queries.In this post, I want to show off another way to deal with the same problem, but without using graph queries, and using only the capabilities that we have in RavenDB 4.1.The idea is that, given a user, I want to be able to issue a query for all the issues that this user has access to, either directly (like Sunny in the graph), via a group (like Max, via project-x group) or via a recursive group, like (Nati, via project-x &#x2013;&gt; team-nati groups).As you can image from the name of this post, this requires recursion. You can read the documentation about this, but I thought to spice things up and use several features all at once. Let&#x2019;s look at the following index (Issues/Permissions):&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // Issues/Permissions index definition&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          map(&quot;Issues&quot;, issue =&gt;{&#xA;        &#xA;        &#xA;          &#xA;             var groups = issue.Groups.reduce(recurse_groups, {});&#xA;        &#xA;        &#xA;          &#xA;             return  { Groups: Object.keys(groups), Users: issue.Users };&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          function recurse_groups(accumulator, grpId) {&#xA;        &#xA;        &#xA;          &#xA;              if(grpId == null || accumulator.hasOwnProperty(grpId))&#xA;        &#xA;        &#xA;          &#xA;                  return accumulator;&#xA;        &#xA;        &#xA;          &#xA;              accumulator[grpId] = null; &#xA;        &#xA;        &#xA;          &#xA;              var grp = load(grpId, &quot;Groups&quot;);&#xA;        &#xA;        &#xA;          &#xA;              if(grp == null || grp.Parents == null)&#xA;        &#xA;        &#xA;          &#xA;                  return accumulator;&#xA;        &#xA;        &#xA;          &#xA;              return grp.Parents.reduce(recurse_groups, accumulator);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          index.js&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is an JS index, which has a map() function over the Issues collection. For each of the issues, we index the Users for the issue and the groups (recursively) that are allowed to access it.Here is what the output of this index will be for our issue in the graph:Now, let&#x2019;s look at how we can query this, shall we?This query has two clauses, either we are assigned directly or via a group. The key here is in the recurse_groups() and inside that, the load() call in the index. It scans upward through the defined groups and their parents until we have a simple structure in the index that is easily searchable.RavenDB will ensure that whenever a document that is referenced by a load() in the index is updated, all the documents that are referencing it will be re-indexed. In the case we have here, whenever a group is updated, we&#x2019;ll re-index all the relevant issues to match the new permissions structure.One of the core principles of RavenDB is that you can push more work to the indexing and keep your queries fast and simple. This is a good example of how we can arrange the data in such a way that we can push work to background indexing in a pretty elegant manner.</p>
        </article>
        <article id="article-1862">
            <a href="https://www.meziantou.net/writing-a-roslyn-analyzer.htm" target="_blank">
                <h2 class="title mb-6" id="article-1862">Writing a Roslyn analyzer</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 17, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This post is part of the series &#x27;Roslyn Analyzers&#x27;. Be sure to check out the rest of the blog posts of the series!Writing a Roslyn analyzer (this post)Writing language-agnostic Roslyn Analyzers using IOperationWorking with types in a Roslyn analyzerReferencing an analyzer from a projectPackaging a</p>
        </article>
        <article id="article-1863">
            <a href="https://ayende.com/blog/185505-A/when-a-production-crash-and-a-killer-bug-isnt-a-big-deal" target="_blank">
                <h2 class="title mb-6" id="article-1863">When a production crash (and a killer bug) isn&#x2019;t a big deal</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 13, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We test RavenDB as thoroughly as we can. Beyond just tests, longevity runs, load test and in general beating it with a stick and seeing if it bleats, we also routinely push early build of RavenDB to our own production systems to see how it behaves on real load. This has been invaluable in catching several hard to detect bugs. A few days after we pushed a new build to production, we started getting errors about running out of disk space. The admin looked, and it seemed to have fixed itself. Then it repeated the issue. It took a bit of time to figure out what was going on. A recent change caused RavenDB to hang on to what are supposed to be transient files until an idle moment. Where idle moment is defined as 5 seconds without any writes. Our production systems don&#x2019;t have an idle moment, here is a typical load on our production system:We&#x2019;ll range between lows of high 30s requests per seconds to peeks of 200&#x2B; requests per second. So we never have an idle moment to actually clean up those files, so they gather up. Eventually, we run out of disk space. At this point, several interesting things happen. Here is what our topology looks like:We have three nodes in the cluster, and currently, node B is the leader of the cluster as a whole. Most of our operations relate to a single database, and for that database, we have the following topology:Note that in RavenDB, the cluster as a whole and a particular database may have different topologies. In particular, the primary node for the database and the leader of the cluster can and are often different. In this case, Node A is the primary for the database and node B is the leader of the cluster.Under this scenario, we have Node A accepting all the writes for this database, and then replicating the data to the other nodes. Here is what this looks like for node C.In other words, Node A is very busy handling requests and writes. Node C is just handling replicated writes. Just for reference, here is what Node A&#x2019;s CPU looks like, the one that is busy:In other words, it is busy handling requests. But it isn&#x2019;t actually busy. We got a lot of spare capacity at hand.This make sense, our benchmark scenarios is starting with tens of thousands of requests per seconds. A measly few hundreds per second aren&#x2019;t actually meaningful load. The servers in questions, by the way, are t2.large with 2 cores and 8GB of RAM. So we have a bug in releasing files when we aren&#x2019;t &#x201C;idle&#x201D;. The files just pile up and eventually we run out of disk space. Here is what this looks like in the studio:And clicking on details gives us:So this looks bad, but let&#x2019;s us see how this actually turns out to work in practice.We have a failure on one node, which causes the database to be unloaded. RavenDB is meant to run in an environment where failure is likely and is built to handle that. Both clients and the cluster as a whole know that when such things happen, either to the whole node or to one particular database on it, we should respond accordingly.The clients automatically fail over to a secondary node. In the case of the database in question, we can see that if Node A is failure, the next in like would be Node C. The cluster will also detect that are re-arrange the responsibilities of the nodes to indicate that one of them failed.The node on which the database has failed will attempt to recover from the error. At this point, the database is idle, in the sense that it doesn&#x2019;t process any requests, and will be able to cleanup all the files and delete them. In other words, the database goes down, restarts and recover. Because of the different write patterns on the different nodes, we&#x2019;ll run into the out of disk space error at different times. We have been running in this mode for a few days now. The actual problem, by the way, has been identified and resolved. We just aren&#x2019;t any kind of pressure to push the fix to production.Even under constant load, the only way we can detect this problem is through the secondary affects, the disk space on the machines that is being monitored. None of our production systems has reported any failures and monitoring is great across the board. This is a great testament to the manner in which expecting failure and preparing for it at all levels of the stack really pays off. My production database is routinely running out of space? No worries, I&#x2019;ll fix that on the regular schedule, nothing is actually externally visible.</p>
        </article>
        <article id="article-1864">
            <a href="https://ardalis.com/support-for-value-objects-in-csharp/" target="_blank">
                <h2 class="title mb-6" id="article-1864">Support for Value Objects in C#</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 13, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">As someone who uses many Domain-Driven Design patterns in my .NET code, I&#x27;ve long wanted to have built-in immutable value objects in C&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-1865">
            <a href="https://andrewlock.net/dark-mode-now-available/" target="_blank">
                <h2 class="title mb-6" id="article-1865">Dark mode now available!</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 13, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I recently added a dark mode to my blog. Here&#x27;s how you can enable it, how I implemented it, and what&#x27;s currently missing!&#x2026;</p>
        </article>
        <article id="article-1866">
            <a href="https://ayende.com/blog/185473-B/refactoring-c-code-going-to-async-i-o" target="_blank">
                <h2 class="title mb-6" id="article-1866">Refactoring C Code</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 12, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Now that I have a good idea on how to use OpenSSL and libuv together, I&#x2019;m going to change my code to support that mode of operation. I have already thought about this a lot, and the code I already have is ready to receive the change in behavior, I think.One of the things that I&#x2019;m going to try to do while I move the code over is properly handle all error conditions. We&#x2019;ll see how that goes.I already have the concept of a server_state_run() method that handles all the network activity, dispatching,&#xA0; etc. So that should make it easy. I&#x2019;m going to start by moving all the libuv code there. I&#x2019;m also going to take the time to refactor everything to an API that is more cohesive and easier to deal with.There is some trouble here, with having to merge together two similar (but not quite identical) concepts. My libuv &amp; openssl post dealt with simply exposing a byte stream to the calling code. My network protocol code is working at a higher level. Initially I tried to layer things together, but that quickly turned out to be a bad idea. I decided to have a single layer that handles both the reading from the network, using OpenSSL and parsing the commands over the network.The first thing to do was to merge the connection state, I ended up with this code:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          struct tls_uv_connection_state_private_members {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;server_state_t* server;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_t* handle;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL *ssl;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO *read, *write;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t** prev_holder;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t* next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int in_queue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;size_t pending_writes_count;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_buf_t* pending_writes_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;} pending;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;size_t used_buffer, to_scan;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int flags;&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          #define RESERVED_SIZE (64 - sizeof(struct tls_uv_connection_state_private_members))&#xA;        &#xA;        &#xA;          &#xA;          #define MSG_SIZE (8192 - sizeof(struct tls_uv_connection_state_private_members) - 64 - RESERVED_SIZE)&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // This struct is exactly 8KB in size, this&#xA;        &#xA;        &#xA;          &#xA;          // means it is two OS pages and is easy to work with&#xA;        &#xA;        &#xA;          &#xA;          typedef struct tls_uv_connection_state {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;struct tls_uv_connection_state_private_members;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char reserved[RESERVED_SIZE]; &#xA;        &#xA;        &#xA;          &#xA;          &#x9;char user_data[64]; // location for user data, 64 bytes aligned, 64 in size&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char buffer[MSG_SIZE];&#xA;        &#xA;        &#xA;          &#xA;          } tls_uv_connection_state_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          static_assert(offsetof(tls_uv_connection_state_t, user_data) % 64 == 0, &quot;tls_uv_connection_state_t.user should be 64 bytes aligned&quot;);&#xA;        &#xA;        &#xA;          &#xA;          static_assert(sizeof(tls_uv_connection_state_t) == 8192, &quot;tls_uv_connection_state_t should be 8KB&quot;);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          connection_state.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There are a few things that are interesting here. On the one hand, I want to keep the state of the connection private, but on the other, we need to expose this out to the user to use some parts of it. The way libuv handles it is with comments denoting what are considered public / private portions of the interface. I decided to stick it in a dedicated struct. This also allowed me to get the size of the private members, which is important for what I wanted to do next.The connection state struct have the following sections:private / reserved &#x2013; 64 bytesavailable for user to use &#x2013; 64 bytes (and aligned on 64 bytes boundary)msg buffer &#x2013; 8,064 bytesThe idea here is that we give the user some space to keep their own data in, and that the overall connection state size is exactly 8KB, so can fit in two OS pages. On Linux, in most cases, we&#x2019;ll not need a buffer that is over 3,968 bytes long, we can even save the second page materialization (because the OS lazily allocate memory to the process). I&#x2019;m using 64 bytes alignment for the user&#x2019;s data to reduce any issues that the user have for storing data about the connection. It will also keep it nicely within the data the user need to handle the connection nearby the actual buffer. I&#x2019;m 99% sure that I won&#x2019;t need any of these details, but I thought it is best to think ahead, and it was fun to experiment. Here is how the startup code for the server changed:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          connection_handler_t handler = {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;print_all_errors,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;on_connection_dropped,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;create_connection,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;on_connection_recv&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          server_state_init_t options = { &#xA;        &#xA;        &#xA;          &#xA;          &#x9;cert, &#xA;        &#xA;        &#xA;          &#xA;          &#x9;key, &#xA;        &#xA;        &#xA;          &#xA;          &#x9;&quot;0.0.0.0&quot;, &#xA;        &#xA;        &#xA;          &#xA;          &#x9;4433,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&amp;handler,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{  // allowed certs&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&quot;1776821DB1002B0E2A9B4EE3D5EE14133D367009&quot; , &#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&quot;AE535D83572189D3EDFD1568DC76275BE33B07F5&quot; &#xA;        &#xA;        &#xA;          &#xA;          &#x9;},&#xA;        &#xA;        &#xA;          &#xA;          &#x9;2 // number of allowed certs&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          srv_state = server_state_create(&amp;options);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          init.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I removed pretty much all the functions that were previously used to build it. We have the server_state_init_t struct, which contains everything that is required for the server to run. Reducing the number of functions to build this means that I have to do less and there is a lot less error checking to go through. Most of the code that I had to touch didn&#x2019;t require anything interesting. Take the code from the libuv/openssl project, make sure it compiles, etc. I&#x2019;m going to skip talking about the boring stuff. I did run into an couple of issues that are worth talking about. Error handling and authentication. As mentioned, I&#x2019;m using client certificates for authentication, but unlike my previous code, I&#x2019;m not explicitly calling SSL_accept(), instead, I rely on OpenSSL to manage the state directly. This means that I don&#x2019;t have a good location to put the checks on the client certificate that is used. For that matter, our protocol starts with the server sending an: &#x201C;OK\r\n&#x201D; message to the client to indicate successful connection. Where does this go? I put all of this code inside the handle_read() method.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          int ensure_connection_intialized(tls_uv_connection_state_t* state) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (state-&gt;flags &amp; CONNECTION_STATUS_INIT_DONE)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (SSL_is_init_finished(state-&gt;ssl)) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;flags |= CONNECTION_STATUS_INIT_DONE;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (validate_connection_certificate(state) == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;state-&gt;flags |= CONNECTION_STATUS_WRITE_AND_ABORT;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return connection_write(state, &quot;OK\r\n&quot;, 4);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void handle_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = client-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (nread &lt;= 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;push_libuv_error(nread, &quot;Unable to read&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;server-&gt;options.handler-&gt;connection_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = BIO_write(state-&gt;read, buf-&gt;base, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;assert(rc == nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (1)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int rc = SSL_read(state-&gt;ssl, buf-&gt;base, buf-&gt;len);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc &lt;= 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;push_ssl_errors();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;state-&gt;server-&gt;options.handler-&gt;connection_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;ensure_connection_intialized(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// need to read more, we&#x27;ll let libuv handle this&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// should be rare: can only happen if we go for 0rtt or something like that&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// and we do the handshake and have real data in one network roundtrip&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (ensure_connection_intialized(state) == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break; &#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (state-&gt;flags &amp; CONNECTION_STATUS_WRITE_AND_ABORT) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// we won&#x27;t accept anything from this kind of connection&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// just read it out of the network and let&#x27;s give the write&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// a chance to kill it&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (read_message(state, buf-&gt;base, rc) == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// handler asked to close the socket&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (maybe_flush_ssl(state)) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;state-&gt;flags |= CONNECTION_STATUS_WRITE_AND_ABORT;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(buf-&gt;base);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          read.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This method is called whenever libuv has more data to give us on the connection. The actual behavior is on ensure_connection_intialized(), where we check a flag on the connection, and if we haven&#x2019;t done the initialization of the connection, we check i OpenSSL consider the connection established. If it is established, we validate the connection and then send the OK to start the ball rolling.You might have noticed a bunch of work with flags CONNECTION_STATUS_WRITE_AND_ABORT and CONNECTION_STATUS_INIT_DONE. What is that about? Well, CONNECTION_STATUS_INIT_DONE is self explanatory, I hope. This just tells us whatever the connection has already been checked or not. This save us the cost of validate the client cert of each packet. Usually, SSL handshake means that we could do this check only inside the &#x201C;need to read more from the network&#x201D;, but I think that there are certain communication patterns in which the SSL handshake could be completed and the packet will already have additional encrypted information for the connection. For example, I&#x2019;m pretty sure that TLS 1.3 0-RTT is one such case. This is why the ensure_connection_initialized() is called twice in the code. Of more interest is the CONNECTION_STATUS_WRITE_AND_ABORT flag. This is set in one of two locations. First, if we fail to validate the certificate for the connection. Second, if we failed to process the message that was sent to us (inside read_message()).In either case, we want to close the connection, but we have a problem: Error handling. We use libuv for all I/O, and that is asynchronous in nature. We want to write an error to the other side, to be nice, and in order to do that, we need to process the write and keep the connection around long enough that we&#x2019;ll actually send it to the other side. Because of this, when this flag is set, we have the following behaviors:Any newly available data on that connection is immediately discardedThe next write will flush all the data to the network, wait for confirmation that this was sent and close the connection.This works very nicely to allow me to abort on an error and still get really nice errors on the other side.As usual, you can read the full code for the network protocol for this post here.</p>
        </article>
        <article id="article-1867">
            <a href="https://www.meziantou.net/inlining-a-stylesheet-a-javascript-or-an-image-file-using-a-taghelper-in-asp-net.htm" target="_blank">
                <h2 class="title mb-6" id="article-1867">Inlining a Stylesheet, a JavaScript, or an image file using a TagHelper in ASP.NET Core</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 12, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I&#x27;ve written about inlining a Stylesheet file in the page. This allows you to reduce the number of requests required to load the page, and so to reduce the loading time of the page. The TagHelper automatically replaces the tag with the content of the file at runtime, so the ht</p>
        </article>
        <article id="article-1868">
            <a href="https://ayende.com/blog/185441-A/using-openssl-with-libuv" target="_blank">
                <h2 class="title mb-6" id="article-1868">Using OpenSSL with libuv</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I want to move my simple blocking socket based code to use libuv, so to allow more than a single connection per thread. The catch is that I also want to do that with TLS, and that seems to be much harder. There are a bunch of GitHub projects that talks about this, but as I know nothing about libuv (and very little about OpenSSL) I decided to write own TLS echo server with libuv to get better understanding of how it all play together. Sit tight, this might take a while to explain. This is a complex topic and it took me a couple of nights of hacking to get it work, and then a lot of thinking into simplifying this to something that I actually like. There seems to be great documentation for libuv, which is awesome. I went over the simple echo server sample and it seems relatively straightforward. Making the jump to using TLS is a bit harder. OpenSSL make it really easy to setup SSL on a socket file descriptor and read/write to it. There is even support for non blocking operations, but I didn&#x2019;t want to be forced to write my own select()/poll() code, so how can I integrate these two libraries?OpenSSL has the notion of a BIO abstraction, which stands for Basic I/O.&#xA0; Basically, this is a stream abstraction. One of the options that OpenSSL has available is the memory BIO. So the overall idea is to:Setup libuv to accept a connectionSetup OpenSSL with the server side configurationWhen a new connection comes through, setup a new SSL instance from SSLRead data from the socket and pass it to the SSL instance and vice versaEnjoy encrypted communicationThe devil is in the details, naturally. The most complex part, after getting the initial handshake to work, in my experience, is the fact that you can get re-negotiation at any time which mean that a write request will fail with need more read data. That really complicate the amount of state that you have to manage.Basically, on every SSL_write when managing your own state, you may need to do SSL_read and then retry to previous write. The simplest scenario that we have here is when SSL_accept() on the connection, which results in the following code to manage this state:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void complete_accept_ssl_flush(int socket, write_req_t* req, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(req-&gt;buf);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(req);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(socket, status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;async_read(socket, cb);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void maybe_flush_ssl_buffer(int socket) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = BIO_pending(state-&gt;write);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;write_req_t * req = calloc(1, sizeof(write_req_t));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;req-&gt;buf = malloc(rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;req-&gt;len = BIO_read(state-&gt;write, buf.base, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;async_write(socket &amp;buf, 1, complete_accept_ssl_flush);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;async_read(socket, complete_accept_ssl_flush);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void accept_ssl(int socket, void* buf, ssize_t nread) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (nread &lt;= 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(socket, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_write(state-&gt;read, buf-&gt;base, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(buf);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = SSL_accept(state-&gt;ssl);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc == 1) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;on_tls_connection_established(client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc == SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;maybe_flush_ssl_buffer(client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;abort_connection_on_error(client, rc);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          async_accept.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;To handle a read, we need to check, after every read if the act of reading caused us to need to write (client wants to renegotiate the connection, so OpenSSL needs to send data on the connection, which we need to orchestrate) before we can do the actual read. For writes, we need to remember what we are writing, read and write from the network and then repeat our read. This is awkward to do when using synchronous calls, but the amount of state that we have to keep in async and callback driven programming is a lot. I got it working, but it was really hard and mostly a big house of cards.I really didn&#x2019;t like that approach, and decided that I should go about it in a very different way. I realized that I had a very conceptual error in how I approach libuv. Unlike standard async programming in C#, for example, libuv is based on the idea of a loop. In other words, unlike in the code above, you aren&#x2019;t going to setup the next read from the network after each one. That is already done for you. You just call un_read_start() and you&#x2019;ll get served the data from the network whenever it is available. You can also inject your own behaviors into the loop, which make things really interesting for ourselves. Here is the logic, we continuously read from the network and pass the buffer to OpenSSL. We then try to read the decrypted data from SSL_read(). This can fail because we are waiting for more data, and that is fine. We&#x2019;ll be called again when there is such data. However, we&#x2019;ll also add a step at the end of the I/O loop to check if there are any pending buffers that needs to be flushed to the network. For writes, if we fail to do the write because we need to read, we&#x2019;ll register the write to be executed later and wait for the network to send us the read operation.Given that C isn&#x2019;t an OO language, I think that I&#x2019;ll start explaining what is going on from the structs that hold the system together and then the operations that are invoked on them:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          typedef struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* (*create_connection)(uv_tcp_t* connection);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int (*connection_established)(tls_uv_connection_state_t* connection);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;void (*connection_closed)(tls_uv_connection_state_t* connection, int status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int (*read)(tls_uv_connection_state_t* connection, void* buf, ssize_t nread);&#xA;        &#xA;        &#xA;          &#xA;          } connection_handler_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          int connection_write(tls_uv_connection_state_t* state, void* buf, int size);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          typedef struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL_CTX *ctx;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_loop_t* loop;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;connection_handler_t protocol;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          } tls_uv_server_state_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          typedef struct tls_uv_connection_state {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_server_state_t* server;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_t* handle;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL *ssl;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO *read, *write;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t** prev_holder;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t* next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int in_queue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;size_t pending_writes_count;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_buf_t* pending_writes_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;} pending;&#xA;        &#xA;        &#xA;          &#xA;          } tls_uv_connection_state_t;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          dtos.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The first thing to note here is that we have clear layers in the code. We have the connection_handler_t in here, which is a bunch of function pointers that allow higher level code to work with a connection abstraction. The first portion of the code defines the interface that I expect callers to use. As you can see, we have a few functions that deal with creating, establishing and tearing down a connection. We also have the most common operations, reads and writes.The write method is pretty obvious, I think. You give it a buffer and it takes care of writing it to the other side. Note that this is an asynchronous process, and if there are any errors in the process, you&#x2019;ll get them in the connection_closed callback. Reading, on the other hand, is completely out of your hands and will be invoked directly by the lower level code whenever it feels like it. This inversion of control may feel strange for people who are used to invoking I/O directly, but it likely allow you better overall performance.Now that we have the interface, let&#x2019;s build a TLS echo server with it. Here is how that looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          tls_uv_connection_state_t* on_create_connection(uv_tcp_t* connection) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return calloc(1, sizeof(tls_uv_connection_state_t));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          int on_connection_established(tls_uv_connection_state_t* connection) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return connection_write(connection, &quot;OK\r\n&quot;, 4);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void on_connection_closed(tls_uv_connection_state_t* connection, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;report_connection_failure(status);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          int on_read(tls_uv_connection_state_t* connection, void* buf, ssize_t nread) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return connection_write(connection, buf, nread);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Basic SSL setup&#xA;        &#xA;        &#xA;          &#xA;          const SSL_METHOD* method = TLSv1_2_server_method();&#xA;        &#xA;        &#xA;          &#xA;          SSL_CTX* ctx = SSL_CTX_new(method);&#xA;        &#xA;        &#xA;          &#xA;          SSL_CTX_use_certificate_file(ctx, cert, SSL_FILETYPE_PEM);&#xA;        &#xA;        &#xA;          &#xA;          SSL_CTX_use_PrivateKey_file(ctx, key, SSL_FILETYPE_PEM);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Basic libuv setup&#xA;        &#xA;        &#xA;          &#xA;          uv_loop_t* loop = uv_default_loop();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Define the actual behavior of the server&#xA;        &#xA;        &#xA;          &#xA;          tls_uv_server_state_t server_state = {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;.ctx = ctx,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;.loop = loop,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;.protocol = {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.create_connection = on_create_connection,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.connection_closed = on_connection_closed,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.read = on_read,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.connection_established = on_connection_established&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          tls_echo_server.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;You can see that there isn&#x2019;t really much done here. On connection creation, we simply allocate a space for tls_uv_connection_state_t. This is a callback because your code might want to allocate more space for whatever stuff you want to do in the per connection structure. When the connection is established (after the SSL negotiation, etc), you get a chance to initiate things from the server side. In the code above, we simply let the client know that the connection has been successful. From that point on, we simply echo back to the client anything that they send us.The SSL and libuv initialization are the bare bones stuff and not really interesting. The nice bits happen in the end of the snippet, where we define the overall server state and wire together the protocol definition.That is great, but where the part where stuff actually gets done? A note about this code. I&#x2019;m writing this primarily for ease of reading / understanding. I&#x2019;m ignoring a lot of potential errors that in production code I would be obliged to handle. That would significantly complicate the code, but must be done if you want to use this code for anything but understanding the overall concept.Let&#x2019;s finish setting up the libuv machinery before we jump to any other code, shall we. Here is what this looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          uv_tcp_t server;&#xA;        &#xA;        &#xA;          &#xA;          uv_tcp_init(loop, &amp;server);&#xA;        &#xA;        &#xA;          &#xA;          server.data = &amp;server_state;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          struct sockaddr_in addr;&#xA;        &#xA;        &#xA;          &#xA;          uv_ip4_addr(&quot;0.0.0.0&quot;, DEFAULT_PORT, &amp;addr);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uv_tcp_bind(&amp;server, (const struct sockaddr*)&amp;addr, 0);&#xA;        &#xA;        &#xA;          &#xA;          int r = uv_listen((uv_stream_t*)&amp;server, DEFAULT_BACKLOG, on_new_connection);&#xA;        &#xA;        &#xA;          &#xA;          if (r) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;fprintf(stderr, &quot;Listen error %s\n&quot;, uv_strerror(r));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          uv_prepare_t after_io;&#xA;        &#xA;        &#xA;          &#xA;          after_io.data = &amp;server_state;&#xA;        &#xA;        &#xA;          &#xA;          uv_prepare_init(loop, &amp;after_io);&#xA;        &#xA;        &#xA;          &#xA;          uv_prepare_start(&amp;after_io, check_if_need_to_flush_ssl_state);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uv_run(loop, UV_RUN_DEFAULT);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          eventloop.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is fairly straightforward. We are listening to a socket and binding any incoming connection to the on_new_connection() callback. There is also the after_io preparation stuff, which we use to handle delayed operations (I&#x2019;ll talk about this later). For now, I want to focus on accepting new connections and processing them.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void on_new_connection(uv_stream_t *server, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;report_connection_failure(status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_server_state_t* server_state = server-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_t *client = (uv_tcp_t*)malloc(sizeof(uv_tcp_t));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_init(server_state-&gt;loop, client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;status = uv_accept(server, (uv_stream_t*)client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status != 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_close((uv_handle_t*)client, NULL);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;report_connection_failure(status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = server_state-&gt;protocol.create_connection(client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;ssl = SSL_new(server_state-&gt;ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL_set_accept_state(state-&gt;ssl);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;server = server_state;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;handle = client;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;read = BIO_new(BIO_s_mem());&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;write = BIO_new(BIO_s_mem());&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_set_nbio(state-&gt;read, 1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_set_nbio(state-&gt;write, 1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL_set_bio(state-&gt;ssl, state-&gt;read, state-&gt;write);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;client-&gt;data = state;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (server_state-&gt;protocol.connection_established(state) == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_read_start((uv_stream_t*)client, alloc_buffer, handle_read);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          on_new_connection.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is quite a lot that is going on this method, and not all of it is obvious. First, we handle accepting the connection and binding its input to the libuv event loop. Then we create a connection and setup some of the SSL details.We create an SSL instance for this connection and create two Basic I/O instances that reside in memory. One for the incoming stream and one for the outgoing stream. We&#x2019;ll be using them to pass data through the OpenSSL encryption, negotiation, etc. We also mark this as a server instance. Once that is done, we invoke the connection_established() callback and then tell the libuv event loop to start pumping data from this socket to the handle_read() callback. For now, I want to ignore the connection_established() callback, it isn&#x2019;t important to understand the flow of the code at this point (but we&#x2019;ll circle back to it). It is important to understand that by the time we call to this callback, the connection is ready to use and can receive and send data. Well, not receive, because we don&#x2019;t provide a way to pull data from the connection, we&#x2019;ll be pushing that data to the provided callback. This will happen by libuv calling to the handle_read() method whenever there is data on the socket. Here is how we handle this:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void handle_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = client-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_write(state-&gt;read, buf-&gt;base, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (1)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int rc = SSL_read(state-&gt;ssl, buf-&gt;base, buf-&gt;len);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc &lt;= 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;state-&gt;server-&gt;protocol.connection_closed(state, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// need to read more, we&#x27;ll let libuv handle this&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (state-&gt;server-&gt;protocol.read(state, buf-&gt;base, rc) == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// protocol asked to close the socket&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(buf-&gt;base);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          handle_read.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;When libuv calls us with some data, we write this data into the read buffer for OpenSSL and then call SSL_read() to get the unencrypted data that was sent to us. There are some issues here. First, the SSL/TLS has framing, and the amount of data that your read from the network isn&#x2019;t going to be the amount of unencrypted bytes that you get in the end. Another issue is that we need to be careful about re-negotiations, which are generally permitted at any point, but can cause a read to do a write (and may require a write to read).You might have noticed that this code contains absolutely no indication of this. Instead, we call SSL_read() to get the plaintext data from OpenSSL. We continue to do this until we get an error from SSL_read(). This can be either a real error or an indication that we need to read more from the network. Whenever I get some bytes from OpenSSL, I pass them directly to the read() callback that was provided to us. If you examine the code carefully, you&#x2019;ll see that when we run out of data to read, we try to flush the SSL state of the connection. Let&#x2019;s look at what that method do:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void maybe_flush_ssl(tls_uv_connection_state_t* state) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (state-&gt;pending.in_queue)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (BIO_pending(state-&gt;write) == 0 &amp;&amp; state-&gt;pending.pending_writes_count &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.next = state-&gt;server-&gt;pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (state-&gt;pending.next != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;pending.next-&gt;pending.prev_holder = &amp;state-&gt;pending.next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.prev_holder = &amp;state-&gt;server-&gt;pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.in_queue = 1;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;server-&gt;pending_writes = state;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          maybe_flush_ssl.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We check if the connection is already in the queue and if it isn&#x2019;t we check whatever it should be added. There are two reasons why a connection should be added to the pending_writes queue. First, we may have data buffered in the write buffer of the SSL connection, which needs to be sent over the network. Or, we may have failed writes that we need to retry after we read more data into the SSL connection.You might notice that we are doing some pointer hopping in the process of registering the connection in the queue. This is basically using a double linked list and will be important later. If we are putting stuff into a queue, what is going to be reading from this queue?Remember that when we setup the libuv stuff, we used the after_io prepare handle? This is called as the first step in the loop, just before we check if there is any I/O to process. This give us the chance to deal with the confusing read on write and write on read nature of OpenSSL in a more structure manner. Let&#x2019;s first look at the code, and then see how this all play together.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void complete_write(uv_write_t* r, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = r-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(r-&gt;write_buffer.base);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(r);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;server-&gt;protocol.connection_closed(state, status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void flush_ssl_buffer(tls_uv_connection_state_t* cur) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = BIO_pending(cur-&gt;write);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_buf_t buf = uv_buf_init(malloc(rc), rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;BIO_read(cur-&gt;write, buf.base, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_write_t* r = calloc(1, sizeof(uv_write_t));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;r-&gt;data = cur;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_write(r, (uv_stream_t*)cur-&gt;handle, &amp;buf, 1, complete_write);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          write.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is what actually handle writing to the network. We take data from the SSL write buffer and send it to the network. Once the write is done, we free buffers that were held for this operation and check if there was any issue with the write (if so, we abort the connection). This is all being driven by this method, which is called before we check for available I/O.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void check_if_need_to_flush_ssl_state(uv_prepare_t* handle) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_server_state_t* server_state = handle-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t** head = &amp;server_state-&gt;pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (*head != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t* cur = *head;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;flush_ssl_buffer(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (cur-&gt;pending.pending_writes_count == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;remove_connection_from_queue(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// here we have pending writes to deal with, so we&#x27;ll try stuffing them&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// into the SSL buffer&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int used = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;for (size_t i = 0; i &lt; cur-&gt;pending.pending_writes_count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;int rc = SSL_write(cur-&gt;ssl,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_buffer[i].base,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_buffer[i].len);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;used&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;rc = SSL_get_error(cur-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc == SSL_ERROR_WANT_WRITE) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;flush_ssl_buffer(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;i--;// retry&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;server_state-&gt;protocol.connection_closed(cur, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;abort_connection_on_error(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.in_queue = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// we are waiting for reads from the network&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// we can&#x27;t remove this instance, so we play&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// with the pointer and start the scan/remove &#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// from this position&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;head = &amp;cur-&gt;pending.next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;flush_ssl_buffer(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (used == cur-&gt;pending.pending_writes_count) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;remove_connection_from_queue(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;else {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_count -= used;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;memmove(cur-&gt;pending.pending_writes_buffer,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_buffer &#x2B; sizeof(uv_buf_t)*used,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;sizeof(uv_buf_t) * cur-&gt;pending.pending_writes_count);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          check_if_need_to_flush_ssl_state.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is quite a lot that is going on in here. First, we iterate through the pending writes for all the connections we have. For each of the connections, we flush the SSL buffer and then check if we have pending writes to process. If we don&#x2019;t, we can remove the connection from the queue, our work is done. If we do have any pending writes, we need to handle them.I do that by using SSL_write(), which will write them into in memory buffer. I continue doing so until one of the following happens:I run out of pending writes.I run out of buffer space and need to flush.I need to re-negotiate and need to read from the networkIn the first case, I&#x2019;ve successfully pushed the data to the SSL buffer, so I can call flush_ssl_buffer() and then remove the connection from the queue. In the second case, I&#x2019;ll flush the SSL write buffer and try again.However, in the last case, I&#x2019;m just aborting the writes. I need to do a read, and that will be handled on the next iteration of the libuv loop. There is some bookkeeping there to make sure that if we successfully wrote data into the SSL buffer, we won&#x2019;t be writing that again, but this is pretty much it. You&#x2019;ll note that I&#x2019;m playing games with pointers to pointers there to get clean code on the code that consumes the queue but allow me to skip one of the steps in the linked list without removing it from the list. This is pretty much it, I have to say. We now have a system where both writes and reads work in conjunction to get the proper SSL behavior, even when we have renegotiation going on.One thing you&#x2019;ll not find in this code is a call to SSL_accept(), or indeed any behavior related to explicitly managing the SSL state. I&#x2019;m letting OpenSSL handle all of that are rely on the fact that I SSL_write() and SSL_read() will handle renegotiations on their own for me.Let&#x2019;s do a simple walk through of what is going on with the connection of the TLS echo server.On connection established (and before we read anything from the network), we call to connection_write():&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          int connection_write(tls_uv_connection_state_t* state, void* buf, int size) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = SSL_write(state-&gt;ssl, buf, size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc == SSL_ERROR_WANT_WRITE) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;flush_ssl_buffer(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;rc = SSL_write(state-&gt;ssl, buf, size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;server-&gt;protocol.connection_closed(state, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;// we need to re negotiate with the client, so we can&#x27;t accept the write yet&#xA;        &#xA;        &#xA;          &#xA;          &#x9;// we&#x27;ll copy it to the side for now and retry after the next read&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_buf_t copy = uv_buf_init(malloc(size), size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;memcpy(copy.base, buf, size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.pending_writes_count&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.pending_writes_buffer = realloc(state-&gt;pending.pending_writes_buffer,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;sizeof(uv_buf_t) * state-&gt;pending.pending_writes_count);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.pending_writes_buffer[state-&gt;pending.pending_writes_count - 1] = copy;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          connection_write.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is fairly straightforward. We try to write to the buffer, and if we are successful, great. The check_if_need_to_flush_ssl_state() will take care of actually sending that to the client.If the write buffer is full, we empty it and try again. The interesting thing happen when we need to read in order to complete this write. In this case, we copy the data to write and store it on the side, then we proceed normally and wait or the libuv to deliver the next read buffer for this connection. When that is done, we&#x2019;ll be sending the deferred write to the client.It may be easier to explain the flow with a real example. When a new connection comes into the server, we create a new SSL context and then we call:connection_write(connection, &quot;OK\r\n&quot;, 4);This is the very first time that we actually interacts with the SSL instance and the call to SSL_write() is going to fail (because we haven&#x2019;t established the SSL connection) with a SSL_ERROR_WANT_READ message. In response for this, we&#x2019;ll copy the buffer we got and place it into the pending_writes of this connection. We also start listening to new data on the connection. The client will send the ClientHello message, which we&#x2019;ll read and then feed into the SSL instance. That will cause us to write the SeverHello to the in memory buffer. When the check_if_need_to_flush_ssl_state() will be called, it will flush that message to the client. Eventually, we&#x2019;ll get the connection established and at this point we&#x2019;ll be sending the deferred write to the client.There are a bunch of other details, but they aren&#x2019;t crucial to understanding this approaching. You can find the whole code sample here. I&#x2019;ll reiterate again that it doesn&#x2019;t have proper error handling, but it is less than 350 lines of C code that does something that is quite nice and expose an API that should be quite interesting to consume. I&#x2019;m really interested in feedback on this blog post, both on whatever this approach make any sense and what do you think about the code.</p>
        </article>
        <article id="article-1869">
            <a href="https://ardalis.com/analyzing-404s-with-google-analytics/" target="_blank">
                <h2 class="title mb-6" id="article-1869">Analyzing 404s with Google Analytics</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x27;ve been wanting to analyze broken links coming into my site so that I could add 301 redirects if necessary. I figured I could probably use&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-1870">
            <a href="https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/" target="_blank">
                <h2 class="title mb-6" id="article-1870">Why is string.GetHashCode() different each time I run my program in .NET Core?</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I discuss string.GetHashCode(), why it&#x27;s randomised, and hash-attacks. I also provide a deterministic implementation you can use when it&#x27;s safe.&#x2026;</p>
        </article>
        <div class="button flex justify-between">
            <a href="186.html"><span class="back arrow"></span></a>

            <a href="188.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>