
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 377 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-3761">
            <a href="https://ayende.com/blog/165857/reviewing-etcd" target="_blank">
                <h2 class="title mb-6" id="article-3761">Reviewing etcd</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 07, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The etcd project is a project that I stumbled upon that looks interesting. It is a a highly-available key value store for shared configuration and service discovery. It is written in Go and is implemented using Raft. I&#x2019;m reviewing commit&#xA0; 46d817f91b2edf4141081abff7d92a4f71d39248. I don&#x2019;t know Go, and I think that this would be a great way to learn both about Raft (which I am very interested about) and about Go (which I peeked at occasionally, but never really studied). Like some of my other posts, this is likely to be a very long and rambling one. For reading the code, I am using LiteIDE, at least for now. This is what this looks like.  I usually like to do a lexicographical read through the codebase, at least at first. That means that in this case, I have to go through the docs first. Probably not a totally bad idea, but a divergence from my usual approach. Discovery &#x2013; it looks like etcd handled the problem of initial peers selection by&#x2026; going to another etcd cluster, that handle membership information. There is a SaaS offering, it appears (discovery.etcd.io). I like the recursive nature of that, and obviously you can set it up with a static list of peers to start with. The first real code file I saw was this one, bench.go:      1: package main   2:&#xA0;    3: import (   4:     &quot;flag&quot;   5:     &quot;log&quot;   6:     &quot;strconv&quot;   7:&#xA0;    8:     &quot;github.com/coreos/etcd/third_party/github.com/coreos/go-etcd/etcd&quot;   9: )  10:&#xA0;   11: func write(endpoint string, requests int, end chan int) {  12:     client := etcd.NewClient([]string{endpoint})  13:&#xA0;   14:     for i := 0; i &lt; requests; i&#x2B;&#x2B; {  15:         key := strconv.Itoa(i)  16:         _, err := client.Set(key, key, 0)  17:         if err != nil {  18:             println(err.Error())  19:         }  20:     }  21:     end &lt;- 1  22: }  23:&#xA0;   24: func watch(endpoint string, key string) {  25:     client := etcd.NewClient([]string{endpoint})  26:&#xA0;   27:     receiver := make(chan *etcd.Response)  28:     go client.Watch(key, 0, true, receiver, nil)  29:&#xA0;   30:     log.Printf(&quot;watching: %s&quot;, key)  31:&#xA0;   32:     received := 0  33:     for {  34:         &lt;-receiver  35:         received&#x2B;&#x2B;  36:     }  37: }  38:&#xA0;   39: func main() {  40:     endpoint := flag.String(&quot;endpoint&quot;, &quot;http://127.0.0.1:4001&quot;, &quot;etcd HTTP endpoint&quot;)  41:&#xA0;   42:     rWrites := flag.Int(&quot;write-requests&quot;, 50000, &quot;number of writes&quot;)  43:     cWrites := flag.Int(&quot;concurrent-writes&quot;, 500, &quot;number of concurrent writes&quot;)  44:&#xA0;   45:     watches := flag.Int(&quot;watches&quot;, 500, &quot;number of writes&quot;)  46:&#xA0;   47:     flag.Parse()  48:&#xA0;   49:     for i := 0; i &lt; *watches; i&#x2B;&#x2B; {  50:         key := strconv.Itoa(i)  51:         go watch(*endpoint, key)  52:     }  53:&#xA0;   54:     wChan := make(chan int, *cWrites)  55:     for i := 0; i &lt; *cWrites; i&#x2B;&#x2B; {  56:         go write(*endpoint, (*rWrites / *cWrites), wChan)  57:     }  58:&#xA0;   59:     for i := 0; i &lt; *cWrites; i&#x2B;&#x2B; {  60:         &lt;-wChan  61:         log.Printf(&quot;Completed %d writes&quot;, (*rWrites / *cWrites))  62:     }  63: }&#xA;I include the entire file here because it is short, and really quite interesting. This is my first time really reading Go code, so I had to go and read some docs. The first interesting thing is in line 11, when when have &#x201C;end chan int&#x201D;, which defines a channel of integers. This allows cross goroutine (for .NET guys, think tasks / TPL, that isn&#x2019;t actually accurate, but it is close enough) communication, including &#x201C;waiting&#x201D; for results.&#xA;The write func will write the specified number of requests, then push a number to the channel, signifying that it completed its work. That is really quite nice pattern for doing work, considering that there isn&#x2019;t a way to await a goroutine.&#xA;The watch func is a little hard for me to get. Mostly because as far as I understand, it is setting up a watch for a particular key, then just accumulate the number of changes to it in a local variable, and not doing anything else with it.&#xA;The main function is really funny to read. The flag package is fascinating way to handle parameter parsing, and it shows how carefully Go was meant to be a server side language, where command line parsing is really common. The flag package is both powerful and really simple. I think that I&#x2019;ll probably make use of this approach for configuration in RavenDB.&#xA;I love that you define the flag, and then you get a pointer to where that value will be, once you called flag.Parse();&#xA;Note that calls to go [expr] are equivalent for Task.Factory.StartNew([expr]) in .NET (not really, but close enough). The syntax &lt;-wChan, for example, means &#x201C;wait until there is a new value in the channel&#x201D;. Presumably it also translate to something like &#x201C;await channel.DequeueAsync()&#x201D; in C#.&#xA;Next was the config package, where etcd is initializing itself. It was interesting to learn that you can have non global flags using the flag package, so you can use the same code for parsing arguments to a method. But that was about it. Nothing exciting there.&#xA;I&#x2019;m skipping the contrib directory because there is no Go code there, and it doesn&#x2019;t seems relevant for now. I&#x2019;ll note that there is a mix of shell scripts, Python and json code in there, so I&#x2019;m feeling good about ignoring that for now.&#xA;One thing that I really like in Go is that it is very easy to define &#x201C;extension methods&#x201D;, in fact, you usually appear to define structs (data holders), and then you just define a function that takes this as the base argument, and you can call it using method syntax. That makes some things very natural and nice. And it also give you really nice separation between data &amp; behavior.&#xA;I also like the multiple return values option, which gives us a good pattern for reporting errors without getting either crazy syntax or throwing. It also make it clear when we want to ignore errors. Look at this:&#xA;&#xA;&#xA;   1: func (d *Discoverer) findPeers() (peers []string, err error) {   2:     resp, err := d.client.Get(path.Join(d.prefix), false, true)   3:     if err != nil {   4:         return nil, err   5:     }   6:&#xA0;    7:     node := resp.Node   8:&#xA0;    9:     if node == nil {  10:         return nil, fmt.Errorf(&quot;%s key doesn&#x27;t exist.&quot;, d.prefix)  11:     }&#xA;Trying to do this in C, for example, would lead to an explosion of arrow head return values, or the complexities of &#x201C;return zero for error, then get the actual issue from GetLatsError()&#x201D;. Multiple return values results in a much nicer code than that.&#xA;The discovery protocol itself is defined in the docs ,but the code implementing it is really nice. Being able to piggy back on etcd itself to implement discovery is really nice.&#xA;The fixtures directory seems to be filled with certs files, I am not sure what for, but I&#x2019;ll go directly to the http directory and see what is going on there. And there doesn&#x2019;t appear to be anything much, so I&#x2019;m moving on to the next thing that is actually meaningful.&#xA;The metrics section is interesting, mostly because we have been doing the same thing in RavenDB currently. But it all depends on an external package, so I&#x2019;ll skip this for now. The next interesting thing is in the mod folder, where we have the dashboard (html5 app, not interested for me) module, and the leader &amp; lock modules.&#xA;I&#x2019;ll start with the leader module. Where we actually have interesting things. The leader module is actually very literally just proxying stuff to the lock module. It is getting a request, translating that request to a lock module http request, and execute that. Personally, I wouldn&#x2019;t bother with doing this server side, and handle this entirely client side, or by calling the lock module methods directly, instead of proxying the request to the lock module. I am not sure why this approach was choosen:&#xA;&#xA;&#xA;   1: // getHandler retrieves the current leader.   2: func (h *handler) getHandler(w http.ResponseWriter, req *http.Request) error {   3:     vars := mux.Vars(req)   4:&#xA0;    5:     // Proxy the request to the lock service.   6:     url := fmt.Sprintf(&quot;%s/mod/v2/lock/%s?field=value&quot;, h.addr, vars[&quot;key&quot;])   7:     resp, err := h.client.Get(url)   8:     if err != nil {   9:         return err  10:     }  11:     defer resp.Body.Close()  12:&#xA0;   13:     w.WriteHeader(resp.StatusCode)  14:     io.Copy(w, resp.Body)  15:     return nil  16: }&#xA;The lock module is where real stuff is happening. And at the same time, I am not sure at what level exactly this is happening. What appears to be happening is that the lock module, too, is built directly on top of the etcd client, rather than using it directly. This is strange to me, because that isn&#x2019;t the way I would architect it, but I am guessing that this make it easier to work with things, having only a single real external API. On the other hand, having a server make http requests to itself seems very strange to me.&#xA;One thing that really confused me was a lot of references to things that are actually defined in another repository, the client side of etcd in go. Another interesting thing is the way Go implements interfaces. Instead of using explicit interfaces, if a type has all the methods for an interface, it is implementing that interface.&#xA;At this point I decided that I wanted a better IDE and spent some time getting IntelliJ to work with Go. It supports this, and you even get some reference tracking. I couldn&#x2019;t get all of it to work, in particular, external reference weren&#x2019;t tracked, and I didn&#x2019;t really care to see why, so I just left it:&#xA;&#xA;&#xA;At any rate, I was reading the lock module code. In particular, I am not tracking the acquire_handler.go file. It has a major function (acquireHandler)* that actually handle the process of acquiring the lock.&#xA;&#xA;* Sidenote, I like the structure of the code so far, in most files, we have one function, and some supporting functions to help it do some work. It is nice, simple and quite easy to follow.&#xA;The first thing that is done is syncing the cluster information. This is done by going to any of the machines that we already know about and asking them about the current state of the cluster. We take the first response, and presumably, since we are running server side, the first response would always be from us (assuming that the requests end up going to the leader). So there isn&#x2019;t another machine boundary request, but it is still very strange to read it going through so much client operations.&#xA;This code is really interesting:&#xA;&#xA;&#xA;   1:&#xA0;    2:     // Setup connection watcher.   3:     closeNotifier, _ := w.(http.CloseNotifier)   4:     closeChan := closeNotifier.CloseNotify()   5:     stopChan := make(chan bool)&#xA;In C#, that would be setting up a cancellation token for the request being abandoned by the client or we completing some work.&#xA;&#xA;&#xA;   1: // If node exists then just watch it. Otherwise create the node and watch it.              2: node, index, pos := h.findExistingNode(keypath, value)                                     3: if index &gt; 0 {                                                                             4:     if pos == 0 {                                                                             5:         // If lock is already acquired then update the TTL.                                      6:         h.client.Update(node.Key, node.Value, uint64(ttl))                                       7:     } else {                                                                                  8:         // Otherwise watch until it becomes acquired (or errors).                                9:         err = h.watch(keypath, index, nil)                                                      10:     }                                                                                        11: } else {                                                                                  12:     index, err = h.createNode(keypath, value, ttl, closeChan, stopChan)                      13: }                                                                                       &#xA;This is interesting, I am not really able to follow what is going on in the happen case (index &gt; 0) yet. Let us lock at what happens with createNode&#x2026;&#xA;&#xA;&#xA;   1: // createNode creates a new lock node and watches it until it is acquired or acquisition fails.   2: func (h *handler) createNode(keypath string, value string, ttl int, closeChan &lt;-chan bool, stopChan chan bool) (int, error) {   3:     // Default the value to &quot;-&quot; if it is blank.   4:     if len(value) == 0 {   5:         value = &quot;-&quot;   6:     }   7:&#xA0;    8:     // Create an incrementing id for the lock.   9:     resp, err := h.client.AddChild(keypath, value, uint64(ttl))  10:     if err != nil {  11:         return 0, err  12:     }  13:     indexpath := resp.Node.Key  14:     index, _ := strconv.Atoi(path.Base(indexpath))  15:&#xA0;   16:     // Keep updating TTL to make sure lock request is not expired before acquisition.  17:     go h.ttlKeepAlive(indexpath, value, ttl, stopChan)  18:&#xA0;   19:     // Watch until we acquire or fail.  20:     err = h.watch(keypath, index, closeChan)  21:&#xA0;   22:     // Check for connection disconnect before we write the lock index.  23:     if err != nil {  24:         select {  25:         case &lt;-closeChan:  26:             err = errors.New(&quot;user interrupted&quot;)  27:         default:  28:         }  29:     }  30:&#xA0;   31:     // Update TTL one last time if acquired. Otherwise delete.  32:     if err == nil {  33:         h.client.Update(indexpath, value, uint64(ttl))  34:     } else {  35:         h.client.Delete(indexpath, false)  36:     }  37:&#xA0;   38:     return index, err  39: }&#xA;In line 9, we create a child of the key path. Assuming that the key path is foo, this will create an item with foo/1, foo/2, etc. Effectively an auto incrementing number (with no guarantees on the size of the step, mind).&#xA;In line 17 we make sure that we keep this alive, the ttlKeepAlive function is really fun to read:&#xA;&#xA;&#xA;   1: // ttlKeepAlive continues to update a key&#x27;s TTL until the stop channel is closed.   2: func (h *handler) ttlKeepAlive(k string, value string, ttl int, stopChan chan bool) {   3:     for {   4:         select {   5:         case &lt;-time.After(time.Duration(ttl/2) * time.Second):   6:             h.client.Update(k, value, uint64(ttl))   7:         case &lt;-stopChan:   8:             return   9:         }  10:     }  11: }&#xA;The C# translation for this would be:&#xA;&#xA;&#xA;   1: public async Task TtlKeepAlive(string k, string value, int ttl, CancelationToken t)   2: {   3:     while(true)   4:     {   5:         await Task.Delay(ttl, t);   6:         if(t.IsCancelled)   7:           return;   8:         client.Update(k,value, ttl);   9:&#xA0;   10:     }  11: }&#xA;But I really like this Go select syntax. It is very much like Erlang&#x2019;s pattern matching on receive. At any rate, it seems that the magic happens in the watch method. &#xA;&#xA;&#xA;   1: // watch continuously waits for a given lock index to be acquired or until lock fails.   2: // Returns a boolean indicating success.   3: func (h *handler) watch(keypath string, index int, closeChan &lt;-chan bool) error {   4:     // Wrap close chan so we can pass it to Client.Watch().   5:     stopWatchChan := make(chan bool)   6:     stopWrapChan := make(chan bool)   7:     go func() {   8:         select {   9:         case &lt;-closeChan:  10:             stopWatchChan &lt;- true  11:         case &lt;- stopWrapChan:  12:             stopWatchChan &lt;- true  13:         case &lt;- stopWatchChan:  14:         }  15:     }()  16:     defer close(stopWrapChan)  17:&#xA0;   18:     for {  19:         // Read all nodes for the lock.  20:         resp, err := h.client.Get(keypath, true, true)  21:         if err != nil {  22:             return fmt.Errorf(&quot;lock watch lookup error: %s&quot;, err.Error())  23:         }  24:         nodes := lockNodes{resp.Node.Nodes}  25:         prevIndex := nodes.PrevIndex(index)  26:&#xA0;   27:         // If there is no previous index then we have the lock.  28:         if prevIndex == 0 {  29:             return nil  30:         }  31:&#xA0;   32:         // Watch previous index until it&#x27;s gone.  33:         waitIndex := resp.Node.ModifiedIndex  34:&#xA0;   35:         // Since event store has only 1000 histories we should use first node&#x27;s CreatedIndex if available  36:         if firstNode := nodes.First(); firstNode != nil {  37:             waitIndex = firstNode.CreatedIndex  38:         }  39:&#xA0;   40:         _, err = h.client.Watch(path.Join(keypath, strconv.Itoa(prevIndex)), waitIndex, false, nil, stopWatchChan)  41:         if err == etcd.ErrWatchStoppedByUser {  42:             return fmt.Errorf(&quot;lock watch closed&quot;)  43:         } else if err != nil {  44:             return fmt.Errorf(&quot;lock watch error: %s&quot;, err.Error())  45:         }  46:     }  47: }&#xA;I&#x2019;ve to admit, this makes my head hurt, just a little bit.&#xA;But first, the defer syntax Go has is really nice. It is very similar to C#&#x2019;s using statements, but it isn&#x2019;t limited to just a specific interface, and it doesn&#x2019;t introduce a nesting block.&#xA;To go routine in line 7 is interesting. It will wait for a notification from the close channel, the stop watch channel or the wrap channel. And it will forward all of those to the stop watch channel. I&#x2019;m really not sure why this is the case, but let&#x2019;s go with this for now.&#xA;The real interesting work happens in the for loop. We get all the keys in the specified key path. Note that we assume that we only have numeric keys in that &#x201C;directory&#x201D;. And we basically try to find if there is any value that is before our value.&#xA;The easiest way to think about it is in the same way you do when you wait in line in any government queue. You take a number, and you&#x2019;re the first is there is no one with an earlier number than you.&#xA;The interesting bit is how Watch is handled. It is basically going to do a long poll request from the server, and the stopWatchChan is used to notify the Watch method when the user cancelled the request, so we don&#x2019;t need this any longer. I&#x2019;m really not sure why there is a need for stopWrapChan, but&#x2026; at least now I understand what is going on here. We use the numbering system to effectively join a queue. Then we wait until we are at the head of the queue. &#xA;Let us go back to the actual acuireHandler routine, more specifically to the findExistingNode() behavior. If we specified a value, we try to find an existing entry in the path that already have this value. If there isn&#x2019;t a value, we go back to the &#x201C;take a number, wait&#x201D; approach. If there is a value, however, I don&#x2019;t following the logic. The findExistingNode() has three return values. The relevant node with the value, the index (the queue #, effectively), and the position of the specified node in the queue.&#xA;My problem is that I don&#x2019;t understand the logic here. We find a node with the same value as we want, then we check that it is the first in the queue? What happens when we have two clients issuing the same request at the same time? I understand what happens, I don&#x2019;t understand what the intention is.&#xA;As an aside, I think that I understand why a lot of the internal works in the lock module is done over the HTTP layer. The idea here is to only handle the distribution once. And if you route everything through the http interface, that would be it. This way, you don&#x2019;t have to worry about how to handle consistencies, or stuff like that. And the idea is that you have a simple HTTP interface for a complex system like locking. My own preference would be to do this entirely client side, with no server side behavior, but that puts a lot of the onus on the clients, and it is easier to implement server side if you have a lot of clients for many environments.&#xA;Anyway, I think that I found the two pieces that really interests me:&#xA;&#xA;&#xA0;&#xA;Store is probably the on disk storage, something that is very near &amp; dear to my heart. While server is the pieces that I&#x2019;ll probably learn the most from&#x2026;&#xA;I&#x2019;ll start with going over the storage stuff, since that is probably the most familiar to me. Here is the interface for the store:&#xA;&#xA;&#xA;   1: type Store interface {   2:     Version() int   3:     CommandFactory() CommandFactory   4:     Index() uint64   5:&#xA0;    6:     Get(nodePath string, recursive, sorted bool) (*Event, error)   7:     Set(nodePath string, dir bool, value string, expireTime time.Time) (*Event, error)   8:     Update(nodePath string, newValue string, expireTime time.Time) (*Event, error)   9:     Create(nodePath string, dir bool, value string, unique bool,  10:         expireTime time.Time) (*Event, error)  11:     CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,  12:         value string, expireTime time.Time) (*Event, error)  13:     Delete(nodePath string, recursive, dir bool) (*Event, error)  14:     CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error)  15:&#xA0;   16:     Watch(prefix string, recursive, stream bool, sinceIndex uint64) (*Watcher, error)  17:&#xA0;   18:     Save() ([]byte, error)  19:     Recovery(state []byte) error  20:&#xA0;   21:     TotalTransactions() uint64  22:     JsonStats() []byte  23:     DeleteExpiredKeys(cutoff time.Time)  24: }&#xA;This is really interesting, because from the interface alone you can see some really interesting things. For example, The Save() method. That doesn&#x2019;t match any transactional store interface that I can think of. To be fair, it looks to be more in the sense that this is used for snapshots than anything else, but still..&#xA;Those appear to be the core elements of the store:&#xA;&#xA;&#xA;   1: type store struct {                                                        2:     Root           *node                                                      3:     WatcherHub     *watcherHub                                                4:     CurrentIndex   uint64                                                     5:     Stats          *Stats                                                     6:     CurrentVersion int                                                        7:     ttlKeyHeap     *ttlKeyHeap  // need to recovery manually                  8:     worldLock      sync.RWMutex // stop the world lock                        9: }                                                                         10:&#xA0;   11:&#xA0;   12: // node is the basic element in the store system.  13: // A key-value pair will have a string value  14: // A directory will have a children map  15: type node struct {  16:     Path string  17:&#xA0;   18:     CreatedIndex  uint64  19:     ModifiedIndex uint64  20:&#xA0;   21:     Parent *node `json:&quot;-&quot;` // should not encode this field! avoid circular dependency.  22:&#xA0;   23:     ExpireTime time.Time  24:     ACL        string  25:     Value      string           // for key-value pair  26:     Children   map[string]*node // for directory  27:&#xA0;   28:     // A reference to the store this node is attached to.  29:     store *store  30: }&#xA;Again, the ability to return multiple values is really nice, see methods such as:&#xA;&#xA;&#xA;   1: // Read function gets the value of the node.   2: // If the receiver node is not a key-value pair, a &quot;Not A File&quot; error will be returned.   3: func (n *node) Read() (string, *etcdErr.Error) {   4:     if n.IsDir() {   5:         return &quot;&quot;, etcdErr.NewError(etcdErr.EcodeNotFile, &quot;&quot;, n.store.Index())   6:     }   7:&#xA0;    8:     return n.Value, nil   9: }&#xA;This is quite lovely way to handle things. &#xA;However, looking at the Store directory, I am seeing a lot of stuff about modifying the in memory state, but nothing about persistence. I think that this is all handled via Raft. So I&#x2019;ll just move away into reading the server side code now.&#xA;This is the Server interface:&#xA;&#xA;&#xA;   1: type Server interface {   2:     State() string   3:     Leader() string   4:     CommitIndex() uint64   5:     Term() uint64   6:     PeerURL(string) (string, bool)   7:     ClientURL(string) (string, bool)   8:     Store() store.Store   9:     Dispatch(raft.Command, http.ResponseWriter, *http.Request) error  10: }&#xA;And then we have actually handling requests. I choose to look at the simplest thing, just looking at how we process a read request:&#xA;&#xA;&#xA;   1: func GetHandler(w http.ResponseWriter, req *http.Request, s Server) error {   2:     vars := mux.Vars(req)   3:     key := &quot;/&quot; &#x2B; vars[&quot;key&quot;]   4:&#xA0;    5:     // Help client to redirect the request to the current leader   6:     if req.FormValue(&quot;consistent&quot;) == &quot;true&quot; &amp;&amp; s.State() != raft.Leader {   7:         leader := s.Leader()   8:         hostname, _ := s.ClientURL(leader)   9:&#xA0;   10:         url, err := url.Parse(hostname)  11:         if err != nil {  12:             log.Warn(&quot;Redirect cannot parse hostName &quot;, hostname)  13:             return err  14:         }  15:         url.RawQuery = req.URL.RawQuery  16:         url.Path = req.URL.Path  17:&#xA0;   18:         log.Debugf(&quot;Redirect consistent get to %s&quot;, url.String())  19:         http.Redirect(w, req, url.String(), http.StatusTemporaryRedirect)  20:         return nil  21:     }  22:&#xA0;   23:     recursive := (req.FormValue(&quot;recursive&quot;) == &quot;true&quot;)  24:     sort := (req.FormValue(&quot;sorted&quot;) == &quot;true&quot;)  25:     waitIndex := req.FormValue(&quot;waitIndex&quot;)  26:     stream := (req.FormValue(&quot;stream&quot;) == &quot;true&quot;)  27:&#xA0;   28:     if req.FormValue(&quot;wait&quot;) == &quot;true&quot; {  29:         return handleWatch(key, recursive, stream, waitIndex, w, s)  30:     }  31:&#xA0;   32:     return handleGet(key, recursive, sort, w, s)  33: }&#xA;If we are requiring consistency, and we aren&#x2019;t the leader, we&#x2019;ll forward to the leader. Otherwise, we&#x2019;ll process the request. Let us assume for now that we are doing a simple get, not a watch, this gives us:&#xA;&#xA;&#xA;   1: func handleGet(key string, recursive, sort bool, w http.ResponseWriter, s Server) error {   2:     event, err := s.Store().Get(key, recursive, sort)   3:     if err != nil {   4:         return err   5:     }   6:&#xA0;    7:     writeHeaders(w, s)   8:     b, _ := json.Marshal(event)   9:     w.Write(b)  10:     return nil  11: }  12:&#xA0;   13: func writeHeaders(w http.ResponseWriter, s Server) {  14:     w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)  15:     w.Header().Add(&quot;X-Etcd-Index&quot;, fmt.Sprint(s.Store().Index()))  16:     w.Header().Add(&quot;X-Raft-Index&quot;, fmt.Sprint(s.CommitIndex()))  17:     w.Header().Add(&quot;X-Raft-Term&quot;, fmt.Sprint(s.Term()))  18:     w.WriteHeader(http.StatusOK)  19: }&#xA;As you can see, we are basically just getting the current state from the in memory store, and handle that. It would be more interesting to look at how we handle waiting for a value to change, however:&#xA;&#xA;&#xA;   1: func handleWatch(key string, recursive, stream bool, waitIndex string, w http.ResponseWriter, s Server) error {   2:     // Create a command to watch from a given index (default 0).   3:     var sinceIndex uint64 = 0   4:     var err error   5:&#xA0;    6:     if waitIndex != &quot;&quot; {   7:         sinceIndex, err = strconv.ParseUint(waitIndex, 10, 64)   8:         if err != nil {   9:             return etcdErr.NewError(etcdErr.EcodeIndexNaN, &quot;Watch From Index&quot;, s.Store().Index())  10:         }  11:     }  12:&#xA0;   13:     watcher, err := s.Store().Watch(key, recursive, stream, sinceIndex)  14:     if err != nil {  15:         return err  16:     }  17:&#xA0;   18:     cn, _ := w.(http.CloseNotifier)  19:     closeChan := cn.CloseNotify()  20:&#xA0;   21:     writeHeaders(w, s)  22:&#xA0;   23:     if stream {  24:         // watcher hub will not help to remove stream watcher  25:         // so we need to remove here  26:         defer watcher.Remove()  27:         for {  28:             select {  29:             case &lt;-closeChan:  30:                 return nil  31:             case event, ok := &lt;-watcher.EventChan:  32:                 if !ok {  33:                     // If the channel is closed this may be an indication of  34:                     // that notifications are much more than we are able to  35:                     // send to the client in time. Then we simply end streaming.  36:                     return nil  37:                 }  38:&#xA0;   39:                 b, _ := json.Marshal(event)  40:                 _, err := w.Write(b)  41:                 if err != nil {  42:                     return nil  43:                 }  44:                 w.(http.Flusher).Flush()  45:             }  46:         }  47:     }  48:&#xA0;   49:     select {  50:     case &lt;-closeChan:  51:         watcher.Remove()  52:     case event := &lt;-watcher.EventChan:  53:         b, _ := json.Marshal(event)  54:         w.Write(b)  55:     }  56:     return nil  57: }&#xA;The store&#x2019;s Watch() method is actually interesting, because it exposes some interesting Go concepts (handling full channels, channels for communications, etc). But the important thing is that this will simply wait for a change to happen in the in memory state, and when such a thing happens, it will put a value in the wathcer.EventChan channel. So the logic here goes like this:&#xA;&#xA;Setup a watch on the in memory state. &#xA;Wait for a: &#xA;&#xA;Change in the items we watch &#xA;Or user abandoning the request&#xA;There is some interesting stuff here regarding one time watch, or streaming watch, but that appears to be quite easy to figure out and follow what is going on.&#xA;One thing that I can tell you, from my own experience, is that I would actually expect this to have serious issues in productions. In particular, web servers can decide that this request takes too long, and just abort it (for example IIS behaves in this manner), or that it timed out. That obviously depends on the server side implementation, and I&#x2019;m willing to assume that this isn&#x2019;t the case for whatever http stack etcd uses. However, clients do not. Most clients would give you the benefit of the doubt, but they would abort the request after a while, usually 15 seconds. That might be okay for some purposes, but especially if you want to handling streaming, that isn&#x2019;t really going to cut it.&#xA;More to the point, for long requests, this can cause issues for proxies, firewalls, etc. They&#x2019;ll decide that the request is closed, and shut it down even if you handled it on both ends properly. With RavenDB, we have a remarkably similar system, but our streaming notifications also incorporate the idea of heartbeat messages. Those are sent every now and then strictly in order to make sure that you&#x2019;ll get something client side, and that will make all the infrastructure, client side code, etc much much happier.&#xA;Enough with the small stuff, let us look at how we handle more complex things. I now intend to take a look at the POST handler. POST operations in etcd has the following format:&#xA;&#xA;curl http://127.0.0.1:4001/v2/keys/queue -XPOST -d value=Job1 &#xA;The idea is that this will create an automatically named key such as queue/15, queue/853, etc. The POST handler is interesting, because here it is in its entirety.&#xA;&#xA;&#xA;   1:&#xA0;    2: func PostHandler(w http.ResponseWriter, req *http.Request, s Server) error {   3:     vars := mux.Vars(req)   4:     key := &quot;/&quot; &#x2B; vars[&quot;key&quot;]   5:&#xA0;    6:     value := req.FormValue(&quot;value&quot;)   7:     dir := (req.FormValue(&quot;dir&quot;) == &quot;true&quot;)   8:     expireTime, err := store.TTL(req.FormValue(&quot;ttl&quot;))   9:     if err != nil {  10:         return etcdErr.NewError(etcdErr.EcodeTTLNaN, &quot;Create&quot;, s.Store().Index())  11:     }  12:&#xA0;   13:     c := s.Store().CommandFactory().CreateCreateCommand(key, dir, value, expireTime, true)  14:     return s.Dispatch(c, w, req)  15: }&#xA;The CreateCreateCommand just create a data object that holds the parameters, and then we dispatch it. I&#x2019;m thinking that we can learn quite a lot from how that works.&#xA;Dispatch merely send the command to the leader. This is the relevant code if we are not the leader:&#xA;&#xA;&#xA;   1: leader := ps.raftServer.Leader()                                            2:                                                                             3: // No leader available.                                                     4: if leader == &quot;&quot; {                                                           5:     return etcdErr.NewError(300, &quot;&quot;, s.Store().Index())                        6: }                                                                           7:                                                                             8: var url string                                                              9: switch c.(type) {                                                          10: case *JoinCommand, *RemoveCommand:                                         11:     url, _ = ps.registry.PeerURL(leader)                                      12: default:                                                                   13:     url, _ = ps.registry.ClientURL(leader)                                    14: }                                                                          15: uhttp.Redirect(url, w, req)                                                16:                                                                            17: return nil                                                               &#xA;So basically, if there isn&#x2019;t a leader, we error. That can happen if we have a network split and we are in the minority portion, for example. But usually we&#x2019;ll just redirect you to the right server to use. But here is the interesting part, where we are the leader, and get to do stuff:&#xA;&#xA;&#xA;   1: result, err := ps.raftServer.Do(c)   2: if err != nil {   3:     return err   4: }   5:&#xA0;    6: if result == nil {   7:     return etcdErr.NewError(300, &quot;Empty result from raft&quot;, s.Store().Index())   8: }   9:&#xA0;   10: // response for raft related commands[join/remove]  11: if b, ok := result.([]byte); ok {  12:     w.WriteHeader(http.StatusOK)  13:     w.Write(b)  14:     return nil  15: }  16:&#xA0;   17: var b []byte  18: if strings.HasPrefix(req.URL.Path, &quot;/v1&quot;) {  19:     b, _ = json.Marshal(result.(*store.Event).Response(0))  20:     w.WriteHeader(http.StatusOK)  21: } else {  22:     e, _ := result.(*store.Event)  23:     b, _ = json.Marshal(e)  24:&#xA0;   25:     w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)  26:     // etcd index should be the same as the event index  27:     // which is also the last modified index of the node  28:     w.Header().Add(&quot;X-Etcd-Index&quot;, fmt.Sprint(e.Index()))  29:     w.Header().Add(&quot;X-Raft-Index&quot;, fmt.Sprint(s.CommitIndex()))  30:     w.Header().Add(&quot;X-Raft-Term&quot;, fmt.Sprint(s.Term()))  31:&#xA0;   32:     if e.IsCreated() {  33:         w.WriteHeader(http.StatusCreated)  34:     } else {  35:         w.WriteHeader(http.StatusOK)  36:     }  37: }  38:&#xA0;   39: w.Write(b)  40:&#xA0;   41: return nil&#xA;The ps variable is something called a PeerServer, and I haven&#x2019;t check it yet. But all of this code is basically doing is: &#x201C;send this to raft to Do something about it, then reply to the caller&#x201D;. So let us look at what we are actually doing there. The Do method merely call the send() method, which looks like this:&#xA;&#xA;&#xA;   1: // Sends an event to the event loop to be processed. The function will wait   2: // until the event is actually processed before returning.   3: func (s *server) send(value interface{}) (interface{}, error) {   4:     event := &amp;ev{target: value, c: make(chan error, 1)}   5:     s.c &lt;- event   6:     err := &lt;-event.c   7:     return event.returnValue, err   8: }&#xA;Personally, I think that this is very interesting, and again, very much like the way you would structure an Erlang system. Of particular interest is the idea of event loop. That would be the s.c channel, and I assume that this is meant for a separate goroutine that is processing work on top of that. We ended up with transaction merging in Voron using pretty much the same system.&#xA;The s.c channel is a channel of ev pointers. And ev is defined as:&#xA;&#xA;&#xA;   1:&#xA0;    2: // An internal event to be processed by the server&#x27;s event loop.   3: type ev struct {   4:     target      interface{}   5:     returnValue interface{}   6:     c           chan error   7: }&#xA;The interface{} definition it Go&#x2019;s System.Object, basically. And the error channel is there to mark when we are done processing the event, I assume. I would structure it so we can send a null error as completion, and I bet that this is how this is done.&#xA;I&#x2019;m currently assuming that this is being read from the loop() method. And while I usually don&#x2019;t just comment on comments, this one is really nice:&#xA;&#xA;&#xA;   1:&#xA0;    2: //--------------------------------------   3: // Event Loop   4: //--------------------------------------   5:&#xA0;    6: //               ________   7: //            --|Snapshot|                 timeout   8: //            |  --------                  ______   9: // recover    |       ^                   |      |  10: // snapshot / |       |snapshot           |      |  11: // higher     |       |                   v      |     recv majority votes  12: // term       |    --------    timeout    -----------                        -----------  13: //            |-&gt; |Follower| ----------&gt; | Candidate |--------------------&gt; |  Leader   |  14: //                 --------               -----------                        -----------  15: //                    ^          higher term/ |                         higher term |  16: //                    |            new leader |                                     |  17: //                    |_______________________|____________________________________ |&#xA;This comment promises an interesting function to read&#x2026;&#xA;&#xA;&#xA;   1:&#xA0;    2: func (s *server) loop() {   3:     defer s.debugln(&quot;server.loop.end&quot;)   4:&#xA0;    5:     for {   6:         state := s.State()   7:&#xA0;    8:         s.debugln(&quot;server.loop.run &quot;, state)   9:         switch state {  10:         case Follower:  11:             s.followerLoop()  12:&#xA0;   13:         case Candidate:  14:             s.candidateLoop()  15:&#xA0;   16:         case Leader:  17:             s.leaderLoop()  18:&#xA0;   19:         case Snapshotting:  20:             s.snapshotLoop()  21:&#xA0;   22:         case Stopped:  23:             s.stopped &lt;- true  24:             return  25:         }  26:     }  27: }&#xA;Let us start by looking at the leaderLoop behavior:&#xA;&#xA;&#xA;   1: func (s *server) leaderLoop() {   2:     s.setState(Leader)   3:     logIndex, _ := s.log.lastInfo()   4:&#xA0;    5:     // Update the peers prevLogIndex to leader&#x27;s lastLogIndex and start heartbeat.   6:     s.debugln(&quot;leaderLoop.set.PrevIndex to &quot;, logIndex)   7:     for _, peer := range s.peers {   8:         peer.setPrevLogIndex(logIndex)   9:         peer.startHeartbeat()  10:     }  11:&#xA0;   12:     // Commit a NOP after the server becomes leader. From the Raft paper:  13:     // &quot;Upon election: send initial empty AppendEntries RPCs (heartbeat) to  14:     // each server; repeat during idle periods to prevent election timeouts  15:     // (&#xA7;5.2)&quot;. The heartbeats started above do the &quot;idle&quot; period work.  16:     go s.Do(NOPCommand{})  17:&#xA0;   18:     // Begin to collect response from followers  19:     for s.State() == Leader {  20:         var err error  21:         select {  22:         case e := &lt;-s.c:  23:             if e.target == &amp;stopValue {  24:                 // Stop all peers before stop  25:                 for _, peer := range s.peers {  26:                     peer.stopHeartbeat(false)  27:                 }  28:                 s.setState(Stopped)  29:             } else {  30:                 switch req := e.target.(type) {  31:                 case Command:  32:                     s.processCommand(req, e)  33:                     continue  34:                 case *AppendEntriesRequest:  35:                     e.returnValue, _ = s.processAppendEntriesRequest(req)  36:                 case *AppendEntriesResponse:  37:                     s.processAppendEntriesResponse(req)  38:                 case *RequestVoteRequest:  39:                     e.returnValue, _ = s.processRequestVoteRequest(req)  40:                 }  41:             }  42:&#xA0;   43:             // Callback to event.  44:             e.c &lt;- err  45:         }  46:     }  47:&#xA0;   48:     s.syncedPeer = nil  49: }&#xA;To be perfectly frank, this is really code code. I am loving the structure here. It is really fun to go through and figure out. And the code follows really closely the Raft paper. And&#x2026; it appears that at some point I actually moved off the etcd code and into the go-raft codebase. I think that I&#x2019;ll skip doing the Raft stuff for this blog post. It is long enough already, and just focus on the etcd stuff for now.&#xA;The part that we really care for this blog post about is the processCommand call:&#xA;&#xA;&#xA;   1: // Processes a command.   2: func (s *server) processCommand(command Command, e *ev) {   3:     s.debugln(&quot;server.command.process&quot;)   4:&#xA0;    5:     // Create an entry for the command in the log.   6:     entry, err := s.log.createEntry(s.currentTerm, command, e)   7:&#xA0;    8:     if err != nil {   9:         s.debugln(&quot;server.command.log.entry.error:&quot;, err)  10:         e.c &lt;- err  11:         return  12:     }  13:&#xA0;   14:     if err := s.log.appendEntry(entry); err != nil {  15:         s.debugln(&quot;server.command.log.error:&quot;, err)  16:         e.c &lt;- err  17:         return  18:     }  19:&#xA0;   20:     s.syncedPeer[s.Name()] = true  21:     if len(s.peers) == 0 {  22:         commitIndex := s.log.currentIndex()  23:         s.log.setCommitIndex(commitIndex)  24:         s.debugln(&quot;commit index &quot;, commitIndex)  25:     }  26: }&#xA;In createEntry, we create effectively serialize the command into JSON, and appenEntry writes it to a file. (I finally found the serialize format, it is JSON for the commands, wrapped in a protobuf envelop). As an aside, if this was a C# code, I would be very worried about the cost of all those allocations. The data is first moved to a JSON buffer, then into a protocol buffer entry, where it is marshaled into another buffer, and only then is it written to the actual file. That is pretty prevalent in the codebase, to be honest. But again, this is Raft stuff that is going on, not etcd stuff. So we&#x2019;ll ignore this for now and try to see where we actually get to apply the command against our own internal state.&#xA;I had to go through some hoops to figure it out. In particular, commands are applied during recovery, or when we are actually committing the state following a quorum, and this is happening in the Log.ApplyFunc, which is setup externally, and&#x2026; Anyway, what we actually do is this:&#xA;&#xA;&#xA;   1: // Apply command to the state machine.                                    2: switch c := c.(type) {                                                    3: case CommandApply:                                                        4:     return c.Apply(&amp;context{                                                 5:         server:       s,                                                        6:         currentTerm:  s.currentTerm,                                            7:         currentIndex: s.log.internalCurrentIndex(),                             8:         commitIndex:  s.log.commitIndex,                                        9:     })                                                                      10: case deprecatedCommandApply:                                             11:     return c.Apply(s)                                                       12: default:                                                                 13:     return nil, fmt.Errorf(&quot;Command does not implement Apply()&quot;)            14: }                                                                      &#xA;And that goes all the way back to the CreateCommand&#x2019;s Apply function, which does:&#xA;&#xA;&#xA;   1: // Create node                                                                                         2: func (c *CreateCommand) Apply(context raft.Context) (interface{}, error) {                             3:     s, _ := context.Server().StateMachine().(store.Store)                                                 4:                                                                                                        5:     e, err := s.Create(c.Key, c.Dir, c.Value, c.Unique, c.ExpireTime)                                     6:                                                                                                        7:     if err != nil {                                                                                       8:         log.Debug(err)                                                                                       9:         return nil, err                                                                                     10:     }                                                                                                    11:                                                                                                       12:     return e, nil                                                                                        13: }                                                                                                     14:                                                                                                     &#xA;So, basically, we have Raft that does the hard work of getting a Quorum, persistence, etc.&#xA0; The etcd server is responsible for the in memory state, defining commands, etc.&#xA;The really interesting part from my perspective is that we need to process erroneous entries as well, in the same manner. For example, let us say that I want to create a new entry, but only if it isn&#x2019;t already there. The way it works, even though I know that this would be an error, I have to run this through Raft, get a consensus that we can apply this command, and then we apply the command, see that it is wrong, and return an error. That error leaves no state changes, but it still had to go through the Raft process, it is going to be in the log forever, etc. I&#x2019;m guessing that the percentage of erroneous commands is low, to be able to tolerate that. &#xA;And, at any rate. That pretty much conclude my review of etcd. It comes to about 20 pages or so, according to my math, and that is quite enough. On the other hand, it might have been 7 posts, instead. I would really like to get some feedback on which option you like more, dear reader.&#xA;Next, I&#x2019;m going to go over go-raft, I have some thoughts about this, but I&#x2019;ll keep them for my next post.&#xA;As a side note. I am not, by any means, an experience Go developer. I haven&#x2019;t even read Go code beyond Hello World before starting reading the etcd codebase. But I can tell you that this is a very nice codebase to look at. It is clear, nicely laid out, it is possible to go through everything and understand what is going on easily.</p>
        </article>
        <article id="article-3762">
            <a href="https://benfoster.io/blog/aspnet-identity-stripped-bare-mvc-part-1/" target="_blank">
                <h2 class="title mb-6" id="article-3762">ASP.NET Identity Stripped Bare - MVC Part 1</h2>
            </a>
            <p class="mb-2">by Ben Foster</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 07, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This post covers setting up cookie based authentication (the replacement for Forms Authentication) in ASP.NET MVC using the new ASP.NET Identity Libraries and nothing else.</p>
        </article>
        <article id="article-3763">
            <a href="https://ayende.com/blog/165794/usage-conventions-for-using-voron" target="_blank">
                <h2 class="title mb-6" id="article-3763">Usage conventions for using Voron</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 06, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">As we are gearing up to do more &amp; more stuff in Voron, it occurred to me that while we have settled on a good technological system for it, we haven&#x2019;t settled on a real set of conventions for real use. We&#x2019;re probably going to see a lot of use in Voron, and we want to see some consistency and best practices there. Voron is a key/value store that expose a sorted tree abstraction. You can have as many trees as you would like. And the keys &amp; values are both arbitrary byte strings. Given that, let us try to bring some order to the mix. Don&#x2019;t use the root tree The root tree should reserved for handling of other trees, and not for the use of data of any kind. The only case where using the root tree is fine is if you don&#x2019;t have any other trees. That tend to be a rare occasion, though. See next topic. Have a $metadata tree Always have a $metadata tree, that gives you information about the actual database you are using. For example, you&#x2019;ll want to have things like the storage version, the database id (always a guid, to be able to tell dbs from their backups), etc. Alpha numeric values only for tree names, please You can use any value as a tree name, but you really want to limit yourself to the printable ASCII set. This is recommended because dumping the data to any other format (think debugging) would be greatly enhanced if you can actually read the tree names. Use @tree for super trees It is very common to have trees where all their data is handled via MutiAdd, MultiRead, etc. We call such trees super trees (they are trees that contains trees, also see big table). While they are usually used for indexing, there are many cases where you want to do that for things like queues, general run of the meal data (this is great for holding edges in a graph, for example), etc. Prefix ix_ for all indexing trees I&#x2019;m not so sure about this, but it is worth mentioning. The purpose here is to distinguish between standard trees and trees that can be rebuild from scratch if needed. That can be of help in diagnostics mode, for example. Dynamic trees should be explained It is very easy to create trees in Voron. But like files, you don&#x2019;t just create some around for no purpose. A tree cost 4KB (minimum), and more importantly, if you are looking at your storage, you want to be able to make sense of things. If you are using a tree as a queue for a particular destination, make sure that you name it appropriately.  Alternatively, use the $metadata tree to keep track of what goes where. Avoid non printable key names Just like in tree names, you can use any byte string in a key name, but you want to be able to read debug data or run diagnostics, it would really help if you could actually look at the data . Remember, sequential writes are best Voron will deal with random writes just fine, but it would be far&#xA0; faster to write if you&#x2019;ll arrange things so they are sequential. It is fine if you have once in a while a random write. But try to keep things sequential if at all possible. On that node, sequential for us means increasing, all of our optimizations assumes that. Decreasing sequential data is currently not as optimized.  Write and end, delete at start This is a common operation you need for queues. It is generally better to do that with writing of the data at the end and removing from start. If you can, avoid just deleting stuff all over the place. Again, that works just fine, but we&#x2019;ve optimized Voron to handle this scenario very well. Keep the data simple Voron does a lot with memory mapping. If the data you can use can be read directly, you can literally just access it off our own buffer, and have no copy required at all. And that is all I have for now&#x2026;</p>
        </article>
        <article id="article-3764">
            <a href="https://www.meziantou.net/presentation-of-exportsrc.htm" target="_blank">
                <h2 class="title mb-6" id="article-3764">Presentation of ExportSrc</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 06, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">When you have to deliver sources to a customer or for a demo, it can be tedious. The folder containing the project contains temporary files, binary files, configuration files for various software, and so on. In addition, projects can be linked to a TFS server.ExportSrc tackles this problem:The GUI</p>
        </article>
        <article id="article-3765">
            <a href="https://ayende.com/blog/165793/distributed-counters-feature-design" target="_blank">
                <h2 class="title mb-6" id="article-3765">Distributed counters feature design</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 05, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This is another experiment with longer posts.  Previously, I used the time series example as the bed on which to test some ideas regarding feature design, to explain how we work and in general work out the rough patches along the way. I should probably note that these posts are purely fiction at this point. We have no plans to include a time series feature in RavenDB at this time. I am trying to work out some thoughts in the open and get your feedback. At any rate, yesterday we had a request for Cassandra style counters at the mailing list. And as long as I am doing feature design series, I thought that I could talk about how I would go about implementing this. Again, consider this fiction, I have no plans of implementing this at this time. The essence of what we want is to be able to&#x2026; count stuff. Efficiently, in a distributed manner, with optional support for cross data center replication. Very roughly, the idea is to have &#x201C;sub counters&#x201D;, unique for every node in the system. Whenever you increment the value, we log this to our own sub counter, and then replicate it out. Whenever you read it, we just sum all the data we have from all the sub counters. Let us outline the various parts of the solution in the same order as the one I used for time series. Storage  A counter is just a named 64 bits signed integer. A counter name can be any string up to 128 printable characters. The external interface of the storage would look like this:      1: public struct CounterIncrement   2: {   3:     public string Name;   4:     public long Change;   5: }   6:&#xA0;    7: public struct Counter   8: {   9:     public string Name;  10:     public string Source;  11:     public long Value;  12: }  13:&#xA0;   14: public interface ICounterStorage  15: {  16:     void LocalIncrementBatch(CounterIncrement[] batch);  17:&#xA0;   18:     Counter[] Read(string name);  19:&#xA0;   20:     void ReplicatedUpdates(Counter[] updates);  21: }&#xA;As you can see, this gives us very simple interface for the storage. We can either change the data locally (which modify our own storage) or we can get an update from a replica about its changes.&#xA;There really isn&#x2019;t much more to it, to be fair. The LocalIncrementBatch() increment a local value, and Read() will return all the values for a counter. There is a little bit of trickery involved in how exactly one would store the counter values.&#xA;For now, I think we&#x2019;ll store each counter as two step values. We&#x2019;ll have a tree of multi tree values that will carry each value from each source. That means that a counter will take roughly 4KB or so. This is easy to work with and nicely fit the model Voron uses internally.&#xA;Note that we&#x2019;ll outline additional requirement for storage (searching for counter by prefix, iterating over counters, addresses of other servers, stats, etc) below. I&#x2019;m not showing them here because they aren&#x2019;t the major issue yet.&#xA;Over the wire&#xA;Skipping out on any optimizations that might be required, we will expose the following endpoints:&#xA;&#xA;GET /counters/read?id=users/1/visits&amp;users/1/posts &lt;&#x2014;will return json response with all the relevant values (already summed up).{ &#x201C;users/1/visits&#x201D;: 43, &#x201C;users/1/posts&#x201D;: 3 }&#xA;GET /counters/read?id=users/1/visits&amp;users/1/1/posts&amp;raw=true &lt;&#x2014;will return json response with all the relevant values, per source.{ &#x201C;users/1/visits&#x201D;: {&#x201C;rvn1&#x201D;: 21, &#x201C;rvn2&#x201D;: 22 } , &#x201C;users/1/posts&#x201D;:&#xA0; { &#x201C;rvn1&#x201D;: 2, &#x201C;rvn3&#x201D;: 1 } }&#xA;POST /counters/increment &lt;&#x2013; allows to increment counters. The request is a json array of the counter name and the change.&#xA;For a real system, you&#x2019;ll probably need a lot more stuff, metrics, stats, etc. But this is the high level design, so this would be enough.&#xA;Note that we are skipping the high performance stream based writes we outlined for time series. We&#x2019;ll probably won&#x2019;t need them, so that doesn&#x2019;t matter, but they are an option if we need them.&#xA;System behavior&#xA;This is where it is really not interesting, there is very little behavior here, actually. We only have to read the data from the storage, sum it up, and send it to the user. Hardly what I&#x2019;ll call business logic.&#xA;Client API&#xA;The client API will probably look something like this:&#xA;&#xA;&#xA;   1: counters.Increment(&quot;users/1/posts&quot;);   2: counters.Increment(&quot;users/1/visits&quot;, 4);   3:&#xA0;    4: using(var batch = counters.Batch())   5: {   6:     batch.Increment(&quot;users/1/posts&quot;);   7:     batch.Increment(&quot;users/1/visits&quot;,5);   8:     batch.Submit();   9: }&#xA;Note that we&#x2019;re offering both batch and single API. We&#x2019;ll likely also want to offer a fire &amp; forget style, which will be able to offer even better performance (because they could do batching across more than a single thread), but that is out of scope for now.&#xA;For simplicity sake, we are going to have the client just a container for all of endpoints that it knows about. The container would be responsible for&#x2026; updating the client visible topology, selecting the best server to use at any given point, etc.&#xA;User interface&#xA;There isn&#x2019;t much to it. Just show a list of counter values in a list. Allow to search by prefix, allow to dive into a particular counter and read its raw values, but that is about it. Oh, and allow to delete a counter.&#xA;Deleting data&#xA;Honestly, I really hate deletes. They are very expensive to handle properly the moment you have more than a single node. In this case, there is an inherent race condition between a delete going out and another node getting an increment. And then there is the issue of what happens if you had a node down when you did the delete, etc.&#xA;This just sucks. Deletion are handled normally, (with the race condition caveat, obviously), and I&#x2019;ll discuss how we replicate them in a bit.&#xA;High availability / scale out&#xA;By definition, we actually don&#x2019;t want to have storage replication here. Either log shipping or consensus based. We actually do want to have different values, because we are going to be modifying things independently on many servers.&#xA;That means that we need to do replication at the database level. And that leads to some interesting questions. Again, the hard part here is the deletes. Actually, the really hard part is what we are going to do with the New Server Problem.&#xA;The New Server Problem dictates how we are going to bring a new server into the cluster. If we could fix the size of the cluster, that would make things a lot easier. However, we are actually interested in being able to dynamically grow the cluster size.&#xA;Therefor, there are only two real ways to do it:&#xA;&#xA;Add a new empty node to the cluster, and have it be filled from all the other servers.&#xA;Add a new node by backing up an existing node, and restoring as a new node. &#xA;RavenDB, for example, follows the first option. But it means that in needs to track a lot more information. The second option is actually a lot simpler, because we don&#x2019;t need to care about keeping around old data.&#xA;However, this means that the process of bringing up a new server would now be:&#xA;&#xA;Update all nodes in the cluster with the new node address (node isn&#x2019;t up yet, replication to it will fail and be queued).&#xA;Backup an existing node and restore at the new node.&#xA;Start the new node.&#xA;The order of steps is quite important. And it would be easy to get it wrong. Also, on large systems, backup &amp; restore can take a long time. Operationally speaking, I would much rather just be able to do something like, bring a new node into the cluster in &#x201C;silent&#x201D; mode. That is, it would get information from all the other nodes, and I can &#x201C;flip the switch&#x201D; and make it visible to clients at any point in time.&#xA0; That is how you do it with RavenDB, and it is an incredibly powerful system, when used properly. &#xA;That means that for all intents and purposes, we don&#x2019;t do real deletes. What we&#x2019;ll actually do is replace the counter value with delete marker. This turns deletes into a much simple &#x201C;just another write&#x201D;. It has the sad implication of not free disk space on deletes, but deletes tend to be rare, and it is usually fine to add a &#x201C;purge&#x201D; admin option that can be run on as needed basis.&#xA;But that brings us to an interesting issue, how do we actually handle replication.&#xA;The topology map&#xA;To simplify things, we are going to go with one way replication from a node to another. That allows complex topologies like master-master, cluster-cluster, replication chain, etc. But in the end, this is all about a single node replication to another.&#xA;The first question to ask is, are we going to replicate just our local changes, or are we going to have to replicate external changes as well? The problem with replicating external changes is that you may have the following topology:&#xA;&#xA;Now, Server A got a value and sent it to Server B. Server B then forwarded it to Server C. However, at that point, we also have a the value from Server A replicated directly to Server C. Which value is it supposed to pick? And what about a scenario where you have more complex topology? &#xA;In general, because in this type of system, we can have any node accept writes, and we actually desire this to be the case, we don&#x2019;t want this behavior. We want to only replicate local data, not all the data.&#xA;Of course, that leads to an annoying question, what happens if we have a 3 node cluster, and one node fails catastrophically. We can bring a new node in, and the other two nodes will be able to fill in their values via replication, but what about the node that is down? The data isn&#x2019;t gone, it is still right there in the other two nodes, but we need a way to pull it out.&#xA;Therefor, I think that the best option would be to say that nodes only replicate their local state, except in the case of a new node. A new node will be told the address of an existing node in the cluster, at which point it will:&#xA;&#xA;Register itself in all the nodes in the cluster (discoverable from the existing node). This assumes a standard two way replication link between all servers, if this isn&#x2019;t the case, the operators would have the responsibility to setup the actual replication semantics on their own.&#xA;New node now starts getting updates from all the nodes in the cluster. It keeps them in a log for now, not doing anything yet.&#xA;Ask that node for a complete update of all of its current state.&#xA;When it has all the complete state of the existing node, it replays all of the remembered logs that it didn&#x2019;t have a chance to apply yet.&#xA;Then it announces that it is in a valid state to start accepting client connections.&#xA;Note that this process is likely to be very sensitive to high data volumes. That is why you&#x2019;ll usually want to select a backup node to read from, and that decision is an ops decision.&#xA;You&#x2019;ll also want to be able to report extensively on the current status of the node, since this can take a while, and ops will be watching this very closely.&#xA;Server Name&#xA;A node requires a unique name. We can use guids, but those aren&#x2019;t readable, so we can use machine name &#x2B; port, but those can change. Ideally, we can require the user to set us up with a unique name. That is important for readability and for being able to alter see all the values we have in all the nodes. It is important that names are never repeated, so we&#x2019;ll probably have a guid there anyway, just to be on the safe side.&#xA;Actual Replication Semantics&#xA;Since we have the New Server Problem down to an automated process, we can choose the drastically simpler model of just having an internal queue per each replication destination. Whenever we make a change, we also make a note of that in the queue for that destination, then we start an async replication process to that server, sending all of our updates there.&#xA;It is always safe to overwrite data using replication, because we are overwriting our own data, never anyone else.&#xA;And&#x2026; that is about it, actually. There are probably a lot of details that I am missing / would discover if we were to actually implement this. But I think that this is a pretty good idea about what this feature is about.</p>
        </article>
        <article id="article-3766">
            <a href="https://benfoster.io/blog/fitframejs-responsive-iframes-made-easy/" target="_blank">
                <h2 class="title mb-6" id="article-3766">FitFrame.js - Responsive iframes made easy</h2>
            </a>
            <p class="mb-2">by Ben Foster</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 05, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Introducing FitFrame.js - Responsive iframes made easy</p>
        </article>
        <article id="article-3767">
            <a href="https://ardalis.com/incent-all-parties-involved/" target="_blank">
                <h2 class="title mb-6" id="article-3767">Incent All Parties Involved</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 04, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Incentives and offers are a mainstay of modern business sales and marketing. People feel better about making a purchasing decision if they&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-3768">
            <a href="https://ayende.com/blog/165764/time-series-feature-design-storage-replication-the-bees-knees" target="_blank">
                <h2 class="title mb-6" id="article-3768">Time series feature design</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 04, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Being able to handle replication at the storage level is a really nice feature to have. More than that, it is a feature that can be broadly applied. But&#x2026; a database is a lot more than just storage. And being able to just move the data around between machines is nice, but there are other things we have to take into account. In particular, when we replicate via storage changes, we don&#x2019;t have a good way to take actions on changes. Most of the time, that means that we can&#x2019;t actually rely on internal caches, and would probably have to deal with that somehow in another fashion. But there are usually secondary processing that is done on a node that would have to be accounted for. For example, let us assume that we had the ability to replicate RavenDB (docs) changes between machines using storage replication. The problem here is that we would be replicating the documents, but not the indexes, and when we do that, we would need to index the changed documents on the destination node. However, that would actually require two data stores, one for the actual documents data, and one for all of the non replicated data (indexing, stats, etc). In other words, I think that such a database would have to be designed specifically for that scenario. In addition to that, it would probably be best for the storage replication to also be annotated with information for higher level code. So if you modify this range in the file, you&#x2019;ll also know that you need to drop the following documents from the cache.</p>
        </article>
        <article id="article-3769">
            <a href="https://benfoster.io/blog/deferred-domain-events/" target="_blank">
                <h2 class="title mb-6" id="article-3769">Deferred Domain Events</h2>
            </a>
            <p class="mb-2">by Ben Foster</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 04, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We recently had the need to defer the dispatch of domain events until the end of the request.</p>
        </article>
        <article id="article-3770">
            <a href="https://www.meziantou.net/view-and-edit-the-tab-order-of-windows-forms-controls.htm" target="_blank">
                <h2 class="title mb-6" id="article-3770">View and edit the Tab Order of Windows Forms Controls</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: March 04, 2014
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The Tab Index (or tab index) is used to define the order in which the controls are browsed by the user when the user uses the Tab key.This value can be changed by selecting a control in the Designer and setting the TabIndex property in the property grid. When the window contains only one or two con</p>
        </article>
        <div class="button flex justify-between">
            <a href="376.html"><span class="back arrow"></span></a>

            <a href="378.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>