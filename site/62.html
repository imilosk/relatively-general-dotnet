
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 62 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-611">
            <a href="https://ayende.com/blog/199617-A/using-encryption-to-verify-a-license-key" target="_blank">
                <h2 class="title mb-6" id="article-611">Using encryption to verify a license key</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 23, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">A long while ago I had this project, which allows you to define software licenses that you can distribute. The basic idea is pretty simple, we want to be able to define a key (needs to be short and copy/pastable) that we&#x2019;ll be able to provide to our code that is running in a separate environment. In particular, we have to deal with the issue of not being connected to a central server.&#xA;That sounds like a really hard problem, but it turns out that it is a pretty simple solution, if we use public key cryptography. Typically you&#x2019;ll utilize public key cryptography for encryption, but you can also use that for signing. The idea is that we can use the ability to sign the key using a private key, then validate it (potentially offline) using the public key.&#xA;Licensing can be complex, so we are going to punt all of that to someone else. In this post I&#x2019;m going to just discuss how we can sign a piece of data and then verify it. We&#x2019;ll start by generating the keys, this is an action that you should only do once:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          using System;&#xA;        &#xA;        &#xA;          &#xA;          using System.Security.Cryptography;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var key = ECDsa.Create();&#xA;        &#xA;        &#xA;          &#xA;          var pem = key.ExportPkcs8PrivateKeyPem();&#xA;        &#xA;        &#xA;          &#xA;          Console.WriteLine(pem);&#xA;        &#xA;        &#xA;          &#xA;          var publicPem = key.ExportSubjectPublicKeyInfoPem();&#xA;        &#xA;        &#xA;          &#xA;          Console.WriteLine(publicPem);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          GenerateKeys.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here is the output of this code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          -----BEGIN PRIVATE KEY-----&#xA;        &#xA;        &#xA;          &#xA;          MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIBmjSDHRRDkvP25ne4&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;bG0mU2L9gedX7nuXHKoSiwMvqQ9E70cyfMwuTH/9Ck7ykll8U4&#x2B;mqnWV2BWluAk&#xA;        &#xA;        &#xA;          &#xA;          xaHtfLWhgYkDgYYABAFbfheDkNDoks25uW8EBPgSGZnwM7zzeXc3BbLNbbAEGLjy&#xA;        &#xA;        &#xA;          &#xA;          SHiC64cHdSqSDjENiLEobrGOfpgRxkmMHJBCMzXmOwBXoDBGrtVz5Y2MPwXb9f8i&#xA;        &#xA;        &#xA;          &#xA;          ZZEeVR3QlZtv51LboC6JPZFHV8afK3sh1UcUY2bVb4xNPKv75ws3CeX&#x2B;O6bTBg22&#xA;        &#xA;        &#xA;          &#xA;          Jw==&#xA;        &#xA;        &#xA;          &#xA;          -----END PRIVATE KEY-----&#xA;        &#xA;        &#xA;          &#xA;          -----BEGIN PUBLIC KEY-----&#xA;        &#xA;        &#xA;          &#xA;          MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBW34Xg5DQ6JLNublvBAT4EhmZ8DO8&#xA;        &#xA;        &#xA;          &#xA;          83l3NwWyzW2wBBi48kh4guuHB3Uqkg4xDYixKG6xjn6YEcZJjByQQjM15jsAV6Aw&#xA;        &#xA;        &#xA;          &#xA;          Rq7Vc&#x2B;WNjD8F2/X/ImWRHlUd0JWbb&#x2B;dS26AuiT2RR1fGnyt7IdVHFGNm1W&#x2B;MTTyr&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;&#x2B;cLNwnl/jum0wYNtic=&#xA;        &#xA;        &#xA;          &#xA;          -----END PUBLIC KEY-----&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          keys.pem&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;You can now embed the public key in your software, while keeping the private key hidden.&#xA;With that in place, we can now sign a license. But what is a license? At its most basic form, it is a set of attributes that describe what your license allows. As such, we can use a Dictionary&lt;string,string&gt; to define the capabilities of the license.&#xA;With that in place, we can write very simple code to generate the license text:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          string Sign(string privateKeyPEM, Dictionary&lt;string, string&gt; license)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              using var sign = ECDsa.Create();&#xA;        &#xA;        &#xA;          &#xA;              sign.ImportFromPem(privateKeyPEM);&#xA;        &#xA;        &#xA;          &#xA;              var text = JsonConvert.SerializeObject(license, Formatting.None);&#xA;        &#xA;        &#xA;          &#xA;              var output = sign.SignData(Encoding.UTF8.GetBytes(text), HashAlgorithmName.SHA256);&#xA;        &#xA;        &#xA;          &#xA;              var outputBase64 = Convert.ToBase64String(output);&#xA;        &#xA;        &#xA;          &#xA;              license[&quot;@Sig&quot;] = outputBase64;&#xA;        &#xA;        &#xA;          &#xA;              return JsonConvert.SerializeObject(license, Formatting.Indented);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Sign.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And here is the result:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            &quot;Name&quot;: &quot;John Doe&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;Location&quot;: &quot;Europe&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;@Sig&quot;: &quot;AGA3s9Vf/LI8t5uxP&#x2B;cRofNOEGaBaqGLfur68kGSu0gYPxPDhDkDcc&#x2B;fneAhAMSjaFJUKTHUtE&#x2B;4OXimgwqRkEsVAKeETE5GWPoejyLTITapabHa5KLY7XOcehgm9pGm5IPBgIB2NgfSizLIGRrjjoa9t6ho2jDpmUnMF4HuGJQd2Dej&quot;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          signed.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The last part to deal with is verifying that the license is valid, we can do that using the following function:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Dictionary&lt;string, string&gt; Verify(string publicKeyPEM, string license)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var dic = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, string&gt;&gt;(license);&#xA;        &#xA;        &#xA;          &#xA;              if (dic.Remove(&quot;@Sig&quot;, out var sigText) == false)&#xA;        &#xA;        &#xA;          &#xA;                  return null;&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;byte&gt; signature = stackalloc byte[512];&#xA;        &#xA;        &#xA;          &#xA;              if (Convert.TryFromBase64String(sigText, signature, out var writter) == false)&#xA;        &#xA;        &#xA;          &#xA;                  return null;&#xA;        &#xA;        &#xA;          &#xA;              signature = signature[..writter];&#xA;        &#xA;        &#xA;          &#xA;              using var verify = ECDsa.Create();&#xA;        &#xA;        &#xA;          &#xA;              verify.ImportFromPem(publicKeyPEM);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var textToVerify = JsonConvert.SerializeObject(dic, Formatting.None);&#xA;        &#xA;        &#xA;          &#xA;              if (verify.VerifyData(Encoding.UTF8.GetBytes(textToVerify), signature, HashAlgorithmName.SHA256) == false)&#xA;        &#xA;        &#xA;          &#xA;                  return null;&#xA;        &#xA;        &#xA;          &#xA;              return dic;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Verify.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;If the license options are the same as the one we signed and the cryptographic signature is a match, we can safely return the license options. Otherwise, we&#x2019;ll return null.&#xA;As I said, this is pretty simple code all around. And doesn&#x2019;t do&#xA0;much, but it means that you can let the framework carry most of the load.&#xA;Features such as enabling specific capabilities for a license, expiration, etc are all possible. Define an ExpirationDate property and have your software react to that, for example.&#xA;A few words about this implementation, however. I&#x2019;m relying heavily on the .NET framework, obviously. But beyond just using the cryptographic primitives, we also have to take into account a bunch of other aspects.&#xA;For example, I&#x2019;m not bothering to normalize the license. Instead, I rely on the fact that the .NET Dictionary will iterate over keys in insertion order. Note that any change in the actual data will result in a verification fails.&#xA;This is a pretty simple design, but it ensures that you cannot &#x201C;crack&#x201D; the algorithm used to generate the license keys. Of course, users can still always just patch the isValidLicense function, instead .</p>
        </article>
        <article id="article-612">
            <a href="https://ayende.com/blog/199588-A/integer-compression-fastpfor-in-c-results" target="_blank">
                <h2 class="title mb-6" id="article-612">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 21, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After this saga, I wanted to close the series with some numbers about the impact of this algorithm.&#xA;If you&#x2019;ll recall, I started this whole series discussing variable-sized integers. I was using this list of numbers to compare the values. There are 44,956 items in the list.&#xA;&#xA;&#xA;&#xA;Algorithm&#xA;Size&#xA;&#xA;&#xA;Raw&#xA;359.648&#xA;&#xA;&#xA;Varint&#xA;224,780&#xA;&#xA;&#xA;Delta &#x2B; Varint&#xA;&#xA0;&#xA0; 45,970&#xA;&#xA;&#xA;Delta &#x2B; Varint &#x2B; Gzip&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 5,273&#xA;&#xA;&#xA;FastPFor&#xA;&#xA0;&#xA0;&#xA0;&#xA0; 24,717&#xA;&#xA;&#xA;&#xA;You can see some interesting details about the various options. Delta &#x2B; Varint &#x2B; Gzip is a really good setup, if you can assume that the output pattern has a high degree of repetition. In some cases, that is possible, but that isn&#x2019;t a generic property. Aside from that, FastPFor is winning hands down in terms of the output size of the data.&#xA;There is also another important aspect. The size of the output here is too big to fit in a single 8KB buffer, so I&#x2019;ll need to use multiple for that. This is not something that you can really do with GZip. Here is the cost across multiple buffers:&#xA;This particular list would fit into 4 pages:&#xA;&#xA;14,080 entries at 8,048 bytes&#xA;14,080 entries at 8,063 bytes&#xA;15,616 entries at 8,030 bytes&#xA;&#xA0; 1,180 entries at&#xA0;&#xA0;&#xA0; 644 bytes&#xA;&#xA;But the compression ratio is only part of that. Let&#x2019;s talk about the performance aspect. On my machine, you can run the encoding process in 1,115 ticks and decoding in just 462 ticks.&#xA;To give some context, that means that you can do the encoding at a rate of ~400,000,000 / second and decoding at a rate of about 1 billion per second.&#xA;My perf team also asked me to mention that they haven&#x2019;t gotten the chance to look at the code yet, so things are likely to improve.&#xA;The entire premise of FastPFor inside of RavenDB relies on these fast decoding &amp; encoding times. It makes it super cheap to iterate over a vast amount of numbers, and the B&#x2B;Tree layout we have means that updating a posting list&#x2019;s page is trivial. Read it, merge, and encode it back. It&#x2019;s fast enough that there is really no other place for meaningful optimizations / complexity.</p>
        </article>
        <article id="article-613">
            <a href="https://ayende.com/blog/199587-A/integer-compression-implementing-fastpfor-decoding-in-c" target="_blank">
                <h2 class="title mb-6" id="article-613">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 20, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I discussed FastPFor encoding, now I&#x2019;m going to focus on how we deal with decoding. Here is the decode struct:&#xA;&#xA;&#xA;&#xA;Note that this is a struct for performance reasons. We expect that we&#x2019;ll have a lot of usage here, so saving the allocation here ends up paying high dividends.&#xA0; Before we&#x2019;ll start, I want to pay special attention to the fields on the decoder:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public unsafe struct FastPForDecoder&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              private byte* _input;&#xA;        &#xA;        &#xA;          &#xA;              private byte* _metadata;&#xA;        &#xA;        &#xA;          &#xA;              private readonly byte* _end;&#xA;        &#xA;        &#xA;          &#xA;              private uint* _exceptions;&#xA;        &#xA;        &#xA;          &#xA;              private fixed int _exceptionOffsets[32];&#xA;        &#xA;        &#xA;          &#xA;              private Vector256&lt;long&gt; _prev;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FastPForDecoder.fields.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Of particular interest is the _exceptionOffsets array. If you aren&#x2019;t familiar with it, this is a fixed-size array on the struct.&#xA;Here is the constructor for the decoder:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public FastPForDecoder(byte* input, int size)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (size &lt;= sizeof(PForHeader)) throw new ArgumentOutOfRangeException(nameof(size));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              _input = input;&#xA;        &#xA;        &#xA;          &#xA;              _end = input &#x2B; size;&#xA;        &#xA;        &#xA;          &#xA;              ref var header = ref Unsafe.AsRef&lt;PForHeader&gt;(input);&#xA;        &#xA;        &#xA;          &#xA;              _metadata = input &#x2B; header.MetadataOffset;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              _exceptions = null;&#xA;        &#xA;        &#xA;          &#xA;              var exceptionsBufferSize = 1024;&#xA;        &#xA;        &#xA;          &#xA;              var exceptionBufferOffset = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              _exceptions = (uint*)NativeMemory.Alloc((uint)(exceptionsBufferSize * sizeof(uint)));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var exception = _input &#x2B; header.ExceptionsOffset;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 2; i &lt;= 32; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if ((header.ExceptionsBitmap &amp; (1 &lt;&lt; (i - 1))) == 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var count = Unsafe.Read&lt;ushort&gt;(exception);&#xA;        &#xA;        &#xA;          &#xA;                  exception &#x2B;= sizeof(ushort);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (count &#x2B; exceptionBufferOffset &gt; exceptionsBufferSize)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      exceptionsBufferSize *= 2;&#xA;        &#xA;        &#xA;          &#xA;                      _exceptions = (uint*)NativeMemory.Realloc(_exceptions, (uint)(exceptionsBufferSize * sizeof(uint)));&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  BitPacking.UnpackSegmented(exception, count, _exceptions &#x2B; exceptionBufferOffset, (uint)i);&#xA;        &#xA;        &#xA;          &#xA;                  _exceptionOffsets[i] = exceptionBufferOffset;&#xA;        &#xA;        &#xA;          &#xA;                  exceptionBufferOffset &#x2B;= count;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  exception &#x2B;= BitPacking.RequireSizeSegmented(count, i);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              _input &#x2B;= sizeof(PForHeader);&#xA;        &#xA;        &#xA;          &#xA;              _prev = Vector256.Create(header.Baseline);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FastPForDecoder.ctor.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We are being provided with the encoded buffer and its size. What is actually happening here?&#xA;We start by allocating memory for the exceptions buffer, then scan the exceptions bitmap and extract the exceptions data to the buffer. We use a single buffer for all of the exceptions, and the _exceptionsOffsets is an indication of where each bit width exception is currently at.&#xA;Finally, we set the _prev to be a vector of the baseline. That is the counterpoint to how we dealt with the values during the encoding. Like the encoding process, we have to deal with three states:&#xA;&#xA;Big deltas (for the next block)&#xA;Variable integer (at the end)&#xA;Packed block of 256 numbers&#xA;&#xA;We&#x2019;ll start with dealing with the first two options:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public int Read(long* output, int outputCount)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              List&lt;long&gt; bigDeltaOffsets = null;&#xA;        &#xA;        &#xA;          &#xA;              var buffer = stackalloc uint[256];&#xA;        &#xA;        &#xA;          &#xA;              int read = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (_metadata &lt; _end &amp;&amp; read &lt; outputCount)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  Debug.Assert(read &#x2B; 256 &lt;= outputCount, &quot;We assume a minimum of 256 free spaces&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var numOfBits = *_metadata&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                  switch (numOfBits)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      case FastPForEncoder.BiggerThanMaxMarker:&#xA;        &#xA;        &#xA;          &#xA;                          (bigDeltaOffsets ??= new List&lt;long&gt;()).Add((long)_metadata);&#xA;        &#xA;        &#xA;          &#xA;                          // we don&#x27;t need to worry about block fit, because we are ensured that we have at least&#xA;        &#xA;        &#xA;          &#xA;                          // 256 items to read into the output here, and these marker are for the next blcok&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          // batch location &#x2B; 16 bytes high bits of the delta&#xA;        &#xA;        &#xA;          &#xA;                          _metadata &#x2B;= 17;&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      case FastPForEncoder.VarIntBatchMarker:&#xA;        &#xA;        &#xA;          &#xA;                          var countOfVarIntBatch = *_metadata&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                          var prevScalar = _prev.GetElement(3);&#xA;        &#xA;        &#xA;          &#xA;                          for (int i = 0; i &lt; countOfVarIntBatch; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              var cur = ReadVarInt(_input, out var offset);&#xA;        &#xA;        &#xA;          &#xA;                              _input &#x2B;= offset;&#xA;        &#xA;        &#xA;          &#xA;                              cur &#x2B;= prevScalar;&#xA;        &#xA;        &#xA;          &#xA;                              output[read&#x2B;&#x2B;] = cur;&#xA;        &#xA;        &#xA;          &#xA;                              prevScalar = cur;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          _prev = Vector256.Create(prevScalar);&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      case &gt; 32 and &lt; FastPForEncoder.BiggerThanMaxMarker:&#xA;        &#xA;        &#xA;          &#xA;                          throw new ArgumentOutOfRangeException(&quot;Unknown bits amount: &quot; &#x2B; numOfBits);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Read_Start.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;If we have a big delta, we record that in the bigDeltaOffsets. Note that we are playing an annoying game here. I&#x2019;m actually storing the metadata position in the delta offsets. I can cast it to long and then to pointer because I&#x2019;m ensured that the data is fixed during the operation.&#xA;For the varint scenario, the last item in the batch, we don&#x2019;t have to do much, we compute the running total of the values as we read them from the input, that&#x2019;s about it.&#xA;Things get a lot more interesting when we start dealing with the actual compressed blocks:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var numOfExceptions = *_metadata&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          SimdBitPacking&lt;NoTransform&gt;.Unpack256(0, _input, buffer, numOfBits);&#xA;        &#xA;        &#xA;          &#xA;          _input &#x2B;= numOfBits * Vector256&lt;byte&gt;.Count;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          if (numOfExceptions &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var maxNumOfBits = *_metadata&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              var bitsDiff = maxNumOfBits - numOfBits;&#xA;        &#xA;        &#xA;          &#xA;              if (bitsDiff == 1)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var mask = 1u &lt;&lt; numOfBits;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; numOfExceptions; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var idx = *_metadata&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                      buffer[idx] |= mask;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              else&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  ref var offset = ref _exceptionOffsets[bitsDiff];&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; numOfExceptions; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var remains = _exceptions[offset&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;                      var idx = *_metadata&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                      buffer[idx] |= remains &lt;&lt; numOfBits;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var expectedBufferIndex = -1;&#xA;        &#xA;        &#xA;          &#xA;          if (bigDeltaOffsets != null &amp;&amp; bigDeltaOffsets.Count &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              expectedBufferIndex = *(byte*)bigDeltaOffsets[0];&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Read_Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here we simply decode the values to the buffer, then we need to apply the exceptions. You can see that we saved some space by not storing exceptions of 1 bit (since we know what the value would be). For exceptions of different sizes, see how we consume the exception from _exceptionOffsets for each used exception. I&#x2019;m using a ref variable here, so the offset&#x2B;&#x2B; operation will increment the value in the array. That ensures that we have to keep very little state in the decoding process as it moves forward. Remember that we require that the output buffer for the decoded numbers be at least 256 values, to ensure that we can fit them all in. That doesn&#x2019;t mean that we have enough space to fit everything. So we may be called multiple times and need to resume from where we left off.&#xA;Finally, we set the expectedBufferIndex if we have a big delta offset. We&#x2019;ll shortly see what we&#x2019;ll do with this.&#xA;Remember that at this point, the buffer we use has&#xA0;int32 deltas in it, not the actual final numbers. In order to get the final values, we need to compute the sum of the deltas, this is handled here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (int i = 0; i &#x2B; Vector256&lt;uint&gt;.Count &lt;= 256; i &#x2B;= Vector256&lt;uint&gt;.Count)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var (a, b) = Vector256.Widen(Vector256.Load(buffer &#x2B; i));&#xA;        &#xA;        &#xA;          &#xA;              if (expectedBufferIndex == i)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  a |= GetDeltaHighBits();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              PrefixSumAndStoreToOutput(a, ref _prev);&#xA;        &#xA;        &#xA;          &#xA;              if (expectedBufferIndex == i &#x2B; 4)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  b |= GetDeltaHighBits();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              PrefixSumAndStoreToOutput(b, ref _prev);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Read_Sum.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What do we do here? We load a vector of 8 integers (32 bits) and widen that to two vectors of 4 integers (64 bits) each.&#xA;We then check whether this is the expected buffer index for big delta offsets, if so, we&#x2019;ll or the high parts of the number back to the vector. This is handled here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Vector256&lt;ulong&gt; GetDeltaHighBits()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var ptr = (byte*)bigDeltaOffsets![0];&#xA;        &#xA;        &#xA;          &#xA;              bigDeltaOffsets.RemoveAt(0);&#xA;        &#xA;        &#xA;          &#xA;              var highBitsDelta = Vector128.Load(ptr)&#xA;        &#xA;        &#xA;          &#xA;                  .AsInt32().ToVector256();&#xA;        &#xA;        &#xA;          &#xA;              if (bigDeltaOffsets.Count &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  expectedBufferIndex = *(byte*)bigDeltaOffsets[0];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              else&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  expectedBufferIndex = -1;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // the last 4 elements are known zero, so no need to AND with zero&#xA;        &#xA;        &#xA;          &#xA;              highBitsDelta = Vector256.Shuffle(highBitsDelta, Vector256.Create(7, 0, 7, 1, 7, 2, 7, 3));&#xA;        &#xA;        &#xA;          &#xA;              return highBitsDelta.AsUInt64();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          GetDeltaHighBits.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There are quite a few things that are happening here all at once. We first read the current delta offset from the metadata, and read 16 bytes into a Vector128. We then translate that vector to a vector of 256 bits. That would basically add zeros to the vector. We set the next index to check and then we shuffle the vector on numbers to arrange it on the high parts of the vector as longs.&#xA;Let&#x2019;s say that we had the numbers [1,2,3,4] in the metadata, we read them into the Vector128, like so:&#xA;&#xA;Vector128 = [1,2,3,4]&#xA;&#xA;We then extended that to a Vector256, like so:&#xA;&#xA;Vector256 = [1,2,3,4,0,0,0,0]&#xA;&#xA;Finally, we shuffle the values, (in this case, 7 is known to be zero) so we have:&#xA;&#xA;highBitsDelta = [0,1,0,2,0,3,0,4]&#xA;&#xA;We convert that to a vector of longs (with the same bits pattern) and then or that with the values from the packed deltas.&#xA;We have to do the expectedBufferIndex twice on each iteration, but we expect that to be rare, so the branch predictor is going to be really good in predicting this.&#xA;Finally, we have the part where we compute the prefix sum, here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void PrefixSumAndStoreToOutput(Vector256&lt;ulong&gt; curUl, ref Vector256&lt;long&gt; prev)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var cur = curUl.AsInt64();&#xA;        &#xA;        &#xA;          &#xA;              // doing prefix sum here: https://en.algorithmica.org/hpc/algorithms/prefix/&#xA;        &#xA;        &#xA;          &#xA;              cur &#x2B;= Vector256.Shuffle(cur, Vector256.Create(0, 0, 1, 2)) &amp;&#xA;        &#xA;        &#xA;          &#xA;                     Vector256.Create(0, -1, -1, -1);&#xA;        &#xA;        &#xA;          &#xA;              cur &#x2B;= Vector256.Shuffle(cur, Vector256.Create(0, 0, 0, 1)) &amp;&#xA;        &#xA;        &#xA;          &#xA;                     Vector256.Create(0, 0, -1, -1);&#xA;        &#xA;        &#xA;          &#xA;              cur &#x2B;= prev;&#xA;        &#xA;        &#xA;          &#xA;              prev = Vector256.Shuffle(cur, Vector256.Create(3, 3, 3, 3));&#xA;        &#xA;        &#xA;          &#xA;              cur.Store(output &#x2B; read);&#xA;        &#xA;        &#xA;          &#xA;              read &#x2B;= Vector256&lt;long&gt;.Count;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Read_PrefixSum.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This looks like black magic, but let&#x2019;s break it apart into individual pieces.&#xA0;&#xA;Let&#x2019;s assume that we started out with [25,27,30, 35] &#x2013; using our approach, we have Baseline: 21 and the deltas: [4,2,3,5].&#xA;We start with prev being set to the baseline value on all elements in the vector:&#xA;&#xA;prev = [21,21,21,21]&#xA;&#xA;And cur is set to deltas:&#xA;&#xA;cur = [4,2,3,5]&#xA;&#xA;On line 5, we shuffle and&#xA0;BitwiseAnd the value with a mask, let&#x2019;s see what we get:&#xA;&#xA;Line 5 &#x2013; shuffled: [4,4,2,3]&#xA;LIne 5- masked: [0,4,2,3]&#xA;&#xA;We add that to cur, giving us:&#xA;&#xA;cur = [4 &#x2B; 0, 4 &#x2B; 2, 3 &#x2B; 2, 5 &#x2B; 3] = [4,6,5,8]&#xA;&#xA;On line 7, we do another shuffle &amp; mask:&#xA;&#xA;Line 7 &#x2013; shuffled: [4,4,4,6]&#xA;Line 7 &#x2013; masked: [0,0,4,6]&#xA;&#xA;And adding that to cur, will give us:&#xA;&#xA;cur = [4&#x2B;0, 6&#x2B; 0, 5 &#x2B; 4, 8&#x2B; 6] = [4,6,9,14]&#xA;&#xA;We now add the prev vector, giving us:&#xA;&#xA;cur = [4 &#x2B; 21, 6 &#x2B; 21, 9 &#x2B; 21, 14 &#x2B; 21] = [25, 27, 30, 35]&#xA;&#xA;We computed the sum again, hurray!&#xA;We then set all elements of prev to the last value of cur:&#xA;&#xA;prev = [35,35,35,35]&#xA;&#xA;And now we are ready for the next element to compute.&#xA;And&#x2026; this is pretty much it, to be honest. We keep reading until we are out of space in the buffer or consumed all the metadata. We are able to decode the data really fast, and it only took a 10 parts (so far) series of blog posts to explain.&#xA;In the next post, I&#x2019;m going to discuss what we can see from actually using this with real numbers.</p>
        </article>
        <article id="article-614">
            <a href="https://andrewlock.net/validating-nested-dataannotation-options-recursively-with-minivalidation/" target="_blank">
                <h2 class="title mb-6" id="article-614">Validating nested DataAnnotation IOptions recursively with MiniValidation</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 20, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post&#x2026;</p>
        </article>
        <article id="article-615">
            <a href="https://ayende.com/blog/199586-A/integer-compression-implementing-fastpfor-encoding-in-c" target="_blank">
                <h2 class="title mb-6" id="article-615">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 19, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post I outlined the requirements we have for FastPFor in RavenDB. Now I want to dig into the actual implementation. Here is the shape of the class in question:&#xA;&#xA;&#xA;&#xA;The process starts when we start encoding the items. Each call to encode is going to process a different posting list, and it is expected that a single instance will process many posting lists during a single indexing run.&#xA;Here is the internal state of this class:&#xA;&#xA;&#xA;&#xA;Here is how we start the process:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public int Encode(long* entries, int count)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              AssertIsSorted(entries, count);&#xA;        &#xA;        &#xA;          &#xA;              _entries = entries;&#xA;        &#xA;        &#xA;          &#xA;              _count = count;&#xA;        &#xA;        &#xA;          &#xA;              _offset = 0;&#xA;        &#xA;        &#xA;          &#xA;              _metadataPos = 0;&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;              for (int k = 0; k &lt; _exceptions.Length; k&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _exceptions[k]?.Clear();&#xA;        &#xA;        &#xA;          &#xA;                  _exceptionsStart[k] = 0;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              _metadata.Clear();&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;              if (_entriesOutputSize &lt; count)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var newCount = Math.Max(256, BitOperations.RoundUpToPowerOf2((uint)count));&#xA;        &#xA;        &#xA;          &#xA;                  _entriesOutput = (byte*)NativeMemory.Realloc(_entriesOutput, newCount * sizeof(long));&#xA;        &#xA;        &#xA;          &#xA;                  _entriesOutputSize = newCount;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode_Init.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, there isn&#x2019;t much here. We initialize the state of exceptions and exceptionsStarts (will discuss this in more detail later in this post) and then we ensure that we have a big enough buffer to encode the data. Note that we retain a point to the original entries that we were passed, that will be important later as well.&#xA;Here is the code of the encoding process:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var totalSize = sizeof(PForHeader);&#xA;        &#xA;        &#xA;          &#xA;          int i = 0;&#xA;        &#xA;        &#xA;          &#xA;          var entriesAsInt = (uint*)_entriesOutput;&#xA;        &#xA;        &#xA;          &#xA;          var entriesIn = _entries;&#xA;        &#xA;        &#xA;          &#xA;          var prev = Vector256.Create(*entriesIn);&#xA;        &#xA;        &#xA;          &#xA;          var max = Vector256.Create&lt;long&gt;(uint.MaxValue);&#xA;        &#xA;        &#xA;          &#xA;          for (; i &#x2B; 256 &lt;= _count; i &#x2B;= 256)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var blockStart = entriesAsInt;&#xA;        &#xA;        &#xA;          &#xA;              int j = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (; j &lt; 256; j &#x2B;= Vector256&lt;long&gt;.Count)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var cur = Vector256.Load(entriesIn &#x2B; i &#x2B; j);&#xA;        &#xA;        &#xA;          &#xA;                  var mixed = Vector256.Shuffle(cur, Vector256.Create(0, 0, 1, 2)) &amp; Vector256.Create(0, -1, -1, -1) |&#xA;        &#xA;        &#xA;          &#xA;                              Vector256.Shuffle(prev, Vector256.Create(3, 3, 3, 3)) &amp; Vector256.Create(-1, 0, 0, 0);&#xA;        &#xA;        &#xA;          &#xA;                  prev = cur;&#xA;        &#xA;        &#xA;          &#xA;                  var delta = cur - mixed;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (Vector256.GreaterThanAny(delta, max))&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      HandleDeltaGreaterThanMax(j, delta);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var deltaInts = Vector256.Shuffle(delta.AsUInt32(), Vector256.Create(0u,2,4,6,0,0,0,0));&#xA;        &#xA;        &#xA;          &#xA;                  deltaInts.Store(entriesAsInt);&#xA;        &#xA;        &#xA;          &#xA;                  // we write 8 values, but increment by 4, so we&#x27;ll overwrite it next op&#xA;        &#xA;        &#xA;          &#xA;                  entriesAsInt &#x2B;= Vector256&lt;long&gt;.Count;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              totalSize &#x2B;= ProcessBlock(blockStart);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode_Core.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I create a couple of vector variables, one to hold the first item in the list and the other to hold uint.MaxValue. Then I start processing the buffers in blocks of 256 items.&#xA;&#xA;A good resource for using vectors and SIMD in C# can be found here.&#xA;&#xA;The classic FastPFor is using vectors of 128 bits (although there are implementations of up to 512 bits). I chose to use Vector256 for the implementation. Today, pretty much any x64 machine is going to have native support for AVX2 (shipped since 2011!). On ARM, they are implemented using Vector128, so they are still vectorized there as well.&#xA;What this means is that we can process 256 numbers as a block. But what are we doing with them? Look at the inner look, where you can see some interesting details. We are using shuffle instructions as well as masking to shift the current value and add the previous one.&#xA;In other words, let&#x2019;s assume that we have the following input array: 1,2,3,4,5,6,7,8 &#x2013; using longs, so Vector256 will contain 4 elements.&#xA;On line 5, we create the prev vector and assign it to have 4 copies of the first item in the array:&#xA;&#xA;prev = [1,1,1,1]&#xA;&#xA;On line 13, we load the 4 elements from the array into cur, giving us:&#xA;&#xA;cur = [1,2,3,4]&#xA;&#xA;On line 14, we shuffle both the prev and the cur values, here are intermediate states:&#xA;&#xA;curShuffled = [0,1,2,3] &#x2013; note that we have 0 at the start because of the mask&#xA;prevShuffled = [1,0,0,0] &#x2013; the last three items are zero because of the mask.&#xA;&#xA;We then or those two intermediates together, giving us:&#xA;&#xA;mixed = [1,1,2,3]&#xA;&#xA;We subtract that from cur to get the delta. The idea is that we massively reduce the number of operations that we have to perform to compute the delta of the values.&#xA;On lines 19..22 we check if any of the deltas is greater than uint.MaxValue, we&#x2019;ll dig into that in a bit.&#xA;The last part of the loop is when we deal with detlaInts, where we are doing some interesting things. We are pulling the low bits from all four elements in the vector to the start of the vector. Then we write the deltas to the output entries buffer.&#xA;However, we write 8 values, but we increment the position by 4, so we&#x2019;ll actually overwrite the last 4 items in the next loop iteration. The entries buffer is sized based on the entries buffer, so we are ensured to have enough space, and the double writes give us better performance.&#xA;The end result of the inner loop is that we are performing running delta over the items, converting them from longs to ints. Then we can call the ProcessBlock() method to actually do the code of the FastPFor algorithm:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private int ProcessBlock(uint* currentEntries)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var (bestB, maxB, exceptionCount) = FindBestBitWidths(currentEntries);&#xA;        &#xA;        &#xA;          &#xA;              _metadata.Add((byte)bestB);&#xA;        &#xA;        &#xA;          &#xA;              _metadata.Add((byte)exceptionCount);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (exceptionCount &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _metadata.Add((byte)maxB);&#xA;        &#xA;        &#xA;          &#xA;                  uint maxVal = 1u &lt;&lt; bestB;&#xA;        &#xA;        &#xA;          &#xA;                  for (int j = 0; j &lt; 256; j&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (currentEntries[j] &gt;= maxVal)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          var exList = _exceptions[maxB - bestB] ??= new();&#xA;        &#xA;        &#xA;          &#xA;                          exList.Add(currentEntries[j] &gt;&gt;&gt; bestB);&#xA;        &#xA;        &#xA;          &#xA;                          _metadata.Add((byte)j);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return bestB * Vector256&lt;byte&gt;.Count;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ProcessBlock.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I already explained how this works in this post.&#xA;It is important to understand that we have multiple data channels that we operate on here:&#xA;&#xA;The entries output, where we write the packed bits&#xA;Metadata, where we describe each block&#xA;Exceptions, where we store the exception data&#xA;&#xA;The encoding process runs through all of them, but isn&#x2019;t actually going to be writing them anywhere, that happens later.&#xA;We process the entries in the array in blocks of 256 numbers each, but what happens when we get to the end? The last block size may not be a multiple of 256, after all. For the last item, we use simple delta encoding plus variable-sized integers. Nothing really fancy is needed at this point, since that is very small.&#xA;Finally, we run over all the exceptions data that we created during the encoding process and compute their size. The final result we have is the total size we would need to store all the encoded data as a single buffer.&#xA;What about handling numbers whose delta is greater than uint.MaxValue?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void HandleDeltaGreaterThanMax(int batchOffset, Vector256&lt;long&gt; delta)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              // we expect this to be *rare*, so not trying to optimize this in any special way&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;uint&gt; deltaHighBuffer = stackalloc uint[8];&#xA;        &#xA;        &#xA;          &#xA;              var highAndLow = Vector256.Shuffle(delta.AsUInt32(), Vector256.Create(1u, 3, 5, 7, 0, 2, 4, 6));&#xA;        &#xA;        &#xA;          &#xA;              highAndLow.StoreUnsafe(ref deltaHighBuffer[0]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              _metadata.Add(BiggerThanMaxMarker);&#xA;        &#xA;        &#xA;          &#xA;              _metadata.Add((byte)batchOffset);&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;byte&gt; asBytes = MemoryMarshal.AsBytes(deltaHighBuffer);&#xA;        &#xA;        &#xA;          &#xA;              for (int j = 0; j &lt; 16; j&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _metadata.Add(asBytes[j]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          HandleDeltaGreaterThanMax.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;You can see that we expect this to be rare, so we handle that to be on the safe side, but aren&#x2019;t trying to be too optimal about it. We simply take the high portion of the current delta and write it to the metadata. That is wasteful in terms of space, but it is simple and doesn&#x2019;t require complex code. We&#x2019;ll see how that is being used during the decoding process in the next post.&#xA;Finally, it is now time to actually write things out to the buffer. We have to be careful here, since we need to support partial writes. Let&#x2019;s see how that works:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public (int Count, int SizeUsed) Write(byte* output, int outputSize)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(outputSize &lt;= ushort.MaxValue, &quot;Output buffer too large, we use ushort for offsets and don&#x27;t want to overflow&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var sizeUsed = sizeof(PForHeader);&#xA;        &#xA;        &#xA;          &#xA;              if (sizeUsed &gt; outputSize)&#xA;        &#xA;        &#xA;          &#xA;                  return default;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              ref var header = ref Unsafe.AsRef&lt;PForHeader&gt;(output);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var baseline = _entries[Math.Max(0, _offset - 1)];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              header.Baseline = baseline;&#xA;        &#xA;        &#xA;          &#xA;              var exceptionsCounts = stackalloc int[33];&#xA;        &#xA;        &#xA;          &#xA;              var startingMetadataPosition = _metadataPos;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var exceptionsRequiredSize = 0;&#xA;        &#xA;        &#xA;          &#xA;              var entriesOutput = (uint*)_entriesOutput;&#xA;        &#xA;        &#xA;          &#xA;              var oldOffset = _offset;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Write_Init.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We define a header for the encoded data, which looks like this:&#xA;&#xA;&#xA;&#xA;The header contains the initial value of the encoded data, the exceptions bitmap (discussed here) and the exception and metadata offsets. Because we always limit the size of the buffer to a maximum of 8KB, I used ushort here.&#xA;The first value we set in the header is the baseline, here we need to explain a bit. When we encode the data, we start from the very first item in the list, and go forward. The problem with doing things in this manner is that when we need to split the encoded data, we need to use the baseline that is the previous value that we encoded with. For that reason, we use either the first item in the entries array or the item from the end of the previous block that we consumed.&#xA;Next, we need to deal with the exceptions, as a reminder, we have a set of exceptions that are shared across blocks. When we do a partial write, we need to keep track of how many exceptions we consumed from each of the exceptions array.&#xA;The most interesting part comes when we start iterating over the metadata values, which tells us how to deal with the data:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          while (_metadataPos &lt; _metadata.Count)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var batchMetadataStart = _metadataPos;&#xA;        &#xA;        &#xA;          &#xA;              var numOfBits = _metadata[_metadataPos&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              switch (numOfBits)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  case BiggerThanMaxMarker:&#xA;        &#xA;        &#xA;          &#xA;                      // nothing to do, doesn&#x27;t impact writes &#xA;        &#xA;        &#xA;          &#xA;                      _metadataPos &#x2B;= 17; // batch offset &#x2B; 16 bytes&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  case VarIntBatchMarker:&#xA;        &#xA;        &#xA;          &#xA;                      var sizeOfVarIntBatch = _metadata[_metadataPos&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;                      var varintSize = WriteLastBatchAsVarIntDelta(sizeOfVarIntBatch, output &#x2B; sizeUsed, outputSize - sizeUsed);&#xA;        &#xA;        &#xA;          &#xA;                      var expectedMetadataSize = _metadataPos - startingMetadataPosition;&#xA;        &#xA;        &#xA;          &#xA;                      if (varintSize == 0 || // couldn&#x27;t fit the var int buffer&#xA;        &#xA;        &#xA;          &#xA;                          sizeUsed &#x2B; varintSize &#x2B; exceptionsRequiredSize &#x2B; expectedMetadataSize &gt; outputSize) // wouldn&#x27;t be able to fit the exceptions &amp; metadata&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          _metadataPos = batchMetadataStart;&#xA;        &#xA;        &#xA;          &#xA;                          goto AfterLoop;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      _offset &#x2B;= sizeOfVarIntBatch;&#xA;        &#xA;        &#xA;          &#xA;                      sizeUsed &#x2B;= varintSize;&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  case &gt; 32 and &lt; BiggerThanMaxMarker:&#xA;        &#xA;        &#xA;          &#xA;                      throw new ArgumentOutOfRangeException(&quot;Invalid bits value: &quot; &#x2B; numOfBits);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Write_Loop.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here we start with the exceptional cases, of a metadata value that is greater than the max delta or the varint batch marker (which occurs in the end).&#xA;You can see that there isn&#x2019;t much there, except that we verify that we have enough space for the written buffers. For fun, I&#x2019;m also using a goto here, this is needed to break out of the loop, since I cannot use a break statement in a switch case.&#xA;The more interesting aspect happens when we process full blocks of compressed 256 numbers:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var numOfExceptions = _metadata[_metadataPos&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var reqSize = numOfBits * Vector256&lt;byte&gt;.Count;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          ref var exceptionCountRef = ref exceptionsCounts[0];&#xA;        &#xA;        &#xA;          &#xA;          var amountToAddToException = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          if (numOfExceptions &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var maxNumOfBits = _metadata[_metadataPos&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;              var exceptionIndex = maxNumOfBits - numOfBits;&#xA;        &#xA;        &#xA;          &#xA;              if (exceptionIndex &gt; 1)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var oldCount = exceptionsCounts[exceptionIndex];&#xA;        &#xA;        &#xA;          &#xA;                  amountToAddToException = numOfExceptions;&#xA;        &#xA;        &#xA;          &#xA;                  exceptionCountRef = ref exceptionsCounts[exceptionIndex];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (oldCount == 0)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      exceptionsRequiredSize &#x2B;= sizeof(ushort); // size for the number of items here&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  exceptionsRequiredSize -= BitPacking.RequireSizeSegmented(oldCount, exceptionIndex);&#xA;        &#xA;        &#xA;          &#xA;                  exceptionsRequiredSize &#x2B;= BitPacking.RequireSizeSegmented(numOfExceptions &#x2B; oldCount, exceptionIndex);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          _metadataPos &#x2B;= numOfExceptions;&#xA;        &#xA;        &#xA;          &#xA;          var metaSize = _metadataPos - startingMetadataPosition;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var finalSize = (sizeUsed &#x2B; reqSize &#x2B; exceptionsRequiredSize &#x2B; metaSize);&#xA;        &#xA;        &#xA;          &#xA;          if (finalSize &gt; outputSize)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              _metadataPos = batchMetadataStart;&#xA;        &#xA;        &#xA;          &#xA;              break;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          SimdBitPacking&lt;MaskEntries&gt;.Pack256(0, entriesOutput &#x2B; _offset,&#xA;        &#xA;        &#xA;          &#xA;              output &#x2B; sizeUsed, numOfBits, new MaskEntries((1u &lt;&lt; numOfBits) - 1));&#xA;        &#xA;        &#xA;          &#xA;          sizeUsed &#x2B;= reqSize;&#xA;        &#xA;        &#xA;          &#xA;          _offset &#x2B;= 256;&#xA;        &#xA;        &#xA;          &#xA;          exceptionCountRef &#x2B;= amountToAddToException;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Write_Block.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This looks like a lot of code, but what it is actually doing is to mostly checking that we have enough space in the buffer for the block we are about to write. Of particular interest to us here is that we may have enough space to write the block, but we also need to ensure that we have space for the metadata and exceptions data that is associated with the current and all previous blocks.&#xA;If we have enough space, we continue to write more blocks to the output, or we exit if we are about to run out of room. After the loop, we have the header and compressed integers data in the output buffer, but we still need to write the metadata and exceptions data, this is handled here:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          AfterLoop:&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uint bitmap = 0;&#xA;        &#xA;        &#xA;          &#xA;          header.ExceptionsOffset = checked((ushort)sizeUsed);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          for (int numOfBits = 2; numOfBits &lt;= 32; numOfBits&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var count = exceptionsCounts[numOfBits];&#xA;        &#xA;        &#xA;          &#xA;              if (count == 0)&#xA;        &#xA;        &#xA;          &#xA;                  continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              bitmap |= 1u &lt;&lt; numOfBits - 1;&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.Write(output &#x2B; sizeUsed, (ushort)count);&#xA;        &#xA;        &#xA;          &#xA;              sizeUsed &#x2B;= sizeof(ushort);&#xA;        &#xA;        &#xA;          &#xA;              var span = CollectionsMarshal.AsSpan(_exceptions[numOfBits]);&#xA;        &#xA;        &#xA;          &#xA;              var exceptionStart = _exceptionsStart[numOfBits];&#xA;        &#xA;        &#xA;          &#xA;              span = span[exceptionStart..(exceptionStart &#x2B; count)];&#xA;        &#xA;        &#xA;          &#xA;              fixed (uint* b = span)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  int size = BitPacking.PackSegmented(b, span.Length, output &#x2B; sizeUsed, (uint)numOfBits);&#xA;        &#xA;        &#xA;          &#xA;                  sizeUsed &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              _exceptionsStart[numOfBits] &#x2B;= count;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          header.ExceptionsBitmap = bitmap;&#xA;        &#xA;        &#xA;          &#xA;          header.MetadataOffset = checked((ushort)sizeUsed);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var metadataSize = (_metadataPos - startingMetadataPosition);&#xA;        &#xA;        &#xA;          &#xA;          var metadataSpan = CollectionsMarshal.AsSpan(_metadata);&#xA;        &#xA;        &#xA;          &#xA;          var metadataBlockRange = metadataSpan[startingMetadataPosition..(startingMetadataPosition &#x2B; metadataSize)];&#xA;        &#xA;        &#xA;          &#xA;          metadataBlockRange.CopyTo(new Span&lt;byte&gt;(output &#x2B; sizeUsed, metadataSize));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          sizeUsed &#x2B;= metadataSize;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          return (_offset - oldOffset, sizeUsed);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Write_AfterLoop.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We compute the bitmap of all the exceptions, writing them out as packed segments (basically, 256 blocks of packed bits). Note that we have to account for how many of them we actually write out to the output, since we may have stopped in the middle.&#xA;Then we can simply write out the metadata buffer and return the total size we took.&#xA;I find it very amusing that we use the same bit packing routines to store the numbers and the exceptions data as well.&#xA;Overall, most of the code isn&#x2019;t particularly interesting, but there are a few highlights that I would like to point out:&#xA;&#xA;We compute the deltas and the narrowing from int64 to int32 on the buffer during the Encode()&#xA;We do the actual bit packing during the Write()&#xA;&#xA;There is some argument to make here that we can do the bit packing during the Encode() as well, but it is unlikely to matter, I believe.&#xA;In the next post, I&#x2019;m going to be diving into how we implement decoding for FastPFor. That is actually of far more interest to me, since that happens a lot more often. It&#x2019;s going to be interesting&#x2026;</p>
        </article>
        <article id="article-616">
            <a href="https://www.meziantou.net/how-to-use-runtimehelpers-isreferenceorcontainsreferences-to-micro-optimize-coll.htm" target="_blank">
                <h2 class="title mb-6" id="article-616">How to use RuntimeHelpers.IsReferenceOrContainsReferences to micro-optimize collections</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 19, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;() is a method that indicates if T is a reference type or contains a reference type. One use case for this method is to micro-optimize collections when removing items. Indeed, if T is a reference type, you need to remove the reference to the it</p>
        </article>
        <article id="article-617">
            <a href="https://ayende.com/blog/199585-A/integer-compression-adapting-fastpfor-to-ravendb" target="_blank">
                <h2 class="title mb-6" id="article-617">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 16, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this series so far, I explored several ways that we can implement integer compression. I focused on the FastPFor algorithm and dove deeply into how it works. In the last post, I showed how we can use the SIMD intrinsics to generate vectorized code that can process a lot of data very quickly.&#xA;With this baseline established, we need to understand the use case we have in RavenDB for integer compression. We are actually using this for the classic scenario, posting lists as part of the indexing engine. However, there are quite a few differences in how we want to actually utilize it.&#xA;Let&#x2019;s take Lucene as a good example, since that is one of the classic examples for a search engine. From the ground up, Lucene is meant to be used in batching scenarios. That has a lot of impact on the design. In particular, it means that a posting list for Lucene is something that you write once in a big batch of operations. For RavenDB, however, we explicitly reject his approach. We want to allow to do on-the-fly indexing and we cannot afford to pay the cost of merging many small writes to big files over time.&#xA;The FastPFor algorithm is meant to get a lot of data, encode that in a compressed form and then allow you to iterate over the results as fast as possible. But RavenDB&#x2019;s needs are different. At the most basic level, RavenDB thinks about things in 8KB pages. A posting list for RavenDB is composed of the following:&#xA;&#xA;Single &#x2013; just a single value (common when indexing unique values)&#xA;Small &#x2013; can fit in under 4KB&#xA;Large &#x2013; requires more than 4KB of data, in which case we split it on 8KB boundaries.&#xA;&#xA;What&#x2019;s the point here? The idea is that when we need to update a posting list (add or remove items), we have one of those three options:&#xA;&#xA;Single &#x2013; we just update the value, duh!&#xA;Small &#x2013; FastPFor is fast, right? It is cheap enough to unpack the compressed values, merge with the new items (or the removals) and compress again.&#xA;Large &#x2013; here we are talking about a lot of values, potentially tens of millions or higher. How do we handle updates in this case?&#xA;&#xA;The answer is that we are going to be making use of a B&#x2B; Tree, with some caveats. The basic idea is that we have two types of pages in the tree. A branch page is the classic B&#x2B; Tree concept, which points to leaf pages below it that contain some range of values. However, the leaf pages, on the other hand, are very different.&#xA;Each leaf page is just an 8KB buffer that holds the compressed data, nothing more. When we want to update the values in the posting list, we find the relevant page that needs to be updated, then we just unpack, merge &amp; compress the values. It&#x2019;s actually cheaper to go this route than any other alternative.&#xA;There is another important aspect. Lucene (and most other indexing systems) assume that your posting list is using 32 bits integers. That limits the number of items in an index to 2.1 billion (up to 4.2 billion, for some implementations). I don&#x2019;t like that limit, not at today&#x2019;s scale. So we internally use 64bits integers in our posting lists.&#xA;That&#x2026; however, is actually too big. In practice, we use 54 bits for the indexed entries. That gives us a maximum number of 18,014,398,509,481,984 items and at a range of 100,000 items per second, we are good for 5,712 years.&#xA0; Those 10 bits allow us to encode additional information about the actual entry that is being indexed, and reduce the number of external lookups we need to do. Taking 10 bits from the entry id means that we are going to hit the 32 bits limit at around 2 million entries, which is really low.&#xA;Then there is another problem, if I have a posting list I want to compress that has 100,000 items in it, I would need to compress that into multiple pages, but figuring out how to split the compressed stream in a way that makes it usable to work with is not trivial at all.&#xA;In short, we have two major concerns with using FastPFor in RavenDB, int64 and paged writes. There is another aspect that I didn&#x2019;t mention, however. FastPFor will take an array of numbers and compress them. If you want to also use delta compression, that is something that you need to add on top of that.&#xA;Now that we understand the constraints we have to operate around, let&#x2019;s talk about the kind of API that I would like to build:&#xA;&#xA;&#xA;&#xA;What is going on here?&#xA0; Well, the basic idea is that you&#x2019;ll create an encoder as part of the indexing process. For each posting list that you want to process, you&#x2019;ll call the Encode() method, passing it the data to be encoded.&#xA;The Encode() method will return the required size for encoding the entire list as a single operation. Note that it does not actually write the data out (indeed, it has nowhere to write it). The calling code is then able to make decisions based on the returned size. If they have a buffer big enough to hold the encoded data, they can pass it to the Write() method.&#xA;Things get more interesting when we don&#x2019;t have a suitable buffer. Remember that we have a limit of 4KB for small posting lists and 8KB per page for large posting lists. The idea with Write() is that it will write as much as it can to the output, allowing you to use multiple buffers to store the compressed posting list.&#xA;In terms of work being done, the Encode() phase copies the post list entries to its own buffer, preparing it to be written out. The process of actually writing the data to the output buffer is mostly concerned with ensuring that we don&#x2019;t exceed the size of the provided buffer.&#xA;This approach means that we only have to pay the encoding code once, which is quite nice. Moreover, the number of checks that we have to make to ensure that we can fit the data into the buffer is also greatly reduced.&#xA;What about decoding? That is handled using:&#xA;&#xA;&#xA;&#xA;Here we have a very interesting observation, the Encoder is a class, but the Decoder is a struct. We assume that decoding is far more frequent, so we use a struct to avoid an unnecessary memory allocation.&#xA;In order to ensure high performance, the decoder makes assumptions about the provided buffers. We will always accept a buffer that has a minimum size, for example.&#xA;With all of this out of the way, I&#x2019;m going to dedicate the next post to discussing the actual implementation and semantics we have for FastPFor encoding.</p>
        </article>
        <article id="article-618">
            <a href="https://ayende.com/blog/199553-A/integer-compression-porting-simdcomp-to-c" target="_blank">
                <h2 class="title mb-6" id="article-618">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 15, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the code of the simdcomp library there is a 25KLOC file that does evil things to SIMD registers to get bit packing to work. When I looked at the code the first few dozen times, I had a strong desire to run away screaming. Luckily, this isn&#x2019;t just some pile of complicated code, but well-thought-out set of functions that are meant to provide optimal code for specific tasks. In particular, the code is specialized for each bit width that you may want to bit pack (0 .. 32). Even better, no one actually sat down to write it out by hand, there is a Python script that would generate the code.&#xA;The first step was to understand what exactly is going on in the code, and then see how we can translate that to C#. Even just a few years ago, that would have been either an impossible dream or required the use of a native library (with the associated PInvoke overhead). However, .NET today has a very robust intrinsics support, and vectors / SIMD instructions are natively supported.&#xA;I actually had a tougher challenge, since I want this code to run on x64 and ARM64 instances. The original code is x64 only, of course. The nice thing about SIMD support for .NET is that most of that can be done in a cross platform manner, with the JIT deciding what instructions will actually be emitted. There is still a very strong correlation between the vectorized code and the instructions that are being emitted, which means that I get both great control of what is going on and the appropriate abstraction. I was actually able to implement the whole thing without dropping to architecture-specific code, which makes me very happy.&#xA;Before we get any deeper, let&#x2019;s take a simple challenge. We want to take an array of 32 integers and pack each one of them in 4 bits into an array of 16 bytes. Here is what the code will look like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public void Pack32IntsWith4Bits(int* items, byte* output) {&#xA;        &#xA;        &#xA;          &#xA;              var v = (Vector128&lt;int&gt;*)items;&#xA;        &#xA;        &#xA;          &#xA;              var mask = Vector128.Create(0x0f);&#xA;        &#xA;        &#xA;          &#xA;              var mixed = &#xA;        &#xA;        &#xA;          &#xA;                      v[0]                          &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[1], 4)  &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[2], 8)  &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[3], 12) &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[4], 16) &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[5], 20) &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[6], 24) &amp; mask |&#xA;        &#xA;        &#xA;          &#xA;                      Vector128.ShiftLeft(v[7], 28) &amp; mask ;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              mixed.AsByte().Store(output);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          pack.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is a bit dense, but let&#x2019;s see if I can explain what is going on here.&#xA;We load from the array a vector (4 items) at the 0, 4, 8, 12, 16, 20, 24, and 28 intervals. For each one of those, we shift the values by the required offset and or all of them together. Note that this means that the first item&#x2019;s four bits go in the first nibble, but the second item&#x2019;s bits go in the fifth nibble, etc.&#xA;The idea is that we are operating on 4 items at a time, reducing the total number of operations we have to perform. It may be easier to understand if you see those changes visually:&#xA;&#xA;What is happening here, however, is that we are able to do this transformation in very compact code. That isn&#x2019;t just an issue of high-level code, let&#x2019;s take a look at the assembly instructions that this generates:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Pack32IntsWith4Bits(Int32*, Byte*)&#xA;        &#xA;        &#xA;          &#xA;              L0000: vzeroupper&#xA;        &#xA;        &#xA;          &#xA;              L0003: vmovupd xmm0, [rdx]&#xA;        &#xA;        &#xA;          &#xA;              L0007: vpand xmm0, xmm0, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L000f: vmovupd xmm1, [rdx&#x2B;0x10]&#xA;        &#xA;        &#xA;          &#xA;              L0014: vpslld xmm1, xmm1, 4&#xA;        &#xA;        &#xA;          &#xA;              L0019: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L0021: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L0025: vmovupd xmm1, [rdx&#x2B;0x20]&#xA;        &#xA;        &#xA;          &#xA;              L002a: vpslld xmm1, xmm1, 8&#xA;        &#xA;        &#xA;          &#xA;              L002f: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L0037: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L003b: vmovupd xmm1, [rdx&#x2B;0x30]&#xA;        &#xA;        &#xA;          &#xA;              L0040: vpslld xmm1, xmm1, 0xc&#xA;        &#xA;        &#xA;          &#xA;              L0045: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L004d: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L0051: vmovupd xmm1, [rdx&#x2B;0x40]&#xA;        &#xA;        &#xA;          &#xA;              L0056: vpslld xmm1, xmm1, 0x10&#xA;        &#xA;        &#xA;          &#xA;              L005b: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L0063: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L0067: vmovupd xmm1, [rdx&#x2B;0x50]&#xA;        &#xA;        &#xA;          &#xA;              L006c: vpslld xmm1, xmm1, 0x14&#xA;        &#xA;        &#xA;          &#xA;              L0071: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L0079: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L007d: vmovupd xmm1, [rdx&#x2B;0x60]&#xA;        &#xA;        &#xA;          &#xA;              L0082: vpslld xmm1, xmm1, 0x18&#xA;        &#xA;        &#xA;          &#xA;              L0087: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L008f: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L0093: vmovupd xmm1, [rdx&#x2B;0x70]&#xA;        &#xA;        &#xA;          &#xA;              L0098: vpslld xmm1, xmm1, 0x1c&#xA;        &#xA;        &#xA;          &#xA;              L009d: vpand xmm1, xmm1, [0x1ed3a030110]&#xA;        &#xA;        &#xA;          &#xA;              L00a5: vpor xmm0, xmm0, xmm1&#xA;        &#xA;        &#xA;          &#xA;              L00a9: vmovdqu [r8], xmm0&#xA;        &#xA;        &#xA;          &#xA;              L00ae: ret&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          pack.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m going to assume that you aren&#x2019;t well versed with assembly, so let&#x2019;s explain what is going on. This code contains zero branches, it does four reads from memory, mask the elements, shift them and or them together.&#xA;The relevant instructions are:&#xA;&#xA;vmovupd &#x2013; read 4 integers to the register&#xA;vpand &#x2013; binary and with a value (masking)&#xA;vpslld &#x2013; shift to the left&#xA;vpor &#x2013; binary or&#xA;vmovdqu &#x2013; write 16 bytes to memory&#xA;&#xA;There are no branches, nothing to complicate the code at all. This is about as tight as you can get, at the level of machine instructions.&#xA;Of particular interest here is the C# code. The entire thing is basically a couple of lines of code, and I could express the whole thing as a single expression in a readable manner. Let&#x2019;s look at the C code, to compare what is going on:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static void pack32_4bits(const uint32_t *_in, __m128i *out) {&#xA;        &#xA;        &#xA;          &#xA;            const __m128i *in = (const __m128i *)(_in);&#xA;        &#xA;        &#xA;          &#xA;            __m128i OutReg, InReg;&#xA;        &#xA;        &#xA;          &#xA;            const __m128i mask = _mm_set1_epi32((1U &lt;&lt; 4) - 1);&#xA;        &#xA;        &#xA;          &#xA;            uint32_t outer;&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = InReg;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 1), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 2), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 3), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 4), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 5), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 6), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(in &#x2B; 7), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));&#xA;        &#xA;        &#xA;          &#xA;            _mm_storeu_si128(out, OutReg);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          pack.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Note that both should generate the same machine code, but being able to rely on operator overloading means that I can now get a far more readable code.&#xA;From that point, the remaining task was to re-write the Python script so it would generate C# code, not C. In the next post I&#x2019;m going to be talking more about the constraints we have and what we are actually trying to solve with this approach.</p>
        </article>
        <article id="article-619">
            <a href="https://ayende.com/blog/199524-C/integer-compression-the-fastpfor-code" target="_blank">
                <h2 class="title mb-6" id="article-619">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 14, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">As I mentioned, I spent quite a lot of time trying to understand the mechanism behind how the FastPFor algorithm works. A large part of that was the fact that I didn&#x2019;t initially distinguish the separate steps in the process. Finding the bits&#x27; widths, packing the bits, metadata and exception management are all integral to how this works, and I tried to grok it all in one shot. I kept getting lost in 14KLOC files with dense SIMD instructions.&#xA;When looking at the code, it is also important to keep in mind that this is not a library that you are meant to pick up &amp; use. This is a research project. As such, there was enough work done to show the results, but all the spit &amp; polish that are associated with making a library ready for general consumption weren&#x2019;t done.&#xA;A simple example of that is that the code just assumes that the output buffer provided will be large enough (with no way to estimate upfront) and will overflow the buffer if that happens. Perfectly acceptable for research code, hell no for production usage, naturally.&#xA;In the same manner, the repository contains a lot of code. Most of that is being used as part of comparing the FastPFor algorithm to various other options. That can make it hard to understand what are the core parts of the algorithm and what is effectively chuff.&#xA;To be honest, the hardest part for me, however, was figuring out the memory allocation patterns that are going on in here. There is a high usage of C&#x2B;&#x2B; containers, with implicit allocations and hidden memory management. Here is a piece of code that I had to struggle to understand for quite some time, for example:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          template &lt;class STLContainer&gt;&#xA;        &#xA;        &#xA;          &#xA;          static uint32_t *packmeupwithoutmasksimd(STLContainer &amp;source, uint32_t *out,&#xA;        &#xA;        &#xA;          &#xA;                                                   const uint32_t bit) {&#xA;        &#xA;        &#xA;          &#xA;            const uint32_t size = static_cast&lt;uint32_t&gt;(source.size());&#xA;        &#xA;        &#xA;          &#xA;            *out = size;&#xA;        &#xA;        &#xA;          &#xA;            out&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            if (source.size() == 0)&#xA;        &#xA;        &#xA;          &#xA;              return out;&#xA;        &#xA;        &#xA;          &#xA;            source.resize((source.size() &#x2B; 32 - 1) / 32 * 32);&#xA;        &#xA;        &#xA;          &#xA;            uint32_t j = 0;&#xA;        &#xA;        &#xA;          &#xA;            for (; j &#x2B; 128 &lt;= size; j &#x2B;= 128) {&#xA;        &#xA;        &#xA;          &#xA;              usimdpackwithoutmask(&amp;source[j], reinterpret_cast&lt;__m128i *&gt;(out), bit);&#xA;        &#xA;        &#xA;          &#xA;              out &#x2B;= 4 * bit;&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            for (; j &lt; size; j &#x2B;= 32) {&#xA;        &#xA;        &#xA;          &#xA;              fastpackwithoutmask(&amp;source[j], out, bit);&#xA;        &#xA;        &#xA;          &#xA;              out &#x2B;= bit;&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            out -= (j - size) * bit / 32;&#xA;        &#xA;        &#xA;          &#xA;            source.resize(size);&#xA;        &#xA;        &#xA;          &#xA;            return out;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          packmeupwithoutmasksimd.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This does bit-packing using SIMD without a mask (the naming convention is something that you really have to get used to, I don&#x2019;t think I encountered justlowercase before).&#xA;Note the call to fastpackwithoutmask() in there, it assumes that the provided buffer has exactly 32 elements. A lot of the code in the project assumes that you are passed a buffer of a certain size and operate on that directly. That produces great results in terms of efficiency and code density. But when I read this code it was &#x201C;obvious&#x201D; to me that there is an out-of-band work here. If the provided buffer isn&#x2019;t perfectly aligned on 32 boundary, that method will write read or write beyond the end of the buffer.&#xA;Look at line 9 there, where the source container is being resized to ensure that this is fine, since we increase the container size to be exactly 32 elements aligned. We revert this operation later in line 20.&#xA;For some SIMD instructions, it matters the alignment of the buffers we are working on. This is handled using a custom allocator on the containers, which is not usually something that I would pay attention to.&#xA;In short, from my perspective, there is a lot of hidden behavior in non-trivial C&#x2B;&#x2B; code usage there that masks the actual behavior of the algorithm in question.&#xA;If you are looking at FastPFor (and if you care enough to look at this series of posts, you probably should), take into consideration that this code shouldn&#x2019;t be applied as is, but should probably be adapted for your needs.&#xA;In the next post, I&#x2019;m going to start discussing how we did just that for RavenDB.</p>
        </article>
        <article id="article-620">
            <a href="https://ayende.com/blog/199523-C/integer-compression-understanding-fastpfor" target="_blank">
                <h2 class="title mb-6" id="article-620">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 13, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The FastPFor is an integer compression algorithm that was published in 2012 initially. You can read the paper about it here: Decoding billions of integers per second through vectorization.&#xA;I&#x2019;ve run into this algorithm many times in the past. You pretty much can&#x2019;t be in the database arena and not run into that. It is an interesting paper, and it has a GitHub repository with the code, which is great. Except that I couldn&#x2019;t figure out what was going on there.&#xA;I actually tried stepping through the code a bunch of times, and I always ended up getting lost. The code is in C&#x2B;&#x2B; and makes heavy use of templates, containers and non-trivial amounts of magic. To give some context, I gave up when I run into these code snippers:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          /*assumes that integers fit in the prescribed number of bits */&#xA;        &#xA;        &#xA;          &#xA;          void __fastpackwithoutmask6(const uint32_t *__restrict__ in,&#xA;        &#xA;        &#xA;          &#xA;                                      uint32_t *__restrict__ out) {&#xA;        &#xA;        &#xA;          &#xA;            Unroller&lt;6&gt;::PackNoMask(in, out);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          /*assumes that integers fit in the prescribed number of bits */&#xA;        &#xA;        &#xA;          &#xA;          void __fastpackwithoutmask7(const uint32_t *__restrict__ in,&#xA;        &#xA;        &#xA;          &#xA;                                      uint32_t *__restrict__ out) {&#xA;        &#xA;        &#xA;          &#xA;            Unroller&lt;7&gt;::PackNoMask(in, out);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          static void __SIMD_fastpackwithoutmask7_32(const uint32_t *__restrict__ _in,&#xA;        &#xA;        &#xA;          &#xA;                                                     __m128i *__restrict__ out) {&#xA;        &#xA;        &#xA;          &#xA;            const __m128i *in = reinterpret_cast&lt;const __m128i *&gt;(_in);&#xA;        &#xA;        &#xA;          &#xA;            __m128i OutReg;&#xA;        &#xA;        &#xA;          &#xA;            __m128i InReg = _mm_loadu_si128(in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = InReg;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));&#xA;        &#xA;        &#xA;          &#xA;            _mm_storeu_si128(out, OutReg);&#xA;        &#xA;        &#xA;          &#xA;            &#x2B;&#x2B;out;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_srli_epi32(InReg, 7 - 3);&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            // this method goes on for another 100 lines...&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          wow.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The paper itself describes the algorithm, but not in a way that actually made sense to me. I tried looking at the code, and I basically noped out. Too complex for me to understand, it seems.&#xA;But I kept running into this, and we recently had a strong need for something similar. So I basically took the time to meditate on this for a while.&#xA;On a personal level, I realized that I was trying to understand how the whole thing worked by just stepping through the code and reading the paper. The problem was that I was mixing several different layers and wasn&#x2019;t able to create the proper separation between them.&#xA;FastPFor builds upon the previously discussed simdcomp, once you understand that, you can go through this in isolation. For this reason, I first talked about SIMD bit-packing and showed an example usage, before actually diving into how FastPFor itself works.&#xA;As a reminder, simdcomp provides routines for quick packing and unpacking of integers, nothing more. FastPFor is where the actual compression happens. Let&#x2019;s see what is actually going on here. Consider the following list, which we previously discussed:&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;1871143144&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;7984&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;If we&#x2019;ll try bit-pack this list, we&#x2019;ll find out that we aren&#x2019;t gaining much. The first value is 31 bits in length, after all, and that means that we aren&#x2019;t able to save much. We talked about Frame of Reference (FOR) as a way to handle that. We can treat every128 block of numbers as a block that has its own reference point and compute the maximum number of bits for that location. That would actually save us a lot of space, but it isn&#x2019;t ideal. In the case above, most entries in the list can be packed in just 3 bits, except 2. That is where PFor comes into play, which stands for Patched Frame of Reference.&#xA;The key aspects of FastPFor are how it figures out what is the best size to use to pack the numbers, the way it detects what should be patched, and the manner in which it stores this.&#xA;The code boils down to a single function:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void getBestBFromData(const uint32_t *in, uint8_t &amp;bestb, uint8_t &amp;bestcexcept, uint8_t &amp;maxb) {&#xA;        &#xA;        &#xA;          &#xA;            uint32_t freqs[33];&#xA;        &#xA;        &#xA;          &#xA;            for (uint32_t k = 0; k &lt;= 32; &#x2B;&#x2B;k)&#xA;        &#xA;        &#xA;          &#xA;              freqs[k] = 0;&#xA;        &#xA;        &#xA;          &#xA;            for (uint32_t k = 0; k &lt; BlockSize; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;              freqs[asmbits(in[k])]&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            bestb = 32;&#xA;        &#xA;        &#xA;          &#xA;            while (freqs[bestb] == 0)&#xA;        &#xA;        &#xA;          &#xA;              bestb--;&#xA;        &#xA;        &#xA;          &#xA;            maxb = bestb;&#xA;        &#xA;        &#xA;          &#xA;            uint32_t bestcost = bestb * BlockSize;&#xA;        &#xA;        &#xA;          &#xA;            uint32_t cexcept = 0;&#xA;        &#xA;        &#xA;          &#xA;            bestcexcept = static_cast&lt;uint8_t&gt;(cexcept);&#xA;        &#xA;        &#xA;          &#xA;            for (uint32_t b = bestb - 1; b &lt; 32; --b) {&#xA;        &#xA;        &#xA;          &#xA;              cexcept &#x2B;= freqs[b &#x2B; 1];&#xA;        &#xA;        &#xA;          &#xA;              uint32_t thiscost = cexcept * overheadofeachexcept &#x2B;&#xA;        &#xA;        &#xA;          &#xA;                                  cexcept * (maxb - b) &#x2B; b * BlockSize &#x2B;&#xA;        &#xA;        &#xA;          &#xA;                                  8; // the  extra 8 is the cost of storing maxbits&#xA;        &#xA;        &#xA;          &#xA;              if (thiscost &lt; bestcost) {&#xA;        &#xA;        &#xA;          &#xA;                bestcost = thiscost;&#xA;        &#xA;        &#xA;          &#xA;                bestb = static_cast&lt;uint8_t&gt;(b);&#xA;        &#xA;        &#xA;          &#xA;                bestcexcept = static_cast&lt;uint8_t&gt;(cexcept);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getBestBFromData.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What is going on here? This function accepts an array of integers (whose size is 128) and computes the best number of bits to use to pack it.&#xA;How does that work? The first thing this does is compute how many numbers we have for each bit range. This is done using the asmbits() call, which is basically a LeadingZeroCount(). The end result is a frequency map that we can use to estimate how many bits will be required to store the items from this block.&#xA;We start from the maximum number of bits that we need to store all the numbers in the block, and we go down, checking what would be the best cost (in terms of space). Since we need to store exceptions somewhere, we compute the cost of that as we go down in the list.&#xA;This function gives us:&#xA;&#xA;bestb &#x2013; the number of bits needed to pack all the items in the block that would result in the&#xA0;smallest output size&#xA;bestcexception &#x2013; the count of exceptions (numbers that do not fit into bestb bits&#xA;maxb &#x2013; the maximum number of bits that we need to store for this block&#xA;&#xA;That is the key function, the one that is responsible for getting the best compression ratio.&#xA;What I found that made FastPFor challenging to understand is that it has a lot of state that you need to keep track of. What I described so far is a single block, but FastPFor operates over sets of numbers, and so needs to tie all of them together.&#xA;At any given point, FastPFor has:&#xA;&#xA;The block that is being outputted&#xA;The metadata about the entire process&#xA;32 arrays of exceptions&#xA;&#xA;The process interleaves all of them together in interesting ways, and I had a hard time figuring out how it all ties together.&#xA;Let&#x2019;s talk about the way FastPFor processes a single block. We process the data in the array in blocks of 128 numbers at a time, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (const uint32_t *const final = in &#x2B; length; (in &#x2B; BlockSize &lt;= final);&#xA;        &#xA;        &#xA;          &#xA;               in &#x2B;= BlockSize) {&#xA;        &#xA;        &#xA;          &#xA;            uint8_t bestb, bestcexcept, maxb;&#xA;        &#xA;        &#xA;          &#xA;            getBestBFromData(in, bestb, bestcexcept, maxb);&#xA;        &#xA;        &#xA;          &#xA;            *bc&#x2B;&#x2B; = bestb;&#xA;        &#xA;        &#xA;          &#xA;            *bc&#x2B;&#x2B; = bestcexcept;&#xA;        &#xA;        &#xA;          &#xA;            if (bestcexcept &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;              *bc&#x2B;&#x2B; = maxb;&#xA;        &#xA;        &#xA;          &#xA;              std::vector&lt;uint32_t, cacheallocator&gt; &amp;thisexceptioncontainer =&#xA;        &#xA;        &#xA;          &#xA;                  datatobepacked[maxb - bestb];&#xA;        &#xA;        &#xA;          &#xA;              const uint32_t maxval = 1U &lt;&lt; bestb;&#xA;        &#xA;        &#xA;          &#xA;              for (uint32_t k = 0; k &lt; BlockSize; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;                if (in[k] &gt;= maxval) {&#xA;        &#xA;        &#xA;          &#xA;                  // we have an exception&#xA;        &#xA;        &#xA;          &#xA;                  thisexceptioncontainer.push_back(in[k] &gt;&gt; bestb);&#xA;        &#xA;        &#xA;          &#xA;                  *bc&#x2B;&#x2B; = static_cast&lt;uint8_t&gt;(k);&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            out = packblockupsimd(in, out, bestb);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ProcessBlock.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The first thing that happens is the computation of the best bits widths for the current block. Then, we use the bc value to record the metadata about the block.&#xA;That is an array of bytes with the following format:&#xA;&#xA;Packed number of bits&#xA;Number of exceptions&#xA;&#xA;If there are exceptions for this block, we also add:&#xA;&#xA;Maximum number of bits&#xA;Offset of exception in the block (repeated as the number of exceptions)&#xA;&#xA;The metadata is shared for the entire encoding operation, across blocks.&#xA;You can see in the code that if bestcexcept (which holds the number of exceptions) is greater than zero, we find the appropriate exceptions buffer to use. That requires a better explanation.&#xA;the getBestBFromData() call gave us two important data points, the best number of bits to pack the numbers, and the maximum number. We are going to pack all the numbers in the block to the output, but what about the exceptions? Where do they go?&#xA;It turns out that we need to store the exceptions, but we don&#x2019;t actually need to store max bits, only the difference between the best number of bits and the maximum. This is what thisexceptioncontainer is holding, the remainding bits for exceptions. It&#x2019;s important to understand that this is done across blocks. So the thisexceptioncontainer value holds exceptions from many different blocks. That will turn out to be very important in just a little bit. We then scan the block and write the remainding bits to the container, and write to the metadata the offset of the value in the block. Since we are using blocks of 128 numbers, this is ensured to fit inside a byte.&#xA;The last step that we do for the block is to call: packblockupsimd(), this ends up calling to simdpack() and packs all the numbers from the block to bestb bits in the output.&#xA;It&#x2019;s really important to understand that we still have two data items that haven&#x2019;t been written. The first is the metadata for the encoding process (bits in blocks, exceptions offsets, etc). The second is the set of exceptions themselves.&#xA;This process repeats itself for each block, until the end of the buffer. It is at this point that we need to write the remaining data to the output. Here is what the code looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const uint32_t bytescontainersize =&#xA;        &#xA;        &#xA;          &#xA;              static_cast&lt;uint32_t&gt;(bc - &amp;bytescontainer[0]);&#xA;        &#xA;        &#xA;          &#xA;          *(out&#x2B;&#x2B;) = bytescontainersize;&#xA;        &#xA;        &#xA;          &#xA;          memcpy(out, &amp;bytescontainer[0], bytescontainersize);&#xA;        &#xA;        &#xA;          &#xA;          uint8_t* pad8 = (uint8_t*)out &#x2B; bytescontainersize;&#xA;        &#xA;        &#xA;          &#xA;          out &#x2B;= (bytescontainersize &#x2B; sizeof(uint32_t) - 1) / sizeof(uint32_t);&#xA;        &#xA;        &#xA;          &#xA;          while (pad8 &lt; (uint8_t*)out)&#xA;        &#xA;        &#xA;          &#xA;              *pad8&#x2B;&#x2B; = 0; // clear padding bytes&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uint32_t bitmap = 0;&#xA;        &#xA;        &#xA;          &#xA;          for (uint32_t k = 2; k &lt;= 32; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;              if (datatobepacked[k].size() != 0)&#xA;        &#xA;        &#xA;          &#xA;                  bitmap |= (1U &lt;&lt; (k - 1));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          *(out&#x2B;&#x2B;) = bitmap;&#xA;        &#xA;        &#xA;          &#xA;          for (uint32_t k = 2; k &lt;= 32; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;              if (datatobepacked[k].size() &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;                  out = packmeupwithoutmasksimd(datatobepacked[k], out, k);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          final.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What is going on? This is dense, and it takes a while to unpack (pun intended) what is going on here.&#xA;First, we write the size of the metadata and then we copy the metadata that we have to the output. That is the description of all the blocks that we just went over. Then, we run over the set of exceptions that we gathered. Remember, the datatobepacked is an array that holds lists of exception data for each bit range that we have to store. We iterate over all the bit widths where we wrote exception data and generate a bitmap. That will help us later during the decoding process.&#xA;Finally, we run over the same exceptions and write them out. Note that we do that using the same simd bit-packing approach as the rest of the code.&#xA;The end result is that we have the following format:&#xA;&#xA;For decoding, we start from the metadata offset and jump to that. Then we read the exceptions bitmap. That tells us how many exceptions we have and how many bits we have in each one of them. In the image above, you can see that we have 3 exceptions list, for 4 bits, 12 bits and 19 bits.&#xA;We use the simd bit-packing to decode those values into memory. We&#x2019;ll need them shortly.&#xA0; Now, we start iterating over the metadata, each block has an overhead of minimum two metadata bytes (number of bits and number of exceptions). Let&#x2019;s assume that we don&#x2019;t have any exceptions in the block. In that case, the process of decoding is simple. Just do the unpacking from bits to numbers and you are done.&#xA;If we have exceptions, on the other hand, we have to deal with them. At that point, the next metadata byte would contain the maximum number of bits for the exceptions in this block. Using that and the normal number of bits, we can tell where the extra bits are located. Here is the relevant code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (uint32_t run = 0; run &lt; nvalue / BlockSize; &#x2B;&#x2B;run, out &#x2B;= BlockSize) {&#xA;        &#xA;        &#xA;          &#xA;            const uint8_t b = *bytep&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            const uint8_t cexcept = *bytep&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            in = unpackblocksimd(in, out, b);&#xA;        &#xA;        &#xA;          &#xA;            if (cexcept &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;              const uint8_t maxbits = *bytep&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              if (maxbits - b == 1) {&#xA;        &#xA;        &#xA;          &#xA;                for (uint32_t k = 0; k &lt; cexcept; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;                  const uint8_t pos = *(bytep&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  out[pos] |= static_cast&lt;uint32_t&gt;(1) &lt;&lt; b;&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              } else {&#xA;        &#xA;        &#xA;          &#xA;                std::vector&lt;uint32_t, cacheallocator&gt;::const_iterator &amp;exceptionsptr =&#xA;        &#xA;        &#xA;          &#xA;                    unpackpointers[maxbits - b];&#xA;        &#xA;        &#xA;          &#xA;                for (uint32_t k = 0; k &lt; cexcept; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;                  const uint8_t pos = *(bytep&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  out[pos] |= (*(exceptionsptr&#x2B;&#x2B;)) &lt;&lt; b;&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          decoding.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Note that there is a special case here if the difference in the number of bits between the block bits and the maximum number of bits is one. In that case, we don&#x2019;t need to store the data, we already know what the value is then (it&#x2019;s one, after all). So we can compute it once and set it in the output.&#xA;For scenarios where we can&#x2019;t tell from the bit width along, we read the relevant exception array based on the difference between the bits in the block and the exceptions bits. That gives us an array that is shared across blocks. The idea is that the metadata contains the offset in the block, and we read from the relevant array one item at a time. This two-step process will result in us setting the right value and getting ready for the next call, which may be done in a different block.&#xA;Note that the exception bits buffers only care about the number of bits, not where they come from. So two blocks, which have (bestb: 4, maxb: 9) and (bestb: 7: maxb: 10) will both go to the 3 bits container.&#xA;Okay, this blog post is getting long enough, so I think that would be it. Hopefully, it will make it easier to understand exactly how the FastPFor format is working. I&#x2019;m going to be talking more about FastPFor and the format implications in the next post, then move on to actually using that in C#.</p>
        </article>
        <div class="button flex justify-between">
            <a href="61.html"><span class="back arrow"></span></a>

            <a href="63.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>