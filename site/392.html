
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 392 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-3911">
            <a href="https://ayende.com/blog/164801/more-on-collection-performance-immutability-and-designing-for-a-specific-scenario" target="_blank">
                <h2 class="title mb-6" id="article-3911">More on collection performance, immutability and designing for a specific scenario</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 12, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Note: I started writing a few minutes after starting the performance test, it took that long to run. As you are probably already aware, we used the Immutable Collections package in Voron. That turned out to be a cause for pretty major performance issues, so I started investigating other approaches for dealing with the problem of both immutability and high performing code. Before I go on, I would like to explain what we are using the immutable collections for. Basically, we have a page translation table, which tells us which pages belong where. This table changes on every write transaction. However, locking isn&#x2019;t a good option for us, because once started, the transaction view of the world can never be changed. That means that while we are modifying it in a write transaction, the read transaction should not ever see the modifications. This is exactly the case where immutable collections make sense. Read only views aren&#x2019;t going to work, since once the write tx modify the page table, that change is going to be visible to read transactions, which isn&#x2019;t what we want. Our test scenario is that after each write tx commit, we will update the page table with all the new pages locations. That means that we wrote the following test case:      1: var tmp = new Dictionary&lt;long, object&gt;();   2:&#xA0;    3: var sp = Stopwatch.StartNew();   4: var rnd = new Random(32);   5: for (int i = 0; i &lt; iterations; i&#x2B;&#x2B;)   6: {   7:     foreach (var item in Enumerable.Range(rnd.Next(0, i), Math.Max(i * 2, 16)))   8:     {   9:         tmp[item] = null;  10:     }  11: }  12:&#xA0;   13: Console.WriteLine(sp.Elapsed &#x2B; &quot; Adding items, mutable dictionary&quot;);&#xA;Every iteration is a &#x201C;transaction&#x201D;, and the work inside the for loop simulate us updating the page locations. Note, however, that the code above uses a mutable dictionary, and the changes are neither thread safe, nor are we isolating other readers from seeing our changes.&#xA;We can do this using immutable dictionary using the following code:&#xA;&#xA;&#xA;   1: var dic = ImmutableDictionary&lt;long, object&gt;.Empty;   2:&#xA0;    3: var sp = Stopwatch.StartNew();   4:&#xA0;    5: var rnd = new Random(32);   6: for (int i = 0; i &lt; iterations; i&#x2B;&#x2B;)   7: {   8:     var tmp = new Dictionary&lt;long, object&gt;();   9:     foreach (var item in Enumerable.Range(rnd.Next(0, i), Math.Max(i * 2, 16)))  10:     {  11:         tmp[item] = null;  12:     }  13:&#xA0;   14:     dic = dic.SetItems(tmp);  15: }  16:&#xA0;   17: Console.WriteLine(sp.Elapsed &#x2B; &quot; Adding items, immutable dictionary&quot;);&#xA;Note that we are using the optimal &#x201C;SetItems&#x201D; method, so we only modify the immutable dictionary once per transaction. That means that we create roughly 1 instance per transaction.&#xA;I then decided to see what would be the cost of running this with 50,000 transactions. Note that this means that in the end we have 149,697 items in the dictionary.&#xA;&#xA;Cost for running this in mutable dictionary: 1 minute and 12 seconds.&#xA;Cost for running this in immutable dictionary: About 30 minutes.&#xA;Cost for reading 10,000 items from the dictionary:&#xA;&#xA;0.0002 seconds for mutable dictionary&#xA;0.0061 seconds for immutable dictionary&#xA;Remember, the reason we go to this place is because we actually got performance issues specifically because of the SetItems calls. But note that we also have a performance problem for reads as well.&#xA;Initially, I tried to do the simple thing of just creating a new instance for every transaction. That worked quite nicely to remove the read costs, but it had a non trivial cost for adds, quite aside from the GC cost. The test is:&#xA;&#xA;&#xA;   1: var dic = new Dictionary&lt;long, object&gt;();   2:&#xA0;    3: var sp = Stopwatch.StartNew();   4: var rnd = new Random(32);   5: for (int i = 0; i &lt; iterations; i&#x2B;&#x2B;)   6: {   7:     var tmp = new Dictionary&lt;long, object&gt;();   8:     foreach (var item in Enumerable.Range(rnd.Next(0, i), Math.Max(i * 2, 16)))   9:     {  10:         tmp[item] = null;  11:     }  12:     dic = new Dictionary&lt;long, object&gt;(dic);  13:     foreach (var o in tmp)  14:     {  15:         dic[o.Key] = o.Value;  16:     }  17: }  18:&#xA0;   19: Console.WriteLine(sp.Elapsed &#x2B; &quot; Adding items, safe dictionary&quot;);&#xA;Cost for adding using new instance every time:&#xA;&#xA;7 minutes and 37 seconds. &#xA;So right off the bat, we are over 4 times faster than immutable dictionary. But this is still expensive. But at least is has the same read speed as a standard dictionary, because it is.&#xA;In order to deal with that, I created something that I call LinkedDictionary. A linked dictionary is based on the following idea: Since dictionaries can only contain a single value per item, it is perfectly safe to layer them on one another. This means that we can just have a linked list of dictionaries, and when we want to read from it, we just need to walk through the list in reverse addition order. That means that it is pretty much perfect for append only linked list model.&#xA;The downside of that is that we now have to traverse the linked list in order to find our value. The good thing about this is that we are able to limit that, by introducing a merge step along the way. The merge step would merge all the pending parts into a single dictionary. Currently we are doing a merge every 32 writes or so. This strikes a nice balance between read and write speed.&#xA;The end result is that for 50,000 iterations, we have the following values:&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;Mutable Dictionary&#xA;Immutable Dictionary&#xA;Cloned Dictionary&#xA;Linked Dictionary&#xA;&#xA;50,000 adds&#xA;&#xA;1 minutes and 12 seconds&#xA;&#xA;29 minutes and 28 seconds&#xA;&#xA;7 minutes and 37 seconds&#xA;&#xA;4 minutes and 37 seconds&#xA;&#xA;10,000 reads&#xA;&#xA;0.0002 seconds&#xA;&#xA;0.0064&#xA;&#xA;0.0002 seconds&#xA;&#xA;0.0032&#xA;In other words, we are able to get write speeds that are just about 4 times the standard mutable behavior, and we are able to get read speeds that are half the immutable dictionary model.&#xA;For reference, the entire code is in the following gist.</p>
        </article>
        <article id="article-3912">
            <a href="https://ayende.com/blog/164772/the-cost-of-select-count-from-tbl" target="_blank">
                <h2 class="title mb-6" id="article-3912">The cost of select count(*) from tbl</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I was always somewhat baffled that something that was so obviously required so often can be so expensive with RDBMSes. When diving deep into B-Tree implementation I suddenly found it obvious why that is the case. Let us look at the following B-Tree:  Now, if I asked you how many entries you had in this tree, you would have to visit each and every page. And that can be very expensive when you have large number of items. But why can&#x2019;t we just keep track of the total number ourselves? There is counting B-Trees that we can use that will give us the answer in O(1) time. The answer to that is that it is too expensive to maintain this. Imagine a big tree, with 10 million records, and a fan out of 16 keys per page. That means that it has a depth of 6. Let us say that we want to add a new record. We can do that by modifying and saving the page. That would cost us 4KB of writes. However, if we use a counting B-Tree, we have to update all of the parent pages. With a depth of 6, that means that instead of writing 4KB to disk we will have to write 24KB to disk. And probably have to do multiple seeks to actually do the write properly. That is an unacceptable performance cost, and the reason why you have to manually check all the pages when you want the full count.</p>
        </article>
        <article id="article-3913">
            <a href="https://ayende.com/blog/164770/hotspot-shell-game" target="_blank">
                <h2 class="title mb-6" id="article-3913">HotSpot Shell Game</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 10, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">One of the annoying things about doing performance work is that you sometimes feel like you found the problem. You fix it, and another pops out. After the previous run of work, we have tackled two important perf issues:  Immutable collections &#x2013; which were replaced with more memory intensive but hopefully faster safe collections. Transaction contention from background work &#x2013; which we reduced and close to eliminated. Once we have done that, it is time to actually look at the code in the profiler again. Note that I am writing this while I am traveling on the train (on battery power), so you can pretty much ignore any actual numbers, we want to look at the percentages.  Let us look at the contention issue first. Here is the old code:   And the new one:   We still have some cost, but that appears to have been drastically cut down. I&#x2019;ll call it good for now. What about transaction commit? Here is the old code:    And here is the new one:   What we can see is that our change didn&#x2019;t actually improve anything much. In fact, we are worse off. We&#x2019;ll probably go with a more complex system of chained dictionaries, rather than the just plain copying that appears to be causing so much trouble. However, there is something else to now. Both Commit and NewTransaction together are less than 60% of the cost of the operation. The major cost is actually in adding item to the in memory tree:   In particular, it looks like finding the right page to place the item is what is costing us so much. We added 2 million items (once sequential, once random), which means that we need to do an O(logN) operation 2 million times. I don&#x2019;t know if we can improve on the way it works for random writes, but we should be able to do something about how it behaves for sequential writes.  a</p>
        </article>
        <article id="article-3914">
            <a href="https://www.meziantou.net/code-contracts.htm" target="_blank">
                <h2 class="title mb-6" id="article-3914">Code Contracts</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 10, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">J&#x27;ai &#xE9;crit un article sur un autre blog:Envie de savoir si votre code fonctionne avant m&#xEA;me de l&#x27;ex&#xE9;cuter, vous en r&#xEA;vez, Microsoft l&#x27;aL&#x27;article complet est diponible &#xE0; l&#x27;URL&#xA0;: https://www.softfluent.fr/blog/expertise/Code-ContractsDo you have a question or a suggestion about this post? Contact me!</p>
        </article>
        <article id="article-3915">
            <a href="https://ayende.com/blog/164769/safelist-safedictionary-fast-immutable-structures" target="_blank">
                <h2 class="title mb-6" id="article-3915">SafeList, SafeDictionary&#x2013;fast immutable structures</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 09, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After the issues we run into with immutable structures, I decided that I still wanted to maintain the same guarantees that immutable data structures gave us, but that still maintain the speed of mutable structures. I managed to do that by making different design choices when building my implementation. While the BCL immutable collections are based on binary trees, and attempt to spare GC pressure in favor of CPU cycles, I find that for a lot of the things that we do, we can spare the memory in favor of actually being faster overall. In particular, this is true since the immutable collections are order of magnitude slower for reads than their mutable counterparts. I could have dealt with the slow writes, somehow. But we do a lot of reads, and that is utterly unacceptable. Here is how I implemented SafeList:      1: public class SafeList&lt;T&gt; : IEnumerable&lt;T&gt;   2: {   3:     List&lt;T&gt; _inner = new List&lt;T&gt;();   4:&#xA0;    5:     public static readonly SafeList&lt;T&gt; Empty = new SafeList&lt;T&gt;();   6:&#xA0;    7:     private SafeList()   8:     {   9:&#xA0;   10:     }  11:&#xA0;   12:     public SafeList&lt;T&gt; AddRange(IEnumerable&lt;T&gt; items)  13:     {  14:         var inner = new List&lt;T&gt;(_inner);  15:         inner.AddRange(items);  16:         return new SafeList&lt;T&gt;  17:         {  18:             _inner = inner  19:         };  20:     }  21:&#xA0;   22:     public SafeList&lt;T&gt; Add(T item)  23:     {  24:         return new SafeList&lt;T&gt;  25:         {  26:             _inner = new List&lt;T&gt;(_inner) {item}  27:         };  28:     }  29:&#xA0;   30:     public int Count  31:     {  32:         get { return _inner.Count; }  33:     }  34:&#xA0;   35:     public T this[int i]  36:     {  37:         get { return _inner[i]; }  38:     }  39:&#xA0;   40:&#xA0;   41:     public SafeList&lt;T&gt; RemoveAll(Func&lt;T, bool&gt; filter)  42:     {  43:         return new SafeList&lt;T&gt;  44:         {  45:             _inner = new List&lt;T&gt;(_inner.Where(x =&gt; filter(x) == false))  46:         };  47:     }  48:&#xA0;   49:     public T Find(Predicate&lt;T&gt; predicate)  50:     {  51:         return _inner.Find(predicate);  52:     }  53:&#xA0;   54:     public SafeList&lt;T&gt; RemoveAllAndGetDiscards(Predicate&lt;T&gt; filter, out List&lt;T&gt; discards)  55:     {  56:         var list = new List&lt;T&gt;();  57:&#xA0;   58:         discards = list;  59:&#xA0;   60:         return new SafeList&lt;T&gt;  61:         {  62:             _inner = new List&lt;T&gt;(_inner.Where(x =&gt;  63:             {  64:                 if (filter(x) == false)  65:                 {  66:                     list.Add(x);  67:                     return false;  68:                 }  69:                 return true;  70:             }))  71:         };  72:&#xA0;   73:     }  74: }&#xA;The implementation for SafeDictionary is pretty similar as well. Note that I have dedicated &amp; optimized methods for the type of things that I need in my code.&#xA;But the key part here is that I gain the safety by always creating another copy of the underlying implementation. We are never actually mutating anything. &#xA;Sure, this results in us having to deal with a lot more allocations, but we get the same speed for reads as you do for the standard mutable collections. And more importantly, we are still faster for writes.</p>
        </article>
        <article id="article-3916">
            <a href="https://ayende.com/blog/164740/immutable-collections-performance-take-ii" target="_blank">
                <h2 class="title mb-6" id="article-3916">Immutable collections performance, take II</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 06, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Why is the performance of an immutable list over 16 times slower than a standard list? I took a peek at what it was actually doing, and it made a lot of sense. In order to maintain efficient indexing access, the actual storage of the data in the immutable list is a binary tree. With the key being used as the indexer. This result is a much higher cost for pretty much everything. Let us look at the following:      1: var listsp = Stopwatch.StartNew();   2: var list = new List&lt;int&gt;(Enumerable.Range(0, 10*1000*1000));   3:&#xA0;    4: for (int i = 0; i &lt; list.Count; i&#x2B;&#x2B;)   5: {   6:     var _ = list[i];   7: }   8:&#xA0;    9: Console.WriteLine(listsp.Elapsed);  10:&#xA0;   11: var ilist = ImmutableList&lt;int&gt;.Empty.AddRange(list);  12: listsp.Restart();  13:&#xA0;   14: for (int i = 0; i &lt; ilist.Count; i&#x2B;&#x2B;)  15: {  16:     var _ = ilist[i];  17: }  18: Console.WriteLine(listsp.Elapsed);&#xA;This List&lt;T&gt; is 0.23 seconds, ImmutableList&lt;T&gt; takes 1.28 seconds. When I use foreach, instead, we get 0.22 seconds vs. 2.29 seconds.&#xA;As you can see from the blog post describing them, because immutable collections are mostly implemented as binary trees, I don&#x2019;t really think that there is a good way to approach this as is. The problem is that the immutable collections actually need to do a lot more than what I need them to do.&#xA;Now, it might have been more acceptable to use them if the perf was limited to just writing to them, it might have been acceptable. But as you can see, we have the same problem when we are reading, and that is quite unacceptable.</p>
        </article>
        <article id="article-3917">
            <a href="https://ardalis.com/configuring-performance-counters-to-run-over-time/" target="_blank">
                <h2 class="title mb-6" id="article-3917">Configuring Performance Counters to Run Over Time</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 05, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Whether you&#x2019;re looking to diagnose performance problems, or just to keep an eye on the health of a server you rely on, knowing how to&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-3918">
            <a href="https://ardalis.com/moores-law-and-the-hybrid-mobile-application/" target="_blank">
                <h2 class="title mb-6" id="article-3918">Moores Law and the Hybrid Mobile Application</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 05, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you&#x2019;re building software today, you&#x2019;ve probably faced the question of whether or not you need to build a mobile version of your&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-3919">
            <a href="https://ayende.com/blog/164739/immutable-collections-performance" target="_blank">
                <h2 class="title mb-6" id="article-3919">Immutable Collections performance</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 05, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After finding out that a lot of our costs in Voron is actually related to immutable collections, I decided to run some isolated perf tests.          1: private static void Dictionary()   2: {   3:     var dic = new Dictionary&lt;object, object&gt;();   4:     var sp = Stopwatch.StartNew();   5:&#xA0;    6:     for (int i = 0; i &lt; 10*1000*1000; i&#x2B;&#x2B;)   7:     {   8:         var obj = new object();   9:         dic[obj] = obj;  10:     }  11:&#xA0;   12:     Console.WriteLine(sp.Elapsed);  13: }                                                          &#xA;&#xA;&#xA;   1: private static void ImmutableDictionary()   2: {   3:     var dic = ImmutableDictionary&lt;object,object&gt;.Empty;   4:     var sp = Stopwatch.StartNew();   5:&#xA0;    6:     for (int i = 0; i &lt; 10 * 1000 * 1000; i&#x2B;&#x2B;)   7:     {   8:         var obj = new object();   9:         dic = dic.SetItem(obj, obj);  10:     }  11:&#xA0;   12:     Console.WriteLine(sp.Elapsed);  13: }&#xA;&#xA;&#xA;3.639 seconds&#xA;&#xA;1 minute and 58 seconds&#xA;Yes, that is correct, the immutable version is over thirty times slower. And given that we are only using 10 million items, that is a ridiculous high rate.&#xA;I decided to do some tests to see if it is just the number of calls that we are making here:&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;   1: private static void ImmutableDictionary()   2: {   3:     var dic = ImmutableDictionary&lt;object,object&gt;.Empty;   4:     var sp = Stopwatch.StartNew();   5:&#xA0;    6:     dic = dic.SetItems(Enumerable.Range(0, 10*1000*1000).Select(i =&gt;   7:     {   8:         var obj = new object();   9:         return new KeyValuePair&lt;object, object&gt;(obj, obj);  10:     }));  11:       12:     Console.WriteLine(sp.Elapsed);  13: }&#xA;&#xA;&#xA;1 minute&#xA;So that it appears that it isn&#x2019;t the number of calls, but something intrinsic to the way it works. And how about lists?&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;   1: private static void List()   2: {   3:     var list = new List&lt;object&gt;();   4:     var sp = Stopwatch.StartNew();   5:&#xA0;    6:     for (int i = 0; i &lt; 10 * 1000 * 1000; i&#x2B;&#x2B;)   7:     {   8:         var obj = new object();   9:         list.Add(obj);  10:     }  11:&#xA0;   12:     Console.WriteLine(sp.Elapsed);  13: }                                                           &#xA;&#xA;&#xA;   1: private static void ImmutableList()   2: {   3:     var list = ImmutableList&lt;object&gt;.Empty;   4:     var sp = Stopwatch.StartNew();   5:&#xA0;    6:     for (int i = 0; i &lt; 10 * 1000 * 1000; i&#x2B;&#x2B;)   7:     {   8:         var obj = new object();   9:         list = list.Add(obj);  10:     }  11:&#xA0;   12:       13:     Console.WriteLine(sp.Elapsed);  14: }&#xA;&#xA;&#xA;0.9 seconds&#xA;&#xA;16 seconds&#xA;Ouch.&#xA;I think we are going to need to do something about this, even though I love the idea of immutable collections, 16 &#x2013; 32 times slower is just going to be utterly unacceptable.&#xA;But this is for writes, how about reads?&#xA;I had written the following for both of them:&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;   1: var sp = Stopwatch.StartNew();   2: for (int i = 0; i &lt; 10*1000*1000; i&#x2B;&#x2B;)   3: {   4:     object value;   5:     dic1.TryGetValue(i, out value);   6: }   7:&#xA0;    8: Console.WriteLine(sp.Elapsed);&#xA;&#xA;&#xA;   1: var sp1 = Stopwatch.StartNew();   2:&#xA0;    3: for (int i = 0; i &lt; 10 * 1000 * 1000; i&#x2B;&#x2B;)   4: {   5:     object value;   6:     dic2.TryGetValue(i, out value);   7: }   8: Console.WriteLine(sp1.Elapsed);&#xA;&#xA;&#xA;0.45 seconds&#xA;&#xA;3.11 seconds&#xA;So the summary is, the performance for our workloads is probably going to be simply unacceptable. We&#x2019;ll have to find another way to handle this. The way to handle this nicely is to basically copy the values. So I wanted to know how long it would take to fully clone a 10 millions items dictionary. The answer: 0.6 seconds. Doing the same with immutable dictionary? 16 seconds.&#xA;So we are going to need to do something else .</p>
        </article>
        <article id="article-3920">
            <a href="https://ayende.com/blog/164738/fruits-of-the-poisonous-tree-voron-performance-refactoring" target="_blank">
                <h2 class="title mb-6" id="article-3920">Fruits of the poisonous tree: Voron performance refactoring</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 04, 2013
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Earlier this month I posted our results for the initial performance of Voron. We learned a lot from that, and it led us to do some major refactoring to the codebase. Now, we are back on a more or less stable ground, so it is time to actually see what is going on. Where before we had a baseline against other storage engines, now we are testing against the previous version as well as Esent. To get a good and fixed numbers, I decided to run the tests on a EC2 machine, in particular, an m1.large instance. The idea is that this gives us a simple way to get a standard machine config that anyone can use to test out as well. For the purpose of this benchmark, we are doing writes to one of the temporary storage disks, rather than a permanent EBS drive. This will presumably be somewhat faster than real world configuration, but I think that running in an environment where we are actually using a common production machine (rather than a dedicated development machine) should give us better numbers, certainly more realistic ones. The first thing to check, of course, is the simplest. Sequential writes: &#xA0; Here we can see that we are actually worse off than we were before. That is actually kind of sad. But we&#x2019;ll get to that later on. For random reads, we are still very good, and it is obvious that we are pretty early make use of all of the resources that the machine gives us. Here we are consistently slightly faster than the older version, but that is something that is probably accidental. We certainly did no work on improving read performance (there was very little need to do so, after all).  Random writes was&#xA0; a big surprise:  As it happens, it appears that we are faster, significantly so, than Esent in this scenario. Which was quite a surprise. For some reason, we are also faster in the new code than the old version. Which is quite interesting. Finally, we have random reads.   No, it isn&#x2019;t an error. We see a rate of ~1,600 reads/sec for Esent single threaded. I am not quite sure why this is behaving in this fashion, but I am willing to say that there is something wrong and just discount this result. I mentioned before that it appears that we are actually slower than the old code. So I decided to check what is actually going on there. My tool of choice, the profiler.&#xA0; Here is the old version:  You can see that we have done two runs (one sequential, one random) of 10,000 transactions, writing a total of 2 million items. And roughly 26% of the time is spent committing the transaction. Digging into that, a lot of that time is spent just flushing to disk:   Note, however, that a decidedly non trivial amount of time is actually spent on ImmutableDictionary, but I&#x2019;ll touch on that later on. With our changes, the new code looks like:  The one thing that jumps at me is that the cost of creating a transaction is now very significant. And here is why:  The actual reason for this is likely that we also have the background journal flushing, that now also needs to take the transaction lock. Which is introducing contention into the mix. We&#x2019;ll need to look into how to resolve that. Let us dig into the commit. The change there was pretty much the whole reason for what we were doing.  You can see that we are using WriteFileGather, and unlike before, where syncing took about 15% of the overall time. Now it is taking just 7%. So we are better than 50% improvement on that score. But the really interesting bit? Look at what was by far the most expensive operation there. It was the calls to immutable dictionary. In fact, let us look at the results in the profiler for the immutable collections:   So now we have two new things that we need to investigate. One is reducing contentions, and the second is checking how we can optimize our usage of the immutable collections. I&#x2019;ll report on our finding&#x2026;</p>
        </article>
        <div class="button flex justify-between">
            <a href="391.html"><span class="back arrow"></span></a>

            <a href="393.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>