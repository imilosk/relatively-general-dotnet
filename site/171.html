
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 171 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-1701">
            <a href="https://www.stevejgordon.co.uk/httpclient-connection-pooling-in-dotnet-core" target="_blank">
                <h2 class="title mb-6" id="article-1701">HttpClient Connection Pooling in .NET Core</h2>
            </a>
            <p class="mb-2">by Steve Gordon</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 19, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">It&#x2019;s been some time since I produced a HttpClient related blog post. This one has been on my list to complete for quite a while. I want to cover something pretty important which happened in .NET Core 2.1 with regard to lifetime management of HTTP connections. TL;DR;HttpClient in .NET Core (since 2.1) performs connection pooling [&#x2026;]</p>
        </article>
        <article id="article-1702">
            <a href="https://ayende.com/blog/189121-A/building-extendible-hash-leaf-page" target="_blank">
                <h2 class="title mb-6" id="article-1702">Building extendible hash leaf page</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 19, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">An extendible hash is composed of a directory section, which point to leaf pages, and the leaf pages, where the actual data resides.&#xA;My current implementation is incredibly na&#xEF;ve, though. The leaf page has an array of records (two int64 values, for key &amp; value) that we scan through to find a match. That works, but it works badly. It means that you have to scan through a lot of records (up to 254, if the value isn&#x2019;t found). At the same time, we also waste quite a bit of space here. We need to store int64 keys and values, but the vast majority of them are going to be much smaller.&#xA0;&#xA;Voron uses 8KB pages, with 64 bytes page header, leaving us with 8,128 bytes for actual data. I want to kill two birds in one design decision here. Handling both the lookup costs as well as the space costs. Another factor that I have to keep in mind is that complexity kills.&#xA;The RavenDB project had a number of dedicated hash tables over the years, for specific purposes. Some of them were quite fancy and optimized to the hilt. They were also complex. In a particular case, a particular set of writes and deletes meant that we lost an item in the hash table. It was there, but because we used linear probing on collision, and there was an issue with deleting a value under some cases where we would mark the first colliding key as removed, but didn&#x2019;t move the second colliding key to its rightful place. If this make sense to you, you can appreciate the kind of bug that this caused. It only happened in very particular cases, very hard to track down and caused nasty issues. If you don&#x2019;t follow the issue description, just assume that it was complex and hard to figure out. I don&#x2019;t like complexity, this is part of why I enjoy extendible hashing so much, it is such a brilliant idea, and so simple in concept.&#xA;So whatever method we are talking about, it has to allow fast lookups, be space efficient and not be complex.&#xA;The idea is simple, we&#x2019;ll divide the space available in our page to 127 pieces, each with 64 bytes in size. The first byte on each piece will be used to hold the number of entries used in this piece, and the rest of the data will hold varint encoded pairs of keys and values. It might be easier to understand if we&#x2019;ll look at the code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          typedef struct hash_bucket_piece {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char used_entries;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char data[63];&#xA;        &#xA;        &#xA;          &#xA;          } hash_bucket_piece_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          typedef struct hash_bucket {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint16_t size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint16_t capacity;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint8_t depth;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;hash_bucket_piece_t pieces[127];&#xA;        &#xA;        &#xA;          &#xA;          } hash_bucket_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          bool hash_table_get(hash_ctx_t* ctx, uint64_t key, uint64_t* value) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint32_t bucket_idx = hash_table_bucket_number(ctx, key);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;hash_bucket_t* b = ctx-&gt;dir-&gt;buckets[bucket_idx];&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint32_t piece_idx = (key &gt;&gt; b-&gt;depth) % 127;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;hash_bucket_piece_t* p = &amp;b-&gt;pieces[piece_idx];&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint32_t count = p-&gt;used_entries;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char* buf = p-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (count &gt;= 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uint64_t cur_key = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uint64_t val = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;varint_decode(&amp;buf, &amp;cur_key);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;varint_decode(&amp;buf, &amp;val);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (cur_key == key) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;*value = val;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return true;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;count--;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return false;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          get.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m showing here the read side of things, because that is pretty simple. For writes, you need to do a bit more house keeping, but not a lot more of it. Some key observations about this piece of code:&#xA;&#xA;We need to scan only a single 64 bytes buffer. This fits into a CPU cache line, so it is safe to assume that the cost of actually scanning it for a match is actually much lower than fetching from main memory.&#xA;We discard all the common prefix of the page, using its depth value. The rest is used as a modulus index directly into the specified location.&#xA;There is no complexity around linear probing, closed / open addressing, etc. This is because our system can&#x2019;t have collisions.&#xA;&#xA;Actually, the last part is a lie. You are going to get two values that end up in the same piece, obviously. That is a collision, but that require no other special handling. The fun part here is that when we fill a piece completely, we&#x2019;ll need to split the whole page. That will automatically spread the data across two pages and we get our load factor for free .&#xA;Analyzing the cost of lookup in such a scheme, we have:&#xA;&#xA;Bit shifts to index into the right bucket (I&#x2019;m assuming that the directory itself is fully resident in memory).&#xA;We also need the header of the bucket, so we&#x2019;ll need to read it as well (Here we may have disk read).&#xA;Modulus constant and then direct addressing to the relevant piece (covered by the previous disk read).&#xA;Scan 64 bytes to find a particular key using varint.&#xA;&#xA;So in all, we read about 192 bytes (counting values in cache lines) and a single disk read. I expect this to be a pretty efficient result, in both time and space.</p>
        </article>
        <article id="article-1703">
            <a href="https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/" target="_blank">
                <h2 class="title mb-6" id="article-1703">Avoiding Startup service injection in ASP.NET Core 3</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 19, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Upgrading to ASP.NET Core 3.0 - Part 3</p>
        </article>
        <article id="article-1704">
            <a href="https://ayende.com/blog/189089-A/optimizing-access-patterns-for-extendible-hashing" target="_blank">
                <h2 class="title mb-6" id="article-1704">Optimizing access patterns for extendible hashing</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 18, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x2019;m continuing to explore the use of extendible hashing and I run into an interesting scenario. The whole point of using a hash table is to reduce the cost of lookups to O(1). When using persistent data structures, the usual cost that we care about is not the number of CPU instructions, but the number of disk accesses.For B-Trees, the usual cost is O(log(N, fanout) ). A typical fanout rate for a B-Tree in Voron would be around 256. In other words, if we have a hundred million records in a B-Tree, we can expect 3 &#x2013; 4 disk reads to find a particular record. That doesn&#x2019;t sound too bad, until you realize just how slow the disks are. The good thing about that is that you can typically cache things. The first two levels of the B-Tree can be cached really efficiently, we need less than a 100 KB to keep them all in memory. For another 25MB, we can keep the third layer in the B-Tree in main memory. That forth level, on the other hand, has about 300 &#x2013; 400 thousands pages and takes 6 &#x2013; 9 GB of space (depending on fragmentation). Let&#x2019;s assume a system that has 1 GB of RAM available, that means that we&#x2019;ll likely be able to keep the first three levels of the B-Tree in main memory (costing us measly 25MB) but be forced to mostly do disk reads on each access to a page on the last level. I&#x2019;m over simplifying things, because a lot depends on the kind of insert patterns that built the B&#x2B;Tree. Assuming that it has minimal fragmentation (generated from sorted data), it is likely that there are quite a few leaf pages in the 3rd level, but that only works if we don&#x2019;t store any sort of value in the B-Tree. These are back of the envelope computations, not exact numbers. The good thing about this is that B-Tree have a number of interesting properties, chief among them is the fact that the data is sorted. If you are accessing the data in sorted order, you are going to get the optimal access pattern. For example, Voron will analyze your work and prefetch related data before you ask for it. That means that you are likely not going to be hitting many disk reads directly. How does that work when we use hashing?Pretty much by definition, the data is much more widely spread. That means that accessing any two keys is very likely going to result in a disk read. Even if we have only a theoretical cost of O(1) compare to the B-Tree cost of 3 &#x2013; 4, the B-Tree can be trivially reduced to a single disk read in most cases as well. In the extendible hashing case, for hundred million records, assuming that we can fit a maximum of 256 entries per page, we&#x2019;ll need:About 3 MB for the directoryAbout 6 &#x2013; 8 GB for the data itself, depending on the load factor.Here we can see something really interesting. In the B-Tree case, we needed about 25MB of memory just for branch pages. In the hash case, we need only 3 MB. The nice thing about this is that the difference isn&#x2019;t too big between the two options. Yes, there is an order of magnitude gap between them, but for practical purposes, there isn&#x2019;t much of a one.However, access the hash table in an ordered fashion is going to result in pretty much guaranteed disk reads on every call. We will essentially be doing full random reads. And that isn&#x2019;t a nice thing to do to our disk or our performance. We can take advantage on a feature of the extendible hashing. The hash table has the notion of a global depth, it guarantees that each data page we use will have the same depth bits in it. The actual promise is a bit wonkier than that, there is a local depth and a global depth, but for our purposes, it means that if we access to key with the same value in their first depth bits, we&#x2019;ll end up in the same page.That means that if we sort the keys we want to search for by the first depth bits, we can be sure that we&#x2019;ll get good results. We&#x2019;re very likely to hit the same page (already in memory), instead of having to fetch a whole other page from the disk. There aren&#x2019;t as many advantages to finding patterns in the data access, however, but there are still a few things that you might be able to do.My use case calls for an extendible hash of an int64 key to int64 value, so something like:Map&lt;int64, int64&gt; FriendshipStorage;In other words, the key for this map would be the user id, and the value would be the file offset where I can read the list of friends that this user have. If I want to do something like find friends of friends (three levels deep), I can do:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;           List&lt;long&gt; FindFriendsOfFriends(long start) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var depthMask = (1 &lt;&lt; FriendsStorage.Depth) -1;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var sortedByDepth = new SortedList&lt;long&gt;(friends, (x,y) =&gt; (x &amp; depthMask) - (y &amp; depthMask));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var startingFriendsOffset = FriendsStorage.Get(start);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;sortedByDepth.AddRange(GetFriendsList(startingFriendsOffset));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var visited = new HashSet&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var matches = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while(sortedByDepth.Count &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;var current = sortedByDepth[0];&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;sortedByDepth.RemoveAt(0);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if(visited.Add(current))&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;var friendsOffset = FriendsStorage.Get(current);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;sortedByDepth.AddRange(GetFriendsList(friendsOffset));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return matches;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          optimal.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;First, I&#x2019;m going to create a list that will sort the values by the depth, then I&#x2019;m going to read the starting offset and start scanning through the values. I&#x2019;m always going to scan the data based on the order of the first depth bits, which should mean that I&#x2019;m hitting the same page for related data. I&#x2019;m also taking advantage on the fact that I&#x2019;m likely to discover data that is already in locations that I visited. I&#x2019;m going to favor going first to places that I have already seen, assuming that they are still retained in memory.This isn&#x2019;t going to always work, of course, but I suspect that this is going to be pretty good approach, from a heuristic point of view.</p>
        </article>
        <article id="article-1705">
            <a href="https://www.meziantou.net/fire-and-forget-a-task-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-1705">Fire and forget a Task in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 18, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Tasks are very useful to start background work. You can use Task.Run(() =&gt; { ... }) to start a background operation. If the background operation succeeds, everything&#x27;s good. If it fails, you check the task.Exception directly to know why it failed or you can await the task or use a blocking call</p>
        </article>
        <article id="article-1706">
            <a href="https://ayende.com/blog/189057-A/digging-into-extendible-hashing" target="_blank">
                <h2 class="title mb-6" id="article-1706">Digging into extendible hashing</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 15, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After my post yesterday, I dug a lot deeper into extendible hashing. There is a wealth of information on the topic. What is more interesting, from my point of view, is just how freaking elegant this data structure is.I spent a few hours implementing it, because I don&#x2019;t really get a data structure until I actually sat down and writing it in code. I decided to write it in C, because I haven&#x2019;t written C in a while. It took about 200 lines of code, and I could see how it works.Well, I saw see, but I learned something very important a few years ago when implementing complex data structures. One of the first things that you want to do is to make sure that you have a visualization of the data. That can be absolutely invaluable when debugging.Here is what this looked like when we have 31 entries in the hash table, for example:I&#x2019;m outputting Graphviz text and then rendering it. This means that I can very easily and visually see how things are working. Very helpful to understand where I messed up.You can find the whole source here. There is a bit more there then I can comfortably discuss in a blog post, but what I found most useful is to insert data, then see the before / after pictures of the table.What you can see above is a hash table that is split to 4 sections, however, it only has three pages. This is because of the way the hash table works. As shown, all values that ends with 00 binary suffix will go to the left most page. All values that end with 10 will go on the right most.&#xA0; Not coincidentally, these pages are pointed to from the 0 (00) and 2 (10) positions on the hash table buckets&#x2019; list. We also have something a lot more interesting, though. We have the middle page, which is pointed to by both the 1 (01) and 3 (11) positions. In fact, you can see that in that page, we have a depth of 1, so we are actually mixed in this location. As we currently stand, I didn&#x2019;t do anything interesting with regards to how to find a value inside the page (I&#x2019;m doing simple linear search), but I expect that to be relatively straightforward to treat the page as a hash table as well. I need this feature to be able to use as a Map&lt;int64, int64&gt;, which really simplify my life. The key observation is that I don&#x2019;t actually need to do any hashing here. The can be no collisions, after all, given that I&#x2019;m using 64 bits keys inside the hash table. Using extendible hashing, I also don&#x2019;t need to mix the values. If I&#x2019;m going to get values that are clustered together to the same place, I&#x2019;m going to end up splitting the page and solving the problem naturally. Of course, that would eventually cause me to have to double my directory size, so there is some cost for collisions, but I don&#x2019;t think that this is going to be a problem. I tested this with a million consecutive numbers (with no hash mixing) and got a directory size of 32KB. That doesn&#x2019;t seems likely to become a problem. I also ought to mention linear hashing, which uses a different approach. The linked article does a great job explaining how this works. There isn&#x2019;t any recent work on comparing linear hashing to extendible hashing. The one I kept running into is from the 80s. The advantage then was using linear hashing on machines with small memories. Remember, this is the 80s that we are talking about. I&#x2019;m not sure what they though about as small memory in that time frame. The article talks about limiting the amount of memory used for extendible hashing&#x2019;s directory to 1000 entries. That translates (assuming 32 bits values) to less than 8KB of data. That isn&#x2019;t something that I really think I need to worry about.Let&#x2019;s do some basic math, shall we?Assuming an 8KB page size and 64 bits pointers, we can have a directory page for extendible hashing that holds 1,024 buckets. Each one of them is going to be 8KB in turn, so at full utilization, we are looking at a single directory page pointing to 8MB of buckets. In each bucket, we are storing key/value that are both 64 bits in size, which give us 512,288 entries. In practice, I haven&#x2019;t account for metadata, so we can probably expect to be able to address about half a million entries per 8MB.&#xA0; If we need to store a hundred million records, you&#x2019;ll need less than 800MB using this scheme.Given current hardware, that seems like a pretty good idea for me. There are other advantages to take into account, though. Some of the advantages of linear hashing is that you can skip the directory part. Indeed, that can grow quite big. In the case of the 100 million records I mentioned earlier? You&#x2019;ll need about 12 MB just for the directory metadata. Linear hashing can skip this cost (but has other storage costs related to overflow pages, that I&#x2019;m ignoring here). However, that assumes that you can actually compute the address of a page from the key. That isn&#x2019;t really something that we can do if we haven&#x2019;t dedicated the whole file for this purpose. In Voron, for example, you can&#x2019;t assume that you have a raw range of pages to work with. Pages are allocated as needed, and may be mixed by other users of the disk space.I can&#x2019;t see any real advantages to linear hashing at this time. I would be happy to hear about scenarios where it make sense.</p>
        </article>
        <article id="article-1707">
            <a href="https://www.stevejgordon.co.uk/high-performance-logging-in-net-core" target="_blank">
                <h2 class="title mb-6" id="article-1707">High-Performance Logging in .NET Core</h2>
            </a>
            <p class="mb-2">by Steve Gordon</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 14, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I will explore and highlight an approach to logging which you can apply in high-performance, high load applications to reduce the overhead of logging. A Refresher of Logging in .NET Core Logging is a built in feature of ASP.NET Core and .NET Core Work Services. The feature is provided as part of [&#x2026;]</p>
        </article>
        <article id="article-1708">
            <a href="https://ayende.com/blog/189025-A/researching-a-disk-based-hash-table" target="_blank">
                <h2 class="title mb-6" id="article-1708">Researching a disk based hash table</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 14, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">There is a specific scenario that I run into that could be really helped by an O(1) lookup cost on a disk persistent data structure. Voron, our storage engine library, is built on top of a whole big pile of B&#x2B;Trees, which has an O(logN) lookup cost. I could use that, but I wanted to see if we could do better. The natural thing to do when you hear about O(1) costs is to go fetch the nearest hash table, so I spent some time thinking about how to build a hash table that would be persisted to disk. My needs are relatively simple, I believe:O(1) lookup (at least in the common case).&#xA;Able to support greater than memory size.&#xA;Mutable (writes &amp; deletes)&#xA;Keys and values are limited to int64.It doesn&#x2019;t sound hard, right?But when I started thinking about it, I run into a pretty hard limit. If the size of the data is greater than memory, then we have to take into account data access costs. A simple approach here would be to allocate a section in the file for the hash table and use a hash to get to the right location in the file. That works, if you don&#x2019;t need to support mutations. But when you do, you run into a big problem. At some point, the load factor of the hash table is going to increase to the point where you need to regrow it. At that point, you may need to re-hash the entire thing.Assume that the hash table size at this point is 4 GB, you need to re-hash it to 8GB and you have just 1 GB available. That is going to take some time and be a pretty horrible process all around. That is as far as I got when I considered directly translating in memory hash table to disk based one. I&#x2019;m pretty lucky that I don&#x2019;t have to do that, because there is a wealth of research on the matter. These go back to before I was born, although B&#x2B;Trees predate them by a decade or so. They key here is to use extensible hashing. The Wikipedia article is pretty good, I especially liked the Python code showing how things work there. The original paper on the topic is also quite interesting and is of interest to people who care about the details of how storage engines work.I believe that my next step is going to be playing with some codebases that implement these ideas. I decided to look at how this is done with the DBM family of systems. They are old, some of them are probably direct implementations of the extensible hashing paper, but I&#x2019;m mostly interested in seeing how things fit together at this point. All of that said, I run into a lot of red flags along the way.Modern B-Tree Techniques discuss the issue of B-Trees vs. Hashes Indexes and come to the conclusion that you shouldn&#x2019;t bother. They cover quite a few aspects of this issue, from complexity of implementation to usage scenarios.The Berkley DB documentation states that for anything requiring locality of reference, B-Trees are the way to go. However, for large amount of data, their Hash implementation uses less metadata, so might be better. That said, this doesn&#x2019;t match my expectation for the way the system will behave. Looking at this StackOverflow answer, it seems very likely that if you have a working set that is greater than memory, the hash implementation will hit page faults all the time and the B-Tree implementation will be able to keep at least most of its metadata in memory, benefiting greatly from that.Indeed, we have this interesting quote from Berkley DB as well:Hash access method is appropriate for data sets so large that not even the Btree indexing structures fit into memory. At that point, it&#x27;s better to use the memory for data than for indexing structures. This trade-off made a lot more sense in 1990 when main memory was typically much smaller than today.All in all, this seems like a nice area for me to look into. I&#x2019;ll go and read some code now, and maybe I&#x2019;ll write about it.</p>
        </article>
        <article id="article-1709">
            <a href="https://www.meziantou.net/visual-studio-tips-and-tricks-paste-as-json.htm" target="_blank">
                <h2 class="title mb-6" id="article-1709">Visual Studio Tips and tricks: Paste as JSON</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 13, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you often work with JSON documents, you may have created classes to map the content of the JSON document to a .NET class. Then, Json.NET or the new System.Text.Json allows to serialize a class to a JSON string or to deserialize a JSON string to a .NET class.Writing mapping classes is annoying an</p>
        </article>
        <article id="article-1710">
            <a href="https://www.stevejgordon.co.uk/timezonenotfoundexception-in-alpine-based-docker-images" target="_blank">
                <h2 class="title mb-6" id="article-1710">TimeZoneNotFoundException in Alpine Based Docker Images</h2>
            </a>
            <p class="mb-2">by Steve Gordon</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 12, 2019
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post, we&#x2019;re going to explore the cause of a TimeZoneNotFoundException in a .NET Core application, running on .NET Core 3.0 in an Alpine Linux Docker container. TL;DR; The default Alpine Docker image does not include time zone data by default. This causes code which depends on this data to throw exceptions. If you [&#x2026;]</p>
        </article>
        <div class="button flex justify-between">
            <a href="170.html"><span class="back arrow"></span></a>

            <a href="172.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>