
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 68 &#x2022; Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="/pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">
<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline underline"
               href="index.html"> Home </a><a
                aria-current="" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline " href="about.html">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>


<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-671">
            <a href="https://ayende.com/blog/199425-B/bug-chasing-the-process-is-more-important-than-the-result" target="_blank">
                <h2 class="title mb-6" id="article-671">Bug chasing, the process is more important than the result</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 04, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x2019;m doing a pretty major refactoring inside of RavenDB right now. I was able to finish a bunch of work and submitted things to the CI server for testing. RavenDB has several layers of tests, which we run depending on context.&#xA;During development, we&#x2019;ll usually run the FastTests. About 2,300 tests are being run to validate various behaviors for RavenDB, and on my machine, they take just over 3 minutes to complete. The next tier is the SlowTests, which run for about 3 hours on the CI server and run about 26,000 tests. Beyond that we actually have a few more layers, like tests that are being run only on the nightly builds and stress tests, which can take several minutes each to complete.&#xA;In short, the usual process is that you write the code and write the relevant tests. You also validate that you didn&#x2019;t break anything by running the FastTests locally. Then we let CI pick up the rest of the work. At the last count, we had about 9 dedicated machines as CI agents and given our workload, an actual full test run of a PR may complete the next day.&#xA;I&#x2019;m mentioning all of that to explain that when I reviewed the build log for my PR, I found that there were a bunch of tests that failed. That was reasonable, given the scope of my changes. I sat down to grind through them, fixing them one at a time. Some of them were quite important things that I didn&#x2019;t take into account, after all. For example, one of the tests failed because I didn&#x2019;t account for sorting on a dynamic numeric field. Sorting on a numeric field worked, and a dynamic text field also worked. But dynamic numeric field didn&#x2019;t. It&#x2019;s the sort of thing that I would never think of, but we got the tests to cover us.&#xA;But when I moved to the next test, it didn&#x2019;t fail. I ran it again, and it still didn&#x2019;t fail. I ran it in a loop, and it failed on the 5th iteration. That&#x2026; sucked. Because it meant that I had a race condition in there somewhere. I ran the loop again, and it failed again on the 5th. In fact, in every iteration I tried, it would only fail on the 5th iteration.&#xA;When trying to isolate a test failure like that, I usually run that in a loop, and hope that with enough iterations, I&#x2019;ll get it to reproduce. Having it happen constantly on the 5th iteration was&#x2026; really strange. I tried figuring out what was going on, and I realized that the test was generating 1000 documents using a random. The fact that I&#x2019;m using Random is the reason it is non-deterministic, of course, except that this is the code inside my test base class:&#xA;&#xA;&#xA;&#xA;So this is properly initialized with a seed, so it will be consistent.&#xA;Read the code again, do you see the problem?&#xA;&#xA;&#xA;&#xA;That is a static value. So there are two problems here:&#xA;&#xA;I&#x2019;m getting the bad values on the fifth run in a consistent manner because that is the set of results that reproduce the error.&#xA;This is a shared instance that may be called from multiple tests at once, leading to the wrong result because Random is not thread safe.&#xA;&#xA;Before fixing this issue so it would run properly, I decided to use an ancient debugging technique. It&#x2019;s called printf().&#xA;In this case, I wrote out all the values that were generated by the test and wrote a new test to replay them. That one failed consistently.&#xA;The problem was that it was still too big in scope. I iterated over this approach, trying to end up with a smaller section of the codebase that I could invoke to repeat this issue. That took most of the day. But the end result is a test like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [Fact]&#xA;        &#xA;        &#xA;          &#xA;          public void CanAddAndRemoveItems()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              using (var wtx = Env.WriteTransaction())&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var c = wtx.OpenContainer(&quot;test&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var items = Items;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      switch (items[i].Item1)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          case &#x27;&#x2B;&#x27;:&#xA;        &#xA;        &#xA;          &#xA;                              Container.Allocate(wtx.LowLevelTransaction, c, items[i].Item2, out _);&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                          case &#x27;-&#x27;:&#xA;        &#xA;        &#xA;          &#xA;                              Container.Delete(wtx.LowLevelTransaction, c, items[i].Item2);&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  wtx.Commit();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private (char, int)[] Items = new[]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 64), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16424), (&#x27;&#x2B;&#x27;, 96),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16464), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 64),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16480), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16488), (&#x27;&#x2B;&#x27;, 96), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16528), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16536), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16584), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16560), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16520), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16592), (&#x27;&#x2B;&#x27;, 64),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16544), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16424), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 128),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16480), (&#x27;&#x2B;&#x27;, 96), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;-&#x27;, 16520), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16568), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16536), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16552), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16576), (&#x27;&#x2B;&#x27;, 64),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16464), (&#x27;&#x2B;&#x27;, 160),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16480), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16488), (&#x27;&#x2B;&#x27;, 128), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;-&#x27;, 16592), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16528), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16584), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 160),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16424), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16464), (&#x27;&#x2B;&#x27;, 192),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16488), (&#x27;&#x2B;&#x27;, 160), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          SmallTest.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, in terms of the amount of code that it invokes, it is pretty minimal. Which is pretty awesome, since that allowed me to figure out what the problem was:&#xA;&#xA;&#xA;&#xA;I&#x2019;ve been developing software professionally for over two decades at this point. I still get caught up with things like that, sigh.</p>
        </article>
        <article id="article-672">
            <a href="https://ayende.com/blog/199393-B/fight-for-every-byte-it-takes-decoding-the-entries" target="_blank">
                <h2 class="title mb-6" id="article-672">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 01, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this series so far, we reduced the storage cost of key/value lookups by a lot. And in the last post we optimized the process of encoding the keys and values significantly. This is great, but the toughest challenge is ahead of us, because as much as encoding efficiency matters, the absolute cost we have is doing lookups. This is the most basic operation, which we do billions of times a second. Any amount of effort we&#x2019;ll spend here will be worth it. That said, let&#x2019;s look at the decoding process we have right now. It was built to be understandable over all else, so it is a good start.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static (long Key, long Val) Decode(Span&lt;byte&gt; buffer, ushort offset)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;              var (keyLen, valLen) = (offset &amp; 0xF) switch&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  1 =&gt; (1, 1),&#xA;        &#xA;        &#xA;          &#xA;                  2 =&gt; (2, 2),&#xA;        &#xA;        &#xA;          &#xA;                  3 =&gt; (3, 3),&#xA;        &#xA;        &#xA;          &#xA;                  4 =&gt; (4, 4),&#xA;        &#xA;        &#xA;          &#xA;                  5 =&gt; (2, 1),&#xA;        &#xA;        &#xA;          &#xA;                  6 =&gt; (2, 3),&#xA;        &#xA;        &#xA;          &#xA;                  7 =&gt; (2, 4),&#xA;        &#xA;        &#xA;          &#xA;                  8 =&gt; (3, 2),&#xA;        &#xA;        &#xA;          &#xA;                  9 =&gt; (3, 4),&#xA;        &#xA;        &#xA;          &#xA;                  10 =&gt; (3, 5),&#xA;        &#xA;        &#xA;          &#xA;                  11 =&gt; (4, 2),&#xA;        &#xA;        &#xA;          &#xA;                  12 =&gt; (4, 3),&#xA;        &#xA;        &#xA;          &#xA;                  13 =&gt; (5, 4),&#xA;        &#xA;        &#xA;          &#xA;                  14 =&gt; (5, 5),&#xA;        &#xA;        &#xA;          &#xA;                  15 =&gt; (4, 5),&#xA;        &#xA;        &#xA;          &#xA;                  _ =&gt; (buffer[offsetInPage] &gt;&gt; 4, buffer[offsetInPage&#x2B;&#x2B;] &amp; 0xF), // note, inc offsetInPage&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              long k = 0;&#xA;        &#xA;        &#xA;          &#xA;              long v = 0;&#xA;        &#xA;        &#xA;          &#xA;              var entry = buffer.Slice(offsetInPage);&#xA;        &#xA;        &#xA;          &#xA;              entry[..keyLen].CopyTo(MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref k)));&#xA;        &#xA;        &#xA;          &#xA;              entry[(keyLen)..(keyLen &#x2B; valLen)].CopyTo(MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref v)));&#xA;        &#xA;        &#xA;          &#xA;              return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What this code does is to accept a buffer and an offset into the buffer. But the offset isn&#x2019;t just a number, it is composed&#xA0; of two values. The first 12 bits contain the offset in the page, but since we use 2-byte alignment for the entry position, we can just assume a zero bit at the start. That is why we compute the actual offset in the page by clearing the first four bits and then shifting left by three bits. That extracts the actual offset to the file, (usually a 13 bits value) using just 12 bits. The first four bits in the offset are the indicator for the key and value lengths. There are 15 known values, which we computed based on probabilities and one value reserved to say: Rare key/val length combination, the actual sizes are stored as the first byte in the entry.&#xA;Note that in the code, we handle that scenario by reading the key and value lengths (stored as two nibbles in the first byte) and incrementing the offset in the page. That means that we skip past the header byte in those rare situations.&#xA;The rest of the code is basically copying the key and value bytes to the relevant variables, taking advantage of partial copy and little-endian encoding.&#xA;The code in question takes 512 bytes and has 23 branches. In terms of performance, we can probably do much better, but the code is clear in what it is doing, at least.&#xA;The first thing I want to try is to replace&#xA0; the switch statement with a lookup table, just like we did before.&#xA0; Here is what the new version looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; DecodeTable =&gt; new byte[16] {&#xA;        &#xA;        &#xA;          &#xA;            (0 /*rare*/), (1 &lt;&lt; 4 | 1), (2 &lt;&lt; 4 | 2), (3 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;            (4 &lt;&lt; 4 | 4), (2 &lt;&lt; 4 | 1), (2 &lt;&lt; 4 | 3), (2 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;            (3 &lt;&lt; 4 | 2), (3 &lt;&lt; 4 | 4), (3 &lt;&lt; 4 | 5), (4 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;            (4 &lt;&lt; 4 | 3), (5 &lt;&lt; 4 | 4), (5 &lt;&lt; 4 | 5), (4 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          private static (long Key, long Val) Decode(Span&lt;byte&gt; buffer, ushort offset) {&#xA;        &#xA;        &#xA;          &#xA;            var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;            var indicator = DecodeTable[offset &amp; 0xF];&#xA;        &#xA;        &#xA;          &#xA;            if (indicator == 0) {&#xA;        &#xA;        &#xA;          &#xA;              indicator = buffer[offsetInPage&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            var keyLen = indicator &gt;&gt; 4;&#xA;        &#xA;        &#xA;          &#xA;            var valLen = indicator &amp; 0xF;&#xA;        &#xA;        &#xA;          &#xA;            long k = 0;&#xA;        &#xA;        &#xA;          &#xA;            long v = 0;&#xA;        &#xA;        &#xA;          &#xA;            var entry = buffer.Slice(offsetInPage);&#xA;        &#xA;        &#xA;          &#xA;            entry[..keyLen].CopyTo(MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref k)));&#xA;        &#xA;        &#xA;          &#xA;            entry[(keyLen)..(keyLen &#x2B; valLen)].CopyTo(&#xA;        &#xA;        &#xA;          &#xA;                MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref v)));&#xA;        &#xA;        &#xA;          &#xA;            return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The size of the function dropped by almost half and we have only 7 more branches involved. There are also a couple of calls to the memory copy routines that weren&#x2019;t inlined. In the encoding phase, we reduced branches due to bound checks using raw pointers, and we skipped the memory calls routines by copying a fixed size value at varied offsets to be able to get the data properly&#xA0; aligned. In this case, we can&#x2019;t really do the same. One thing that we have to be aware of is the following situation:&#xA;&#xA;&#xA;&#xA;In other words, we may have an entry that is at the end of the page, if we&#x2019;ll try to read unconditionally 8 bytes, we may read past the end of the buffer. That is not something that we can do. In the Encode() case, we know that the caller gave us a buffer large enough to accommodate the largest possible size, so that isn&#x2019;t an issue. That complicates things, sadly, but we can go the other way around.&#xA;The Decode() function will always be called on an entry, and that is part of the page. The way we place entries means that we are starting at the top and moving down. The structure of the page means that we can never actually place an entry below the first 8 bytes of the page. That is where the header and the offsets array are going, after all. Given that, we can do an unconditional read backward from the entry. As you can see in the image below, we are reading some data that we don&#x2019;t care about, but this is fine, we can fix it later, and without any branches.&#xA;&#xA;&#xA;&#xA;The end result is that we can have the following changes:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private unsafe static (long Key, long Val) Decode(byte* buffer, ushort offset)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;              var indicator = DecodeTable[offset &amp; 0xF];&#xA;        &#xA;        &#xA;          &#xA;              if (indicator == 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  indicator = buffer[offsetInPage&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = indicator &gt;&gt; 4;&#xA;        &#xA;        &#xA;          &#xA;              var valLen = indicator &amp; 0xF;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long k = ReadBackward(buffer, offsetInPage, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              long v = ReadBackward(buffer, offsetInPage &#x2B; keyLen, valLen);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long ReadBackward(byte* buffer, int offsetInPage, int len)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var shift = 8 - len;&#xA;        &#xA;        &#xA;          &#xA;                  var l = Unsafe.ReadUnaligned&lt;long&gt;(ref buffer[offsetInPage - shift]);&#xA;        &#xA;        &#xA;          &#xA;                  l &gt;&gt;&gt;= shift * 8;&#xA;        &#xA;        &#xA;          &#xA;                  return l;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I changed the code to use a raw pointer, avoiding bound checks that we already reasoned about. Most interesting is the ReadBackward function. This is an inner function, and was properly inlined during JIT compilation, it implements the backward reading of the value. Here is what the assembly looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;              L0041: mov r10d, r9d&#xA;        &#xA;        &#xA;          &#xA;              L0044: neg r10d&#xA;        &#xA;        &#xA;          &#xA;              L0047: add r10d, 8&#xA;        &#xA;        &#xA;          &#xA;              L004b: mov r11d, r8d&#xA;        &#xA;        &#xA;          &#xA;              L004e: sub r11d, r10d&#xA;        &#xA;        &#xA;          &#xA;              L0051: movsxd r11, r11d&#xA;        &#xA;        &#xA;          &#xA;              L0054: mov r11, [r11&#x2B;rdx]&#xA;        &#xA;        &#xA;          &#xA;              L0058: shl r10d, 3&#xA;        &#xA;        &#xA;          &#xA;              L005c: shrx r10, r11, r10&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ReadBackward.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;With this in place, we are now at 133 bytes and a single branch operation. That is pretty awesome, but we can do better still. Consider the following code (explanations to follow):&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; DecodeTable =&gt; new byte[16] {&#xA;        &#xA;        &#xA;          &#xA;              ( 1 &lt;&lt; 3), // special!&#xA;        &#xA;        &#xA;          &#xA;              ( 1 &lt;&lt; 4 | 1),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 1),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;              ( 5 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 5 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public unsafe static void Decode(byte* buffer, ushort offset, out long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;              var decoderByte = DecodeTable[offset &amp; 0xF];&#xA;        &#xA;        &#xA;          &#xA;              var offload = decoderByte &amp; 8;&#xA;        &#xA;        &#xA;          &#xA;              byte decodeParts = (byte)((buffer[offsetInPage] &lt;&lt; 8 | decoderByte) &gt;&gt; offload);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int keyLen = (decodeParts &gt;&gt; 4);&#xA;        &#xA;        &#xA;          &#xA;              int valLen = (decodeParts &amp; 0xF);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              offload &gt;&gt;= 3;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              key = ReadBackward(buffer, offsetInPage &#x2B; offload, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              val = ReadBackward(buffer, offsetInPage &#x2B; offload &#x2B; keyLen, valLen);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long ReadBackward(byte* buffer, int offsetInPage, int len)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var shift = 8 - len;&#xA;        &#xA;        &#xA;          &#xA;                  var l = Unsafe.ReadUnaligned&lt;long&gt;(ref buffer[offsetInPage - shift]);&#xA;        &#xA;        &#xA;          &#xA;                  l &gt;&gt;&gt;= shift * 8;&#xA;        &#xA;        &#xA;          &#xA;                  return l;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Note that the first element in the table here is different, it is now setting the 4th bit. This is because we are making use of that. The structure of the bytes in the table are two nibbles, but no other value in the table sets the 4th bit. That means that we can operate on that.&#xA;Indeed, what we are doing is use the decoder byte to figure out what sort of shift we want. We have the byte from the table and the byte from the buffer. And we use the fact that masking this with 8 gives (just for this value) the value of 8. We can then use that to select the appropriate byte. If we have an offloaded byte, then we&#x2019;ll shift the value by 8, getting the byte from the buffer. For any other value, we&#x2019;ll get 0 as the shift index, resulting in us getting the value from the table. That gives us a function with zero branches, and 141 bytes.&#xA;I spent a lot of time thinking about this, so now that we have those two approaches, let&#x27;s benchmark them. The results were surprising:&#xA;&#xA;|                  Method |       Mean |    Error |   StdDev |&#xA;|------------------------ |-----------:|---------:|---------:|&#xA;|  DecodeBranchlessShifts | 2,107.1 ns | 20.69 ns | 18.34 ns |&#xA;|           DecodeBranchy |   936.2 ns |  1.89 ns |  1.68 ns |&#xA;&#xA;It turns out that the slightly smaller code with the branches is able to beat up the branchless code. When looking into what they are doing, I think that I can guess why. Branches aren&#x2019;t a huge problem if they are predictable, and in our case, the whole point of all of this is that the offload process where we need to go to the entry to get the value is meant to be a rare event. In branchless code, on the other hand, you have to do something several times to avoid a branch (like shifting the value from the buffer up and maybe shifting it down, etc).&#xA;You can&#x2019;t really argue with a difference like that. We also tried an AVX version, to see if this would have better performance. It turns out that there is really no way for us to beat the version with the single branch. Everything else was at least twice as slow.&#xA;At this point, I believe that we have a winner.</p>
        </article>
        <article id="article-673">
            <a href="https://www.meziantou.net/reading-windows-application-manifest-of-an-exe-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-673">Reading Windows Application Manifest of an exe in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 01, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The application manifest file is a compatibility feature that allows Windows to run older applications on newer versions of Windows. It contains information such as the supported versions of Windows, if it should run as administrator, if it supports long paths, etc.This file is stored as an embedde</p>
        </article>
        <article id="article-674">
            <a href="https://ayende.com/blog/199364-B/fight-for-every-byte-it-takes-optimizing-the-encoding-process" target="_blank">
                <h2 class="title mb-6" id="article-674">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 28, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my previous post, I showed how we use the nibble offload approach to store the size of entries in space that would otherwise be unused. My goal in that post was clarity, so I tried to make sure that the code was as nice to read as possible. In terms of machine code, that isn&#x2019;t really ideal. Let&#x2019;s talk about how we can make it better. Here is the starting version:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static (int EntrySize, byte SizeNibble) Encode(Span&lt;byte&gt; buffer, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              byte inlined = (keyLen, valLen) switch&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  (1, 1) =&gt; 1,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 2) =&gt; 2,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 3) =&gt; 3,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 4) =&gt; 4,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 1) =&gt; 5,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 3) =&gt; 6,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 4) =&gt; 7,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 2) =&gt; 8,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 4) =&gt; 9,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 5) =&gt; 10,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 2) =&gt; 11,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 3) =&gt; 12,&#xA;        &#xA;        &#xA;          &#xA;                  (5, 4) =&gt; 13,&#xA;        &#xA;        &#xA;          &#xA;                  (5, 5) =&gt; 14,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 5) =&gt; 15,&#xA;        &#xA;        &#xA;          &#xA;                  // note the trickery here with increment the write offset&#xA;        &#xA;        &#xA;          &#xA;                  _ =&gt; 0&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = 0;&#xA;        &#xA;        &#xA;          &#xA;              if (inlined == 0) // cannot fit, need to write to entry itself&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  writeOffset = 1;&#xA;        &#xA;        &#xA;          &#xA;                  buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref key))[..keyLen].CopyTo(buffer[writeOffset..]);&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref val))[..valLen].CopyTo(buffer[(keyLen &#x2B; writeOffset)..]);&#xA;        &#xA;        &#xA;          &#xA;              return (writeOffset &#x2B; keyLen &#x2B; valLen, inlined);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This code generates a function whose size exceeds 600 bytes and contains 24(!) branches. I already talked before about why this is a problem, there is a good discussion of the details on branches and their effect on performance here. In short, fewer branches are better. And when looking at machine instructions, the smaller the function, the better we are.&#xA;The first thing to do then is to remove the switch statement and move to a table-based approach. Given that this is a lookup of a small set of values, we can precompute all the options and just do a lookup like that. Here is what the code looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; EncodingTable =&gt; new byte[64]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              1, 0, 0, 0, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              5, 2, 6, 7, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 8, 3, 9, 10, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 11, 12, 4, 15, 0, 0,&#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 13, 14, 0, 0,&#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 0, 0, 0, 0, 0&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;           static (int EntrySize, byte SizeNibble) Encode(Span&lt;byte&gt; buffer, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var inlined = EncodingTable[(keyLen-1)*8 &#x2B; valLen-1];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = 0;&#xA;        &#xA;        &#xA;          &#xA;              if (inlined == 0) // cannot fit, need to write to entry itself&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  writeOffset = 1;&#xA;        &#xA;        &#xA;          &#xA;                  buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref key))[..keyLen].CopyTo(buffer[writeOffset..]);&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref val))[..valLen].CopyTo(buffer[(keyLen &#x2B; writeOffset)..]);&#xA;        &#xA;        &#xA;          &#xA;              return (writeOffset &#x2B; keyLen &#x2B; valLen, inlined);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is already a win, since we are now at about half the code size (340 bytes) and there are just 7 branches in the function. Let&#x2019;s take a look at the code and its assembly:&#xA;&#xA;&#xA;&#xA;&#xA;Code&#xA;Assembly&#xA;&#xA;&#xA;&#xA;if (inlined == 0)  {&#xA0;&#xA0;&#xA0;&#xA0; writeOffset = 1;&#xA0;&#xA0;&#xA0;&#xA0; buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen); }&#xA;&#xA;&#xA;L0065: test r14d, r14d L0068: jne short L0081 L006a: mov r15d, 1 L0070: mov ecx, ebx L0072: shl ecx, 4 L0075: or ecx, ebp L0077: test edi, edi L0079: je L014fL007f: mov [rsi], cl&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;As you can see, in the assembly, we first test the value, and if it isn&#x2019;t zero, we jump after the if statement. If it is 0, we compute a shift right by 4 and then or the values, then we do another check and finally set the value in the buffer.&#xA;Where does this check came from? There is no if there?&#xA;Well, that is the bound checking that we have with using Span, in fact, most of the checks there are because of Span or because of the safe intrinsics that are used.&#xA;Let&#x2019;s get rid of this. There are actually several interesting iterations in the middle, but let&#x2019;s jump directly to the final result I have. It&#x2019;s under 10 lines of code, and it is quite beautiful.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; EncodingTable =&gt; new byte[64]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;             1,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;             5,    2,    6,    7,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,    8,    3,    9,   10,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   11,   12,    4,   15,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   13,   14,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          unsafe static void Encode(byte* buffer, long key, long val, out int entrySize, out byte nibble)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var inlined = Unsafe.Add(ref MemoryMarshal.GetReference(EncodingTable), (keyLen - 1) * 8 &#x2B; valLen - 1);&#xA;        &#xA;        &#xA;          &#xA;              nibble = (byte)(inlined &amp; 0xF);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = inlined &gt;&gt; 4;&#xA;        &#xA;        &#xA;          &#xA;              buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.WriteUnaligned(ref buffer[writeOffset], key);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.WriteUnaligned(ref buffer[writeOffset &#x2B; keyLen], val);&#xA;        &#xA;        &#xA;          &#xA;              entrySize = writeOffset &#x2B; keyLen &#x2B; valLen;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m sure that you&#x2019;ll look at this versus the previous iterations and go&#x2026; huh?! I mean, even the reference table is different now.&#xA;Let&#x2019;s analyze what is going on here in detail. The first thing you&#x2019;ll note that changed is the method signature. Before we had multiple result types and now we use out parameters. This turns out to generate slightly less code, so I went with that approach, instead.&#xA;Next, computing the number of bytes we need to copy is the same. Once we have the sizes of the key and the value, we fetch the relevant instruction from the reference table. We do that in a way that skips the bounds checking on the table, since we know that we cannot exceed the length of the array.&#xA;Unlike before, we have new values in the table, where before we had 0 for entries that we didn&#x2019;t care for, now we put 16. That means that we need to clear that when we set the nibble parameter. The reason for this is that we use this to compute the writeOffset. For cases where we have an offboarded nibble, the shift we do there will clear all the values, leaving us with a zero. For the values we cannot offload, we get 16, shifting by 4 gives us 1.&#xA;The reason we do it this way is that we do not use any conditional in this method. We unconditionally set the first byte of the buffer, because it is cheaper to do the work and discard that than check if it needs to be done.&#xA;Finally, we previously used Span.Copy() to move the data. That works, but it turns out that it is not ideal for very small writes, like what we have. At the same time, we write variable size each time, how can we manage that?&#xA;The answer is that we know that the buffer we are passed is large enough to contain the largest size possible. So we don&#x2019;t need to worry about bound checking, etc.&#xA;We take advantage of the fact that the data is laid out in little-endian format and just write the whole 8 bytes of the key to the buffer at the right location. That may be shifted by the computed writeOffset. We then write the value immediately following the computed key length. The idea is that we overwrite the memory we just wrote (because parts of that were found to be not interesting). Using this approach, we were able to drop the code for this function to 114 bytes(!). Even with the encoding table, that is under three cache lines for the whole thing. That is really small.&#xA;There are also no conditionals or branches throughout the process. This is a piece of code that is ready and willing to be inlined anywhere. The amount of effort to understand what is going on here is balanced against how much this function can achieve in its lifetime.&#xA;For reference, here is the assembly of the encoding process:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Main.Encode(Byte*, Int64, Int64, Int32 ByRef, Byte ByRef)&#xA;        &#xA;        &#xA;          &#xA;              L0000: push rdi&#xA;        &#xA;        &#xA;          &#xA;              L0001: push rsi&#xA;        &#xA;        &#xA;          &#xA;              L0002: xor eax, eax&#xA;        &#xA;        &#xA;          &#xA;              L0004: lzcnt rax, rdx&#xA;        &#xA;        &#xA;          &#xA;              L0009: shr rax, 3&#xA;        &#xA;        &#xA;          &#xA;              L000d: neg eax&#xA;        &#xA;        &#xA;          &#xA;              L000f: add eax, 8&#xA;        &#xA;        &#xA;          &#xA;              L0012: xor r10d, r10d&#xA;        &#xA;        &#xA;          &#xA;              L0015: lzcnt r10, r8&#xA;        &#xA;        &#xA;          &#xA;              L001a: shr r10, 3&#xA;        &#xA;        &#xA;          &#xA;              L001e: neg r10d&#xA;        &#xA;        &#xA;          &#xA;              L0021: add r10d, 8&#xA;        &#xA;        &#xA;          &#xA;              L0025: lea r11d, [r10&#x2B;rax*8-9]&#xA;        &#xA;        &#xA;          &#xA;              L002a: movsxd r11, r11d&#xA;        &#xA;        &#xA;          &#xA;              L002d: mov rsi, 0x216751e0b80&#xA;        &#xA;        &#xA;          &#xA;              L0037: movzx r11d, byte ptr [r11&#x2B;rsi]&#xA;        &#xA;        &#xA;          &#xA;              L003c: mov esi, r11d&#xA;        &#xA;        &#xA;          &#xA;              L003f: and esi, 0xf&#xA;        &#xA;        &#xA;          &#xA;              L0042: mov rdi, [rsp&#x2B;0x38]&#xA;        &#xA;        &#xA;          &#xA;              L0047: mov [rdi], sil&#xA;        &#xA;        &#xA;          &#xA;              L004a: sar r11d, 4&#xA;        &#xA;        &#xA;          &#xA;              L004e: mov esi, eax&#xA;        &#xA;        &#xA;          &#xA;              L0050: shl esi, 4&#xA;        &#xA;        &#xA;          &#xA;              L0053: or esi, r10d&#xA;        &#xA;        &#xA;          &#xA;              L0056: mov [rcx], sil&#xA;        &#xA;        &#xA;          &#xA;              L0059: movsxd rsi, r11d&#xA;        &#xA;        &#xA;          &#xA;              L005c: mov [rcx&#x2B;rsi], rdx&#xA;        &#xA;        &#xA;          &#xA;              L0060: add eax, r11d&#xA;        &#xA;        &#xA;          &#xA;              L0063: movsxd rdx, eax&#xA;        &#xA;        &#xA;          &#xA;              L0066: mov [rdx&#x2B;rcx], r8&#xA;        &#xA;        &#xA;          &#xA;              L006a: add eax, r10d&#xA;        &#xA;        &#xA;          &#xA;              L006d: mov [r9], eax&#xA;        &#xA;        &#xA;          &#xA;              L0070: pop rsi&#xA;        &#xA;        &#xA;          &#xA;              L0071: pop rdi&#xA;        &#xA;        &#xA;          &#xA;              L0072: ret&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The EncodingTable deserves a better explanation. I generated it using the following code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (int i = 0; i &lt; 8; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int j = 0; j &lt; 8; j&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  byte inlined = (i &#x2B; 1, j &#x2B; 1) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      (1, 1) =&gt; 1,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 2) =&gt; 2,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 3) =&gt; 3,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 4) =&gt; 4,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 1) =&gt; 5,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 3) =&gt; 6,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 4) =&gt; 7,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 2) =&gt; 8,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 4) =&gt; 9,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 5) =&gt; 10,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 2) =&gt; 11,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 3) =&gt; 12,&#xA;        &#xA;        &#xA;          &#xA;                      (5, 4) =&gt; 13,&#xA;        &#xA;        &#xA;          &#xA;                      (5, 5) =&gt; 14,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 5) =&gt; 15,&#xA;        &#xA;        &#xA;          &#xA;                      // note the trickery here with increment the write offset&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; 16&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  Console.Write($&quot;{inlined,4}, &quot;);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              Console.WriteLine();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          EncodingGeneration.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In other words, I basically wrote out all the options and generated the appropriate value for each one of the options. I&#x2019;m using the value of 16 here to be able to get to the right result using some bit shifts without any conditionals. So instead of doing many conditions, I replaced this with a (small) table lookup.&#xA;In my next post, I&#x2019;m going to try to handle the same process for decoding.</p>
        </article>
        <article id="article-675">
            <a href="https://ayende.com/blog/199363-B/fight-for-every-byte-it-takes-fitting-64-values-in-4-bits" target="_blank">
                <h2 class="title mb-6" id="article-675">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 27, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Moving to nibble encoding gave us a measurable improvement in the density of the entries in the page.&#xA0;&#xA0; The problem is that we pretty much run out of room to do so. We are currently using a byte per entry to hold the size of the entry (as two nibbles, of 4 bits each). You can&#x2019;t really go lower than that.&#xA;Let&#x2019;s review again what we know about the structure of the data, we have an 8KB page, with three sections, fixed size header and variable size offsets and entries array. Here is what this looks like:&#xA;&#xA;This is called a slotted page design. The idea is that the offset array at the bottom of the page is maintaining the sort orders of the entries, and that we can write the entries from the top of the page. When we need to sort the entries, we just need to touch the offsets array (shown in yellow in the image).&#xA;Given that we are talking about size and density, we spent a lot of time trying to reduce the size of the entries, but can we do something with the header or the offsets? The header is just 4 bytes right now, two shorts that denote the location of the bottom and the top position in the page. Given that the page is 8KB in size, we have to use 16 bits integer to cover the range. For offsets, the situation is the same. We have to be able to point to the entry location on the page, and that means that we have to reach 8KB. So the offsets are actually 16 bits ints and take two bytes.&#xA;In other words, there is a hidden overhead of 2 bytes per entry that we didn&#x2019;t even consider. In the case of our latest success, we were able to push 759 entries into the page, which means that we are actually using 18.5% of the page just to hold the offsets of the entries. That is 1.48 KB that is being used.&#xA;The problem is that we need to use this. We have to be able to point to an entry anywhere in the page, which means that we have to reach 0 .. 8192. The minimum size we can use is 16 bits or two bytes.&#xA;Or do we?&#xA;16 bits gives us a range of 0 .. 65,535, after all. That is far in excess of what we need. We could use a 64KB page, but there are other reasons to want to avoid that.&#xA;To cover 8KB, we only need 13 bits to cover the range we need, after all. For that matter, we can extend that bit by 25%. If we decide that an entry should be 2 bytes aligned, we can access the entire page in 12 bits.&#xA;That means that we have 4 whole free bits to play with. The first idea is to change the offsets array from 16 bits ints to 12 bits ints. That would save us 380 bytes at 759 entries per page. That is quite a lot. Unfortunately, working with bits in this manner would be super awkward. We are doing a lot of random access and moves while we are building the page. It is possible to do this using bits, but not fun.&#xA;So we can set things up so we have a nibble free to use. We just used nibbles to save on the cost of variable size ints, to great success.&#xA;However, we don&#x2019;t need just a nibble, we need two of them. We need to store the size of the key and the value in bytes. Actually, we don&#x2019;t need two nibbles. The size of the key and the value maxes at 8 bytes, after all. We can encode that in 3 bits. In other words, we need 6 bits to encode this information.&#xA;We only have 4 bits, however. It is a really nice idea, however, and I kept turning that in my head, trying to come up with all sorts of clever ways to figure out how we can push 64 values in 4 bits. The impact of that would be pretty amazing.&#xA;Eventually, I realized that it is fairly easy to prove, using math, that there is no way to do so. Faced with this failure, I realigned my thinking and found a solution. I don&#x2019;t need to have a perfect answer, I can have a good one.&#xA;4 bits give me a range of 16 values (out of the possible 64). If I give up on trying to solve the whole problem, can I solve a meaningful part of it?&#xA;And I came up with the following idea. We can do a two-stage approach, we&#x2019;ll map the most common 15 values of key and value sizes to those 4 bits. The last value will be a marker that you have to go and look elsewhere.&#xA;Using just the data in the offset, I&#x2019;m able to figure out what the location of the entry in the page is as well as the size of the key and value for most cases. For the (hopefully rare) scenarios where that is not the case, we fall back to storing the size information as two nibbles preceding the entry data.&#xA;This is a pretty neat idea, even if I say so myself, and it has a good chance to allow us to save about 1 byte per entry in the common case. In fact, I tested that and about 90% of the cases in my test case are covered by the top 15 cases. That is a pretty good indication that I&#x2019;m on the right track.&#xA;All of that said, let&#x2019;s look at how this looks in code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static (int EntrySize, byte SizeNibble) Encode(Span&lt;byte&gt; buffer, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              byte inlined = (keyLen, valLen) switch&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  (1, 1) =&gt; 1,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 2) =&gt; 2,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 3) =&gt; 3,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 4) =&gt; 4,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 1) =&gt; 5,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 3) =&gt; 6,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 4) =&gt; 7,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 2) =&gt; 8,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 4) =&gt; 9,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 5) =&gt; 10,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 2) =&gt; 11,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 3) =&gt; 12,&#xA;        &#xA;        &#xA;          &#xA;                  (5, 4) =&gt; 13,&#xA;        &#xA;        &#xA;          &#xA;                  (5, 5) =&gt; 14,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 5) =&gt; 15,&#xA;        &#xA;        &#xA;          &#xA;                  // note the trickery here with increment the write offset&#xA;        &#xA;        &#xA;          &#xA;                  _ =&gt; 0&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = 0;&#xA;        &#xA;        &#xA;          &#xA;              if (inlined == 0) // cannot fit, need to write to entry itself&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  writeOffset = 1;&#xA;        &#xA;        &#xA;          &#xA;                  buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref key))[..keyLen].CopyTo(buffer[writeOffset..]);&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref val))[..valLen].CopyTo(buffer[(keyLen &#x2B; writeOffset)..]);&#xA;        &#xA;        &#xA;          &#xA;              return (writeOffset &#x2B; keyLen &#x2B; valLen, inlined);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m using a switch expression here for readability, so it is clear what is going on. If the key and value sizes are in one of the known patterns, we can put that in the nibble we&#x2019;ll return. If the value is not, we&#x2019;ll write it to the entry buffer.&#xA;The Set method itself had to change in some subtle but crucial ways, let&#x2019;s look at it first, then I&#x2019;ll discuss those changes:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static bool Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // header is 4 bytes [bottom, top] &#xA;        &#xA;        &#xA;          &#xA;              ref var bottom = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              ref var top = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[1]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (bottom == 0) // init empty page &#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  top = 8192; // top of the page&#xA;        &#xA;        &#xA;          &#xA;                  bottom = 4; // leave 4 bytes for the bottom/top header&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var usableSpace = top - bottom;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;byte&gt; temp = stackalloc byte[17]; // max 8 bytes per, plus 1&#xA;        &#xA;        &#xA;          &#xA;              var (reqEntryLen, nibble) = Encode(temp, key, val);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var idx = BinarySearch(page, key);&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;ushort&gt; offsets;&#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // let&#x27;s check if we can update?&#xA;        &#xA;        &#xA;          &#xA;                  offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;                  var actualEntryOffset = ((offsets[idx] &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;                  var curEntryLen = DecodeEntryLength(page[actualEntryOffset..]);&#xA;        &#xA;        &#xA;          &#xA;                  if (reqEntryLen &lt;= curEntryLen) // can fit with out needing new allocation&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      // can fit, just copy &amp; done&#xA;        &#xA;        &#xA;          &#xA;                      offsets[idx] = (ushort)(actualEntryOffset &lt;&lt; 3 | nibble);&#xA;        &#xA;        &#xA;          &#xA;                      temp[..reqEntryLen].CopyTo(page[actualEntryOffset..]);&#xA;        &#xA;        &#xA;          &#xA;                      return true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  // is there enough space for a new entry?&#xA;        &#xA;        &#xA;          &#xA;                  if (reqEntryLen &gt; usableSpace)&#xA;        &#xA;        &#xA;          &#xA;                      return false;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              else // increase size of offsets array&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var expectedStart = (top - reqEntryLen) &amp; ~1; // aligned on 2 bytes boundary&#xA;        &#xA;        &#xA;          &#xA;                  // is there enough space for a new entry &#x2B; it&#x27;s offset?&#xA;        &#xA;        &#xA;          &#xA;                  if (bottom &#x2B; sizeof(ushort) &gt; expectedStart)&#xA;        &#xA;        &#xA;          &#xA;                      return false;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  idx = ~idx;&#xA;        &#xA;        &#xA;          &#xA;                  bottom &#x2B;= 2;&#xA;        &#xA;        &#xA;          &#xA;                  offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;                  offsets[idx..(offsets.Length - 1)].CopyTo(offsets[(idx &#x2B; 1)..]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              top = (ushort)((top - reqEntryLen) &amp; ~1); // align on two bytes boundary&#xA;        &#xA;        &#xA;          &#xA;              offsets[idx] = (ushort)(top &lt;&lt; 3 | nibble);&#xA;        &#xA;        &#xA;          &#xA;              temp[..reqEntryLen].CopyTo(page[top..]);&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Set.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As before, we encode the entry into a temporary buffer. Now, in addition to getting the length of the entry, we are also getting the nibble that we&#x2019;ll need to store.&#xA;You can see the changes in how we work with the offsets array following that. When we need to update an existing value, we are using this construction to figure out the actual entry offset:&#xA;&#xA;var actualEntryOffset = ((offsets[idx] &amp; 0xFFF0) &gt;&gt; 3);&#xA;&#xA;What exactly is going on here? Don&#x2019;t try to figure it out yet, let&#x2019;s see how we are writing the data:&#xA;&#xA;top = (ushort)((top - reqEntryLen) &amp; ~1); // align on two bytes boundary &#xA;offsets[idx] = (ushort)(top &lt;&lt; 3 | nibble);&#xA;&#xA;Those two code snippets may look very odd, so let&#x2019;s go over them in detail.&#xA;First, remember that we have an 8KB page to work with, but we need to use 4 bits for the size nibble we got from encoding the entry. To address the full 8,192 values in the page, we&#x2019;ll need to reserve 13 bits. That is&#x2026; a problem. We solve that by saying that the entry addresses must always be aligned on two bytes boundary. That is handled by clearing the first bit in the new top computation. Since we are growing down, that has the effect of ensuring aligned-by-two.&#xA;Then, we merge the top location and the nibble together. We know that the bottom-most of the top is cleared, so we can just move the value by 3 bits and we know that we&#x2019;ve 4 cleared bits ready.&#xA;Conversely, when we want to read, we clear the first 4 bits and then we shift by three. That has the effect of returning us back to the original state.&#xA;A little bit confusing, but we managed to get to squeeze 784 entries into the page using the realistic dataset and 765 using the full one. That is another 3.5% of space savings over the previous nibble attempt and over 10% increase in capacity from the variable integer approach.&#xA;And at this point, I don&#x2019;t believe that there is anything more that I can do to reduce the size in a significant manner without having a negative impact elsewhere.&#xA;We are not done yet, however. We are done with the size aspect, but we also have much to do in terms of performance and optimizations for runtime.&#xA;In the meantime, you can see my full code here. In the next post, we are going to start talking about the actual machine code and how we can optimize it.</p>
        </article>
        <article id="article-676">
            <a href="https://ayende.com/blog/199362-B/fight-for-every-byte-it-takes-nibbling-at-the-costs" target="_blank">
                <h2 class="title mb-6" id="article-676">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 26, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my last post we implemented variable-sized encoding to be able to pack even more data into the page. We were able to achieve 40% better density because of that. This is pretty awesome, but we would still like to do better. There are two disadvantages for variable size integers:&#xA;&#xA;They may take more space than the actual raw numbers.&#xA;The number of branches is high, and non-predictable.&#xA;&#xA;Given that we need to encode the key and value together, let&#x2019;s see if we can do better. We know that both the key and the value are 8 bytes long. Using little-endian systems, we can consider the number as a byte array.&#xA;Consider this number: 139,713,513,353 which is composed of the following bytes: [137, 7, 147, 135, 32, 0, 0, 0]. This is how it looks in memory. This means, that we only need the first 5 bytes, not the last 3 zero ones.&#xA;It turns out that there is a very simple way to compute the number of used bytes, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          int UsedBytes(long l)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)l) / 8);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          UsedBytes.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This translates into the following assembly:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          UsedBytes|0_0(Int64)&#xA;        &#xA;        &#xA;          &#xA;              L0000: xor eax, eax&#xA;        &#xA;        &#xA;          &#xA;              L0002: lzcnt rax, rcx&#xA;        &#xA;        &#xA;          &#xA;              L0007: shr rax, 3&#xA;        &#xA;        &#xA;          &#xA;              L000b: neg eax&#xA;        &#xA;        &#xA;          &#xA;              L000d: add eax, 8&#xA;        &#xA;        &#xA;          &#xA;              L0010: ret&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          UsedBytes.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Which is about as tight as you can want it to be.&#xA;Of course, there is a problem. In order to read the value back, we need to store the number of bytes we used somewhere. For variable-sized integers, they use the top bit until they run out. But we cannot do that here.&#xA;Remember however, that we encode two numbers here. And the length of the number is 8 bytes. In binary, that means that we need 4 bits to encode the length of each number. This&#xA0;means that if we&#x2019;ll take an additional byte, we can fit the length of both numbers into a single byte.&#xA;The length of the key and the value would each fit on a nibble inside that byte. Here is what the encoding step looks like now:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static unsafe uint Encode(byte* buffer, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (uint)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (uint)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;              buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.CopyBlock(buffer &#x2B; 1, &amp;key, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.CopyBlock(buffer &#x2B; 1 &#x2B; keyLen, &amp;val, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              return 1 &#x2B; keyLen &#x2B; valLen;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And in assembly:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Encode(ulong,long,long):uint:&#xA;        &#xA;        &#xA;          &#xA;                 push     r15&#xA;        &#xA;        &#xA;          &#xA;                 push     r14&#xA;        &#xA;        &#xA;          &#xA;                 push     r12&#xA;        &#xA;        &#xA;          &#xA;                 push     rbx&#xA;        &#xA;        &#xA;          &#xA;                 sub      rsp, 24&#xA;        &#xA;        &#xA;          &#xA;                 mov      qword ptr [rsp&#x2B;10H], rsi&#xA;        &#xA;        &#xA;          &#xA;                 mov      qword ptr [rsp&#x2B;08H], rdx&#xA;        &#xA;        &#xA;          &#xA;                 mov      rbx, rdi&#xA;        &#xA;        &#xA;          &#xA;                 xor      edi, edi&#xA;        &#xA;        &#xA;          &#xA;                 lzcnt    rdi, qword ptr [rsp&#x2B;10H]&#xA;        &#xA;        &#xA;          &#xA;                 shr      rdi, 3&#xA;        &#xA;        &#xA;          &#xA;                 mov      r14d, edi&#xA;        &#xA;        &#xA;          &#xA;                 neg      r14d&#xA;        &#xA;        &#xA;          &#xA;                 add      r14d, 8&#xA;        &#xA;        &#xA;          &#xA;                 xor      edi, edi&#xA;        &#xA;        &#xA;          &#xA;                 lzcnt    rdi, qword ptr [rsp&#x2B;08H]&#xA;        &#xA;        &#xA;          &#xA;                 shr      rdi, 3&#xA;        &#xA;        &#xA;          &#xA;                 mov      r15d, edi&#xA;        &#xA;        &#xA;          &#xA;                 neg      r15d&#xA;        &#xA;        &#xA;          &#xA;                 add      r15d, 8&#xA;        &#xA;        &#xA;          &#xA;                 mov      edi, r14d&#xA;        &#xA;        &#xA;          &#xA;                 shl      edi, 4&#xA;        &#xA;        &#xA;          &#xA;                 or       edi, r15d&#xA;        &#xA;        &#xA;          &#xA;                 mov      byte  ptr [rbx], dil&#xA;        &#xA;        &#xA;          &#xA;                 lea      rdi, [rbx&#x2B;01H]&#xA;        &#xA;        &#xA;          &#xA;                 lea      rsi, [rsp&#x2B;10H]&#xA;        &#xA;        &#xA;          &#xA;                 mov      r12d, r14d&#xA;        &#xA;        &#xA;          &#xA;                 mov      rdx, r12&#xA;        &#xA;        &#xA;          &#xA;                 call     [CORINFO_HELP_MEMCPY]&#xA;        &#xA;        &#xA;          &#xA;                 mov      edi, r14d&#xA;        &#xA;        &#xA;          &#xA;                 lea      rdi, [rbx&#x2B;rdi&#x2B;01H]&#xA;        &#xA;        &#xA;          &#xA;                 lea      rsi, [rsp&#x2B;08H]&#xA;        &#xA;        &#xA;          &#xA;                 mov      rdx, r12&#xA;        &#xA;        &#xA;          &#xA;                 call     [CORINFO_HELP_MEMCPY]&#xA;        &#xA;        &#xA;          &#xA;                 lea      eax, [r14&#x2B;r15&#x2B;01H]&#xA;        &#xA;        &#xA;          &#xA;                 add      rsp, 24&#xA;        &#xA;        &#xA;          &#xA;                 pop      rbx&#xA;        &#xA;        &#xA;          &#xA;                 pop      r12&#xA;        &#xA;        &#xA;          &#xA;                 pop      r14&#xA;        &#xA;        &#xA;          &#xA;                 pop      r15&#xA;        &#xA;        &#xA;          &#xA;                 ret      &#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Note that there are no branches at all here. Which I&#x2019;m really stoked about. As for decoding, we just have to go the other way around:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Main:Decode(ulong):System.ValueTuple`2[long,long]:&#xA;        &#xA;        &#xA;          &#xA;                 push     r15&#xA;        &#xA;        &#xA;          &#xA;                 push     r14&#xA;        &#xA;        &#xA;          &#xA;                 push     rbx&#xA;        &#xA;        &#xA;          &#xA;                 sub      rsp, 16&#xA;        &#xA;        &#xA;          &#xA;                 xor      eax, eax&#xA;        &#xA;        &#xA;          &#xA;                 mov      qword ptr [rsp&#x2B;08H], rax&#xA;        &#xA;        &#xA;          &#xA;                 mov      qword ptr [rsp], rax&#xA;        &#xA;        &#xA;          &#xA;                 mov      rbx, rdi&#xA;        &#xA;        &#xA;          &#xA;                 movzx    r14, byte  ptr [rbx]&#xA;        &#xA;        &#xA;          &#xA;                 mov      r15d, r14d&#xA;        &#xA;        &#xA;          &#xA;                 sar      r15d, 4&#xA;        &#xA;        &#xA;          &#xA;                 and      r14d, 15&#xA;        &#xA;        &#xA;          &#xA;                 lea      rdi, [rsp&#x2B;08H]&#xA;        &#xA;        &#xA;          &#xA;                 lea      rsi, [rbx&#x2B;01H]&#xA;        &#xA;        &#xA;          &#xA;                 mov      edx, r15d&#xA;        &#xA;        &#xA;          &#xA;                 call     [CORINFO_HELP_MEMCPY]&#xA;        &#xA;        &#xA;          &#xA;                 lea      rdi, [rsp]&#xA;        &#xA;        &#xA;          &#xA;                 mov      esi, r15d&#xA;        &#xA;        &#xA;          &#xA;                 lea      rsi, [rbx&#x2B;rsi&#x2B;01H]&#xA;        &#xA;        &#xA;          &#xA;                 mov      edx, r14d&#xA;        &#xA;        &#xA;          &#xA;                 call     [CORINFO_HELP_MEMCPY]&#xA;        &#xA;        &#xA;          &#xA;                 mov      rax, qword ptr [rsp&#x2B;08H]&#xA;        &#xA;        &#xA;          &#xA;                 mov      rdx, qword ptr [rsp]&#xA;        &#xA;        &#xA;          &#xA;                 add      rsp, 16&#xA;        &#xA;        &#xA;          &#xA;                 pop      rbx&#xA;        &#xA;        &#xA;          &#xA;                 pop      r14&#xA;        &#xA;        &#xA;          &#xA;                 pop      r15&#xA;        &#xA;        &#xA;          &#xA;                 ret      &#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          unsafe static (long Key, long Val) Decode(byte* buffer)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (uint)(buffer[0] &gt;&gt; 4);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (uint)(buffer[0] &amp; 0xF);&#xA;        &#xA;        &#xA;          &#xA;              long k = 0;&#xA;        &#xA;        &#xA;          &#xA;              long v = 0;&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.CopyBlock(&amp;k, buffer &#x2B; 1, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.CopyBlock(&amp;v, buffer &#x2B; 1 &#x2B;keyLen, valLen);&#xA;        &#xA;        &#xA;          &#xA;              return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;No branches, and really predictable code.&#xA;That is all great, but what about the sizes? We are always taking 4 additional bits per number. So it is actually a single additional byte for each entry we encode. By using varint, the memory we encode numbers that are beyond the 2GB range, we&#x2019;re already winning. Encoding (3,221,241,856), for example, will cost us 5 bytes (since we limit the range of each byte to 7 bits). The key advantage in our case is that if we have any case where either key or value needs to take an additional byte, we are at parity with the nibble method. If both of them need that, we are winning, since the nibble method will use a single additional byte and the variable size integer will take two (one for each number).&#xA;Now that we understand encoding and decoding, the rest of the code is basically the same. We just changed the internal format of the entry, nothing about the rest of the code changes.&#xA;And the results?&#xA;For the realistic dataset, we can fit 759 entries versus 712 for the variable integer model.&#xA;For the full dataset, we can fit 752 entries versus 710 for the variable integer model.&#xA;That is a 7% improvement in size, but it also comes with a really important benefit. Fewer branches.&#xA;This is the sort of code that runs billions of times a second. Reducing its latency has a profound impact on overall performance. One of the things that we pay attention to in high-performance code is the number of branches, because we are using super scalar CPUs, multiple instructions may execute in parallel at the chip level. A branch may cause us to stall (we have to wait until the result is known before we can execute the next instruction), so the processor will try to predict what the result of the branch would be. If this is a highly predictable branch (an error code that is almost never taken, for example), there is very little cost to that.&#xA;The variable integer code, on the other hand, is nothing but branches, and as far as the CPU is concerned, there is no way to actually predict what the result will be, so it has to wait. Branchless or well-predicted code is a key aspect of high-performance code. And this approach can have a big impact.&#xA;As a reminder, we started at 511 items, and we are now at 759. The question is, can we do more?&#xA;I&#x2019;ll talk about it in the next post&#x2026;</p>
        </article>
        <article id="article-677">
            <a href="https://ayende.com/blog/199361-B/fight-for-every-byte-it-takes-variable-size-data" target="_blank">
                <h2 class="title mb-6" id="article-677">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 25, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my previous post, we stored keys and values as raw numbers inside the 8KB page. That was simple, but wasteful. For many scenarios, we are never going to need to utilize the full 8 bytes range for a long. Most numbers are far smaller.&#xA;In the example I gave in the last post, we are storing the following range of numbers (file offsets, basically). I&#x2019;m using two test scenarios, one where I&#x2019;m testing the full range (for correctness) and one where I&#x2019;m testing files under 512 GB in size. Given that we are trying to compress the space, once we hit the 512GB mark, it is probably less urgent, after all.&#xA;Here are the number generations that I&#x2019;m using:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          IEnumerable&lt;long&gt; Generate_Full()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var rand = new Random(2023_04_21);&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  yield return rand.Next(100) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 3 =&gt; rand.NextInt64(0, 1L &lt;&lt; 7),  // 3%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 10 =&gt; rand.NextInt64(0, 1L &lt;&lt; 15),// 7%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 35 =&gt; rand.NextInt64(0, 1L &lt;&lt; 23),// 25%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 75 =&gt; rand.NextInt64(0, 1L &lt;&lt; 31),// 35%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 90 =&gt; rand.NextInt64(0, 1L &lt;&lt; 39),// 15%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 95 =&gt; rand.NextInt64(0, 1L &lt;&lt; 47),// 5%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 98 =&gt; rand.NextInt64(0, 1L &lt;&lt; 55),// 3%&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; rand.NextInt64(0, 1L &lt;&lt; 62)    // 2%&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          IEnumerable&lt;long&gt; Generate_Realistic()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var rand = new Random(2023_04_21);&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  yield return rand.Next(100) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 1 =&gt; rand.NextInt64(0, 1L &lt;&lt; 7),  // 1%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 3 =&gt; rand.NextInt64(0, 1L &lt;&lt; 15), // 2%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 30 =&gt; rand.NextInt64(0, 1L &lt;&lt; 23),// 27%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 75 =&gt; rand.NextInt64(0, 1L &lt;&lt; 31),// 35%&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; rand.NextInt64(0, 1L &lt;&lt; 39),   // 25%&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Generate.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;What this means is:&#xA;&#xA;&#xA;&#xA;Full data set&#xA;Realistic data set&#xA;&#xA;&#xA;&#xA;&#xA;&#xA0; 3% in the first 128 bytes&#xA;&#xA0; 7% in the first 64 KB&#xA;25% in the first 8 MB&#xA;35% in the first 2 GB&#xA;15% in the first 512 GB&#xA;5% in the first 128 TB&#xA;3% in the first 32 Petabytes&#xA;2% in the first 4 Exabytes&#xA;&#xA;&#xA;&#xA;&#xA;&#xA0; 1% in the first 128 bytes&#xA;&#xA0; 2% in the first 64 KB&#xA;27% in the first 8 MB&#xA;35% in the first 2 GB&#xA;25% in the first 512 GB&#xA;&#xA;&#xA0;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;This is meant to verify that we can handle any scenario, in practice, we can usually focus on the first 512 GB, which is far more common.&#xA;Using both approaches, I can fit using my previous approach, up to 511 entries per page. That makes sense, we are storing the data raw, so how can we do better? Most of the time, we don&#x2019;t need anywhere near 8 bytes per value. For that reason, we have variable length encoding, which has many names, such as variable size int, 7 bits integers, etc. I adapted some methods from the .NET codebase to allow me to operate on Spans, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static int Write7BitEncodedInt64(long value, Span&lt;byte&gt; buffer)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              // Adapted from: https://github.com/dotnet/runtime/blob/2087ceb0c70f0c13e79fbbdec90efd242e1f2cd4/src/libraries/System.Private.CoreLib/src/System/IO/BinaryWriter.cs#L492&#xA;        &#xA;        &#xA;          &#xA;              ulong uValue = (ulong)value;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // Write out an int 7 bits at a time. The high bit of the byte,&#xA;        &#xA;        &#xA;          &#xA;              // when on, tells reader to continue reading more bytes.&#xA;        &#xA;        &#xA;          &#xA;              //&#xA;        &#xA;        &#xA;          &#xA;              // Using the constants 0x7F and ~0x7F below offers smaller&#xA;        &#xA;        &#xA;          &#xA;              // codegen than using the constant 0x80.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int index = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (uValue &gt; 0x7Fu)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  buffer[index&#x2B;&#x2B;] = ((byte)((uint)uValue | ~0x7Fu));&#xA;        &#xA;        &#xA;          &#xA;                  uValue &gt;&gt;= 7;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              buffer[index&#x2B;&#x2B;] = ((byte)uValue);&#xA;        &#xA;        &#xA;          &#xA;              return index;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private static long Read7BitEncodedInt64(Span&lt;byte&gt; buffer, out int len)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              // Adapted from: https://github.com/dotnet/runtime/blob/2087ceb0c70f0c13e79fbbdec90efd242e1f2cd4/src/libraries/System.Private.CoreLib/src/System/IO/BinaryReader.cs#L588&#xA;        &#xA;        &#xA;          &#xA;              ulong result = 0;&#xA;        &#xA;        &#xA;          &#xA;              byte byteReadJustNow;&#xA;        &#xA;        &#xA;          &#xA;              len = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // Read the integer 7 bits at a time. The high bit&#xA;        &#xA;        &#xA;          &#xA;              // of the byte when on means to continue reading more bytes.&#xA;        &#xA;        &#xA;          &#xA;              //&#xA;        &#xA;        &#xA;          &#xA;              // There are two failure cases: we&#x27;ve read more than 10 bytes,&#xA;        &#xA;        &#xA;          &#xA;              // or the tenth byte is about to cause integer overflow.&#xA;        &#xA;        &#xA;          &#xA;              // This means that we can read the first 9 bytes without&#xA;        &#xA;        &#xA;          &#xA;              // worrying about integer overflow.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              const int MaxBytesWithoutOverflow = 9;&#xA;        &#xA;        &#xA;          &#xA;              for (int shift = 0; shift &lt; MaxBytesWithoutOverflow * 7; shift &#x2B;= 7)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // ReadByte handles end of stream cases for us.&#xA;        &#xA;        &#xA;          &#xA;                  byteReadJustNow = buffer[len&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;                  result |= (byteReadJustNow &amp; 0x7Ful) &lt;&lt; shift;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (byteReadJustNow &lt;= 0x7Fu)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      return (long)result; // early exit&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // Read the 10th byte. Since we already read 63 bits,&#xA;        &#xA;        &#xA;          &#xA;              // the value of this byte must fit within 1 bit (64 - 63),&#xA;        &#xA;        &#xA;          &#xA;              // and it must not have the high bit set.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              byteReadJustNow = buffer[len&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;              if (byteReadJustNow &gt; 0b_1u)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  throw new FormatException(&quot;Format_Bad7BitInt&quot;);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              result |= (ulong)byteReadJustNow &lt;&lt; (MaxBytesWithoutOverflow * 7);&#xA;        &#xA;        &#xA;          &#xA;              return (long)result;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          varint.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Let&#x2019;s check what sort of savings we can get using this approach:&#xA;&#xA;Under 127 bytes&#x2013; 1 byte&#xA;128 bytes .. 32 KB &#x2013; 2 bytes&#xA;32KB .. 8MB &#x2013; 3 bytes&#xA;8MB .. 2GB &#x2013; 4 bytes&#xA;2 GB .. 512 GB &#x2013; 5 bytes&#xA;512GB .. 128 TB &#x2013; 6 bytes&#xA;128TB .. 32 Petabytes &#x2013; 7 bytes&#xA;32 Petabytes .. 8 Exabytes &#x2013; 8 bytes&#xA;Greater than 8 Exabytes &#x2013; 9 bytes&#xA;&#xA;That is really cool, since for the realistic data set, we can pack a lot more data into the page.&#xA;It comes with a serious issue, however. The data is no longer fixed size (well, that is the point, no?). Why is that a problem? Because we want to be able to do a binary search on that, which means that we need to be able to access the data by index. As usual, the solution is to utilize indirection. We&#x2019;ll dedicate the bottom of the page to an array of fixed-size int (16 bits &#x2013; sufficient to cover the 8KB range of the page) that will point to the actual location of the entry. Like before, we are going to reserve the first few bytes as a header, in this case we&#x2019;ll use 4 bytes, divided into two shorts. Those will keep track of the writes to the bottom and the top of the page.&#xA;At the bottom, we&#x2019;ll have the actual offsets that point to the entries, and at the top, we write the actual entries. Here is what this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static Span&lt;ushort&gt; OffsetsFor(Span&lt;byte&gt; page)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var asShorts = MemoryMarshal.Cast&lt;byte, ushort&gt;(page);&#xA;        &#xA;        &#xA;          &#xA;              var bottom = asShorts[0];&#xA;        &#xA;        &#xA;          &#xA;              var top = asShorts[1]; // unused here, included for clarity&#xA;        &#xA;        &#xA;          &#xA;              return MemoryMarshal.CreateSpan(ref asShorts[2], (bottom - 4) / 2);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Header.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Let&#x2019;s see how our reading from the page will look now. As you can see, it is very similar to what we had before, but instead of going directly to the key by its offset, we have to use the indirection:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static bool TryGetValue(Span&lt;byte&gt; page, long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var idx = BinarySearch(page, key);&#xA;        &#xA;        &#xA;          &#xA;              if (idx &lt; 0) // update&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  val = default;&#xA;        &#xA;        &#xA;          &#xA;                  return false;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;              var entryOffset = offsets[idx];&#xA;        &#xA;        &#xA;          &#xA;              _ = Read7BitEncodedInt64(page[entryOffset..], out var keyLen);&#xA;        &#xA;        &#xA;          &#xA;              val = Read7BitEncodedInt64(page[(entryOffset &#x2B; keyLen)..], out _);&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          TryGetValue.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The offsets array contains the location of the entry in the page, and that is laid out as the [varint-key][varint-val]. So we read (and discard) the key from the offset we found (we have to do that to discover its size) and then we read and return the actual value.&#xA;Let&#x2019;s look at how we implemented the actual binary search in the page:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static int BinarySearch(Span&lt;byte&gt; page, long key)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;              int lo = 0, hi = offsets.Length - 1;&#xA;        &#xA;        &#xA;          &#xA;              while (lo &lt;= hi)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  int mid = (lo &#x2B; hi) &gt;&gt; 1;&#xA;        &#xA;        &#xA;          &#xA;                  var entryOffset = offsets[mid];&#xA;        &#xA;        &#xA;          &#xA;                  var cur = Read7BitEncodedInt64(page[entryOffset..], out _);&#xA;        &#xA;        &#xA;          &#xA;                  int cmp = key.CompareTo(cur);&#xA;        &#xA;        &#xA;          &#xA;                  if (cmp == 0)&#xA;        &#xA;        &#xA;          &#xA;                      return mid;&#xA;        &#xA;        &#xA;          &#xA;                  if (cmp &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      lo = mid &#x2B; 1;&#xA;        &#xA;        &#xA;          &#xA;                  else&#xA;        &#xA;        &#xA;          &#xA;                      hi = mid - 1;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // where it is *supposed* to go&#xA;        &#xA;        &#xA;          &#xA;              return ~lo;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          BinarySearch.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is a bog standard binary search, with the only interesting bit that we are going through the offsets array to find the actual location of the key, which we then read using variable size decoding.&#xA;The interesting part of this model happens when we need to set a value. Here is what this looks like, with my notes following the code.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static bool Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // header is 4 bytes [bottom, top] &#xA;        &#xA;        &#xA;          &#xA;              ref var bottom = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              ref var top = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[1]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (bottom == 0) // init empty page &#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  top = 8192; // top of the page&#xA;        &#xA;        &#xA;          &#xA;                  bottom = 4; // leave 4 bytes for the bottom/top header&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var usableSpace = top - bottom;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;byte&gt; temp = stackalloc byte[18]; // max varint = 9 - we need to encode 2&#xA;        &#xA;        &#xA;          &#xA;              var reqEntryLen = Write7BitEncodedInt64(key, temp);&#xA;        &#xA;        &#xA;          &#xA;              reqEntryLen &#x2B;= Write7BitEncodedInt64(val, temp[reqEntryLen..]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var idx = BinarySearch(page, key);&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;ushort&gt; offsets;&#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // let&#x27;s check if we can update?&#xA;        &#xA;        &#xA;          &#xA;                  offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;                  var entryOffset = offsets[idx];&#xA;        &#xA;        &#xA;          &#xA;                  Read7BitEncodedInt64(page[entryOffset..], out var keyLen);&#xA;        &#xA;        &#xA;          &#xA;                  Read7BitEncodedInt64(page[(entryOffset &#x2B; keyLen)..], out var valLen);&#xA;        &#xA;        &#xA;          &#xA;                  if (reqEntryLen &gt; keyLen &#x2B; valLen) // cannot fit, need new allocation&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (reqEntryLen &gt; usableSpace)&#xA;        &#xA;        &#xA;          &#xA;                          return false; // we are full, need to split the page&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  else&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      // can fit, just copy &amp; done&#xA;        &#xA;        &#xA;          &#xA;                      temp[..reqEntryLen].CopyTo(page[entryOffset..]);&#xA;        &#xA;        &#xA;          &#xA;                      return true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              else // increase size of offsets array&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (reqEntryLen &#x2B; sizeof(ushort) &gt; usableSpace)&#xA;        &#xA;        &#xA;          &#xA;                      return false; // we are full, need to split the page&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  idx = ~idx;&#xA;        &#xA;        &#xA;          &#xA;                  bottom &#x2B;= 2;&#xA;        &#xA;        &#xA;          &#xA;                  offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;                  offsets[idx..(offsets.Length - 1)].CopyTo(offsets[(idx &#x2B; 1)..]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              top -= (ushort)reqEntryLen;&#xA;        &#xA;        &#xA;          &#xA;              offsets[idx] = top; // new data location&#xA;        &#xA;        &#xA;          &#xA;              temp[..reqEntryLen].CopyTo(page[top..]);&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Set.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is quite a lot, I&#x2019;ll admit. Let&#x2019;s try to break up into individual pieces what is going on here.&#xA;First, we get the header values (bottom, top) and initialize them if empty (note that bottom is set to 4, after the header, while top is set to the end of the buffer). The idea is that the bottom grows up and the top grows down. This is called Slotted Page design and it is a staple of database design.&#xA;We then encode the key and the value into a temporary buffer. We need to do that so we&#x2019;ll know what size the entry will take. Then we need to figure out if we are updating an existing record or creating a new one.&#xA;Updating an existing record is complex. This is because the size of the new record may be greater than the size of the old one. So we can&#x2019;t put it in the same location. I&#x2019;m handling this by just allocating new space for this entry, ignoring the old space that was allocated to it.&#xA;&#xA;I&#x2019;m not handling any deletes / space reclamation on this series. That is a separate subject, not complex, but fairly tedious to do properly. So I&#x2019;m going to focus solely on writes.&#xA;&#xA;Updates to an existing entry that also change its size aren&#x2019;t in my test dataset, so I&#x2019;m not worried about it too much here. I mention this to point out that variable length records bring with them considerations that we wouldn&#x2019;t have run into with the fixed-size model.&#xA;And after all of this work? What are the results?&#xA;With the fixed-size version, we could fit 511 entries into the page. With the variable size int, however, we can do better.&#xA;For the realistic dataset, I can fit 712 entries for the page, and for the full dataset, 710 (there are very few very big elements even there, but we can see that it has an impact).&#xA;511 vs. 712 may not sound like much, but that is 40% increase in the number of entries that I can fit. To give some context, using 8KB pages, that is a difference of 5 MB per million entries. That adds up.&#xA;The question is, can we do better? More on that in my next post&#x2026;</p>
        </article>
        <article id="article-678">
            <a href="https://andrewlock.net/super-charging-git-rebase-with-git-absorb/" target="_blank">
                <h2 class="title mb-6" id="article-678">Super-charging &#x27;git rebase&#x27; with &#x27;git absorb&#x27;</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 25, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I describe the git-absorb tool, and show how it can super-charge your git rebase workflow, removing a huge amount of manual work!&#x2026;</p>
        </article>
        <article id="article-679">
            <a href="https://ayende.com/blog/199329-B/fight-for-every-byte-it-takes-storing-raw-numbers" target="_blank">
                <h2 class="title mb-6" id="article-679">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 24, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I write databases for a living, which means that I&#x2019;m thinking a lot about persistence. Here is a fun challenge that we went through recently. We have the need to store a list of keys and values and then lookup a value by key. Pretty standard stuff. The keys and values are both 64 bits integers. In other words, what I would like to have is:&#xA;&#xA;Dictionary&lt;long,long&gt; lookup;&#xA;&#xA;That would be perfect, except that I&#x2019;ve to persist the data, which means that I have to work with raw bytes. It&#x2019;s easiest to think about it if we have some code in front of us. Here is the interface that I need to implement:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // impl...&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          bool TryGetValue(Span&lt;byte&gt; page, long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // impl...&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Page.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we have a byte buffer (8KB in size) and we want to add or lookup values from the buffer. All the data resides&#xA0;in the buffer, nothing is external. And we cannot unpack it in memory, because this is used for lookups, so this needs to be really fast.&#xA;The keys we are storing are file offsets, so they correlate quite nicely to the overall size of the file. Meaning that you&#x2019;ll have a lot of small values, but also large ones. Given a key, we need to be able to look its value quickly, since we may run this lookup billions of times.&#xA;Given that I have 8KB of data, I can do the following, just treat the buffer as a sorted array, which means that I get a pretty easy way to search for a particular value and a simple way to actually store things.&#xA;Theoretically, given an 8KB page, and 16 bytes per each (key, value) entry, we can store up to 512 entries per page. But it turns out that this is just a theory. We also need to keep track of the number of items that we have, and that takes some space. Just a couple of bytes, but it means that we don&#x2019;t have those bytes available. A page can now contain up to 511 entries, and even at full capacity, we have 14 bytes wasted (2 for the number of entries, and the rest are unused).&#xA;Here is what this looks like in code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          bool Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // takes two bytes, but we reserve 8 bytes to make alignment easier&#xA;        &#xA;        &#xA;          &#xA;              ref var numberOfItems = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              // actual usable range&#xA;        &#xA;        &#xA;          &#xA;              var entries = MemoryMarshal.CreateSpan(ref MemoryMarshal.Cast&lt;byte, long&gt;(page)[1], page.Length / sizeof(long) - 1);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var keys = entries[..numberOfItems]; // from the bottom&#xA;        &#xA;        &#xA;          &#xA;              var values = entries[(entries.Length - numberOfItems)..]; // from the top&#xA;        &#xA;        &#xA;          &#xA;              var idx = keys.BinarySearch(key); // makes searching easy&#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0) // update&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  values[idx] = val;&#xA;        &#xA;        &#xA;          &#xA;                  return true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if (numberOfItems &gt;= entries.Length / 2)&#xA;        &#xA;        &#xA;          &#xA;                  return false; // we are full, need to split the page&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;              idx = ~idx; // find where it *should* go&#xA;        &#xA;        &#xA;          &#xA;              numberOfItems&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              // now extend the ranges&#xA;        &#xA;        &#xA;          &#xA;              keys = entries[..numberOfItems];&#xA;        &#xA;        &#xA;          &#xA;              values = entries[(entries.Length - numberOfItems)..];&#xA;        &#xA;        &#xA;          &#xA;              // move the existing entries to make room for the new one&#xA;        &#xA;        &#xA;          &#xA;              keys[..idx].CopyTo(keys[idx..]);&#xA;        &#xA;        &#xA;          &#xA;              values[1..(idx &#x2B; 1)].CopyTo(values[0..idx]);&#xA;        &#xA;        &#xA;          &#xA;              keys[idx] = key;&#xA;        &#xA;        &#xA;          &#xA;              values[idx] = val;&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          bool TryGetValue(Span&lt;byte&gt; page, long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // takes two bytes, but we reserve 8 bytes to make alignment easier&#xA;        &#xA;        &#xA;          &#xA;              ref var numberOfItems = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              // actual usable range&#xA;        &#xA;        &#xA;          &#xA;              var entries = MemoryMarshal.CreateSpan(ref MemoryMarshal.Cast&lt;byte, long&gt;(page)[1], page.Length / sizeof(long) - 1);&#xA;        &#xA;        &#xA;          &#xA;              var keys = entries[..numberOfItems]; &#xA;        &#xA;        &#xA;          &#xA;              var values = entries[(entries.Length - numberOfItems)..];&#xA;        &#xA;        &#xA;          &#xA;              var idx = keys.BinarySearch(key); &#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0) // update&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  val = values[idx];&#xA;        &#xA;        &#xA;          &#xA;                  return true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              val = default;&#xA;        &#xA;        &#xA;          &#xA;              return false;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          SimpleArray.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we are creating two arrays, the keys are growing from the bottom of the page and the values are growing from the top. The idea is that I can utilize the BinarySearch() method to quickly find the index of a key (or where it&#xA0;ought) to go. From there, I can look at the corresponding values array to get the actual value. The fact that they are growing separately (and toward each other) means that I don&#x2019;t need to move as much memory if I&#x2019;m getting values out of order.&#xA;For now, I want to set up the playground in which we&#x2019;ll operate. The type of data that you write into such a system is important. I decided to use the following code to generate the test set:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          IEnumerable&lt;long&gt; Generate()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var rand = new Random(2023_04_21);&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  yield return rand.Next(100) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 3 =&gt; rand.NextInt64(0, 1L &lt;&lt; 7),  // 3%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 10 =&gt; rand.NextInt64(0, 1L &lt;&lt; 15),// 7%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 35 =&gt; rand.NextInt64(0, 1L &lt;&lt; 23),// 25%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 75 =&gt; rand.NextInt64(0, 1L &lt;&lt; 31),// 35%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 90 =&gt; rand.NextInt64(0, 1L &lt;&lt; 39),// 15%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 95 =&gt; rand.NextInt64(0, 1L &lt;&lt; 47),// 5%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 98 =&gt; rand.NextInt64(0, 1L &lt;&lt; 55),// 3%&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; rand.NextInt64(0, 1L &lt;&lt; 62)    // 2%&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Generate.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is that we&#x2019;ll generate a random set of numbers, in the given distribution. Most of the values are in the range of 8MB to 512GB, representing a pretty good scenario overall, I think.&#xA;And with that, we just need to figure out what metrics we want to use for this purpose. My goal is to push as many values as I can into the buffer, while maintaining the ability to get a value by its key as fast as possible.&#xA;The current approach, for example, does a binary search on a sorted array plus an extra lookup to the companion values array. You really can&#x2019;t beat this, if you allow to store arbitrary keys. Here is my test bench:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Span&lt;byte&gt; buffer = new byte[8192];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var enumerator = Generate().GetEnumerator();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var index = 0;&#xA;        &#xA;        &#xA;          &#xA;          while (true)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;              var k = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;              enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;              var v = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;              if (Set(buffer, k, v) == false)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  Console.WriteLine(&quot;Inserted: &quot; &#x2B; Validate(buffer, index));&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              index&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              Validate(buffer, index);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          int Validate(Span&lt;byte&gt; buffer, int index)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var enumerator = Generate().GetEnumerator();&#xA;        &#xA;        &#xA;          &#xA;              var dic = new Dictionary&lt;long, long&gt;();&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; index; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;                  var k = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;                  enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;                  var v = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;                  dic[k] = v; // need to handle update to the same value&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              foreach (var (k,expected) in dic)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (TryGetValue(buffer, k, out var actual) == false || expected != actual)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      Console.WriteLine($&quot;Missed: {k}! {expected} != {actual}&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return dic.Count;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Tester.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This will insert key/value pairs into the page until it is full. Note that we allow duplicates (we&#x2019;ll just update the value), so we need to keep track of the number of entries inserted, not just the number of insertions.&#xA0; We also validate the structure at any step of the way, to ensure that we always get the right behavior.&#xA;This code runs as expected and we can put 511 values into the page before it gives up. This approach works, it is simple to reason about and has very few flaws. It is also quite wasteful in terms of information density. I would like to do better than 511 entries / pager. Is it possible to drop below 16 bytes per entry?&#xA;Give it some thought, I&#x2019;m going to present several ways of doing just that in my next post&#x2026;</p>
        </article>
        <article id="article-680">
            <a href="https://www.meziantou.net/retry-a-bash-command.htm" target="_blank">
                <h2 class="title mb-6" id="article-680">Retrying a bash command</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 24, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">There are many reasons for commands to fail. Some of them provide retry options, but others don&#x27;t. In this post, I describe how to retry a bash command multiple times until it succeeds.To retry a command in Bash, you can use a while loop. The loop will execute the command and if the command returns</p>
        </article>
        <div class="button flex justify-between">
            <a href="67.html"><span class="back arrow"></span></a>

            <a href="69.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>

<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;🚀&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="about.html"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="/pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>
