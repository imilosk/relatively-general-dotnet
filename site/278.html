
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Home â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">
<script>
    const lightModePref = window.matchMedia("(prefers-color-scheme: light)");

    function getUserPref() {
        const storedTheme = typeof localStorage !== "undefined" && localStorage.getItem("theme");
        return storedTheme || (lightModePref.matches ? "light" : "dark");
    }

    function setTheme(newTheme) {
        if (newTheme !== "light" && newTheme !== "dark") {
            return console.warn(
                `Invalid theme value '${newTheme}' received. Expected 'light' or 'dark'.`,
            );
        }

        const root = document.documentElement;

        // root already set to newTheme, exit early
        if (newTheme === root.getAttribute("data-theme")) {
            return;
        }

        root.setAttribute("data-theme", newTheme);

        const colorThemeMetaTag = document.querySelector("meta[name='theme-color']");
        const bgColour = getComputedStyle(document.body).getPropertyValue("--theme-bg");
        colorThemeMetaTag.setAttribute("content", `hsl(${bgColour})`);
        if (typeof localStorage !== "undefined") {
            localStorage.setItem("theme", newTheme);
        }
    }

    // initial setup
    setTheme(getUserPref());

    document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("theme-toggle").addEventListener("click", () => {
            const theme = localStorage.getItem("theme");

            if (theme === "dark") {
                setTheme("light");
            } else {
                setTheme("dark");
            }
        });

        document.getElementById("toggle-navigation-menu").addEventListener("click", (e) => {
            const button = e.target;
            const ariaExpanded = button.getAttribute("aria-expanded");
            const header = document.getElementById("main-header");

            if (ariaExpanded === "true") {
                button.setAttribute("aria-expanded", "false");
                header.classList.remove("menu-open");
            } else {
                button.setAttribute("aria-expanded", "true");
                header.classList.add("menu-open");
            }
        });
    });
</script>

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <theme-toggle class="ms-auto">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main">
    <section aria-label="Blog post list">
        <a href="https://ayende.com/blog/164545/windows-overlapped-i-o-and-tpl-style-programming" target="_blank"><h1 class="title mb-6">Windows Overlapped I/O and TPL style programming</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 26, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I really like the manner in which C# async tasks work. And while building Voron, I run into a scenario in which I could really make use of Windows async API. This is exposed via the Overlapped I/O. The problem is that those are pretty different models, and they don&#x2019;t appear to want to play together very nicely. Since I don&#x2019;t feel like having those two cohabitate in my codebase, I decided to see if I could write a TPL wrapper that would provide nice API on top of the underlying Overlapped I/O implementation. Here is what I ended up with:      1: public unsafe class Win32DirectFile : IDisposable   2: {   3:     private readonly SafeFileHandle _handle;   4:&#xA0;    5:     public Win32DirectFile(string filename)   6:     {   7:         _handle = NativeFileMethods.CreateFile(filename,   8:             NativeFileAccess.GenericWrite | NativeFileAccess.GenericWrite, NativeFileShare.None, IntPtr.Zero,   9:             NativeFileCreationDisposition.CreateAlways,  10:             NativeFileAttributes.Write_Through | NativeFileAttributes.NoBuffering | NativeFileAttributes.Overlapped, IntPtr.Zero);  11:&#xA0;   12:         if (_handle.IsInvalid)  13:             throw new Win32Exception();  14:&#xA0;   15:         if(ThreadPool.BindHandle(_handle) == false)  16:             throw new InvalidOperationException(&quot;Could not bind the handle to the thread pool&quot;);  17:     }&#xA;Note that I create the file with overlapped enabled, as well as write_through &amp; no buffering (I need them for something else, not relevant for now).&#xA;It it important to note that I bind the handle (which effectively issue a BindIoCompletionCallback under the cover, I think), so we won&#x2019;t have to use events, but can use callbacks. This is much more natural manner to work when using the TPL.&#xA;Then, we can just issue the actual work:&#xA;&#xA;&#xA;   1: public Task WriteAsync(long position, byte* ptr, uint length)   2: {   3:     var tcs = new TaskCompletionSource&lt;object&gt;();   4:&#xA0;    5:     var nativeOverlapped = CreateNativeOverlapped(position, tcs);   6:        7:     uint written;   8:     var result = NativeFileMethods.WriteFile(_handle, ptr, length, out written, nativeOverlapped);   9:       10:     return HandleResponse(result, nativeOverlapped, tcs);  11: }&#xA;As you can see, all the actual details are handled in the helper functions, we can just run the code we need, passing it the overlapped structure it requires. Now, let us look at those functions:&#xA;&#xA;&#xA;   1: private static NativeOverlapped* CreateNativeOverlapped(long position, TaskCompletionSource&lt;object&gt; tcs)   2: {   3:     var o = new Overlapped((int) (position &amp; 0xffffffff), (int) (position &gt;&gt; 32), IntPtr.Zero, null);   4:     var nativeOverlapped = o.Pack((code, bytes, overlap) =&gt;   5:     {   6:         try   7:         {   8:             switch (code)   9:             {  10:                 case ERROR_SUCCESS:  11:                     tcs.TrySetResult(null);  12:                     break;  13:                 case ERROR_OPERATION_ABORTED:  14:                     tcs.TrySetCanceled();  15:                     break;  16:                 default:  17:                     tcs.TrySetException(new Win32Exception((int) code));  18:                     break;  19:             }  20:         }  21:         finally  22:         {  23:             Overlapped.Unpack(overlap);  24:             Overlapped.Free(overlap);  25:         }  26:     }, null);  27:     return nativeOverlapped;  28: }  29:&#xA0;   30: private static Task HandleResponse(bool completedSyncronously, NativeOverlapped* nativeOverlapped, TaskCompletionSource&lt;object&gt; tcs)  31: {  32:     if (completedSyncronously)  33:     {  34:         Overlapped.Unpack(nativeOverlapped);  35:         Overlapped.Free(nativeOverlapped);  36:         tcs.SetResult(null);  37:         return tcs.Task;  38:     }  39:&#xA0;   40:     var lastWin32Error = Marshal.GetLastWin32Error();  41:     if (lastWin32Error == ERROR_IO_PENDING)  42:         return tcs.Task;  43:&#xA0;   44:     Overlapped.Unpack(nativeOverlapped);  45:     Overlapped.Free(nativeOverlapped);  46:     throw new Win32Exception(lastWin32Error);  47: }&#xA;The complexity here is that we need to handle 3 cases:&#xA;&#xA;Successful completion&#xA;Error (no pending work)&#xA;Error (actually success, work is done in an async manner).&#xA;But that seems to be working quite nicely for me so far.</p>
        <a href="https://ayende.com/blog/164487/so-how-does-this-works-on-linux" target="_blank"><h1 class="title mb-6">So, how does this works on Linux?</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 25, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">For the past few days I have been talking about our findings with regards to creating ACID storage solution. And mostly I&#x2019;ve been focusing on how it works with Windows, using Windows specific terms and APIs. The problem is that I am not sure if those are still relevant if we talk about Linux. I know that fsync perf is still an issue (if only because both Win &amp; Lin are running on the same hardware). But would the same solutions apply? For example, the nearest that I can find to FILE_FLAG_NO_BUFFERING is O_DIRECT and FILE_FLAG_WRITE_THROUGH appears to be similar to&#xA0; O_SYNC. But I am not sure if they are actually behaving in the same fashion. Any ideas? Anyone has something like Process Monitor for Linux and can look at the actual behavior of industry grade databases commit behavior? From my exploring, it appears that PostgreSQL is using fdatasync() as the default approach, but it can use O_DIRECT and O_DSYNC as well, so that is promising. But I would like to have someone who actually know Linux intimately tell me if I am even in the right direction.</p>
        <a href="https://ayende.com/blog/164486/storing-the-header-information" target="_blank"><h1 class="title mb-6">Storing the header information</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 22, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In Voron, we use a double buffer approach. We use the first two pages of the file to alternately write the last version of the database info. For example, the last transaction id, among other things. The problem is that when we make those changes, we have to call fsync on that, and as we have seen, that is something that we would like to avoid if possible. Because of that, we are going to try something different. We are going to extract the header information from the first few pages of the file in favor of holding them as separate files: header.one and header.two The idea is that they are very small files, and as such, it would be cheap to fsync them independently. Moreover, we can take advantage of the fact that very small files (and in this case, I am not sure we even above 256 bytes) are usually stored in the MFT in NTFS and in the inode in ext4. That means that fsync would get both data and metadata at the same time, hopefully just writing out a single block. I am not sure how useful that is going to be, but I have hopes.</p>
        <a href="https://ayende.com/blog/164641/ravendb-the-road-to-release" target="_blank"><h1 class="title mb-6">RavenDB</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 21, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This post is here to answer several queries in the mailing list, and some questions that were raised in this blog post. I think that this is important enough to warrant a post here, instead of an email to the list, or just a comment. To summarize, we had a few issues recently that impacted our users&#x2019; systems. Those are usually (but not always) cases where a combination of features wasn&#x2019;t working properly (feature intersection), or just actual bugs. That led to some questions that are worth answering. You can find all the details below, but I would like to talk about what we are actually doing. In the past 4 or 5 years, we have managed to create a NoSQL database for the .NET platform, and it has been doing nothing but picking up steam ever since we released it. We have been working hard to provide performance, features and stability for our users. On a personal note, it has been quite an amazing ride, seeing more people put RavenDB to use and creating interesting applications and features. First, there seems to be some concerns about the new things that we are doing. Voron, in particular, appears to be a cause for concern. We have relied on Esent as our storage engine for the past four or five years, to great success. Not least of its properties is the fact that Esent has been around the block for a while now, and is proven to be robust and safe in the simplest of methods, high and constant use over multiple decades. Esent also have its share of problems, but we didn&#x2019;t forget why we chose it in the first place. Indeed, I still think that that was an excellent choice. With Voron, the only change you&#x2019;ll see is that it won&#x2019;t be the only choice. Voron is meant to allow us to run on Linux machines, and to provide us with a fully owned stack, so we can do more interesting things across the board. But we aren&#x2019;t letting go of Esent, and in any way you care to name, Esent is still going to be the core (and default) option we have for storage in RavenDB. With RavenDB 3.0, you&#x2019;ll have the option to make an informed choice about selecting Voron as a storage engine, with a list of pros &amp; cons. Second, we do acknowledge that we suffer from a typical blindness for how we approach RavenDB. Since we built it, we know how things are supposed to be, and that is how we usually test them. Even when we try to go for the edge cases, we are constrained by our own thinking. We are currently working on getting an external testing team to do just that. Actively work to make use of RavenDB in creative ways specifically to try to break it.  Third, our own internal policies for releasing RavenDB need to be adjusted slightly. In particular, we are usually faced with two competing pressures: Release Already and Super Stable. We have always tried to release both unstable and stable versions, and the process for moving from unstable to stable is a pretty good one, I think. We have:  The test suite, now clocking at just over 3,000 tests.  A separate test suite that is meant to stress test the database.  Performance test suite, to make sure that we are in line for general performance.  Longevity tests, making sure that we don&#x2019;t have any issues in long term usage.  Finally, as an act of dog fooding, we upgrade our own servers to the new build, and let it run in production for a while, just to make absolutely sure. We are going to add additional tests (see the 2nd point) to the process, and we are going to extend the duration of all of those steps.&#xA0; I think that in the past few months we have have leaned too far toward the &#x201C;Release Already&#x201D; mode, so we are going to try to lean back (hopefully not too much) the other way.&#xA0;  Fourth, with regards to licensing. It has been our policy to provide anyone with a free trail license of RavenDB if they want to test it on a temporary basis. We require permanent non developer servers to have a license. I think that this strikes the appropriate balance.  Fifth, we are going to be working on additional tooling round deployment and upgrades. For customers that jump multiple versions (moving from 1.x to 2.5, for example), the update process of the RavenDB internal storage data during upgrades can be lengthy and there is too little visibility into it at the moment. We are also working on building tools that help figure out what is going on with a production instance (more ops endpoint, more visibility into internal operations, etc). In summary, we are grateful for our users for bringing any issues to our attention. We are trying hard to have a very responsive feedback cycle, and we can usually resolve most issues within 24 &#x2013; 48 hours. But I know we need to do better in making sure that users have a more streamlined experience.</p>
        <a href="https://ayende.com/blog/164485/and-we-need-some-scratch-space-to-work-with" target="_blank"><h1 class="title mb-6">And we need some scratch space to work with</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 20, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">So far, we have got to the conclusion that we are going to ditch fsync in favor of unbuffered write through calls. We also saw that it can play nicely with memory mapped files, which is what we are using for Voron. However, there is a problem here. Before we can write the data to the journal file, we need some way to actually put it. Previously, we could use the memory directly from the memory mapped journal file, and then just flush it. However, now we cannot do that, the only writes that we can do to the journal are using the unbufered write through I/O. Otherwise, we have to deal call fsync again. And sadly, we cannot call WriteFile on the memory that is mapped to the same part of the file that we write to.  That means that we need some scratch space to work with. And that means that we need to make some choices here. The obvious place to handle this scratch space is memory. The problem with that is that this means that we are going to compete with the rest of the system for available memory. In particular, we would need some way to free up memory after we use it, or we may hold into it forever. But if we free the memory, we might need to use it again, in which case we have a free/alloc pattern that isn&#x2019;t going to be good. Ideally, we want to get a continuous range of memory, so that probably explains why we care about its size and not releasing it early. One thing that I should note is that we are worried mostly about big transactions, ones that might need to touch hundreds or thousands of megabytes. Those tend to be rare, yes, but I hate to have any sort of hard limits in my software. So what we&#x2019;ll probably do is create another memory mapped file, of a size that is at least as big as the current journal file. And we will put all of our in flight transactional data in there. The good news about it is that we can re-use the space on every transaction, just overwriting what previous values. It also means that we easily expand the size of the current transaction buffer, so to speak. And under high memory pressure, we have an easier way to handle things.  When the transaction actually commits, we will write directly from the scratch space to the journal file, as a single, sequential, unbuffered write through write. Externally, there would be much of a change. And most of that would probably just have to do with the transaction commit semantics. Speaking of which, we probably want to talk about the way we store the header information&#x2026;</p>
        <a href="https://ayende.com/blog/164484/are-you-tripping-on-acid-i-think-you-forgot-something" target="_blank"><h1 class="title mb-6">Are you tripping on ACID? I think you forgot something&#x2026;</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 19, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After going over all the options for handling ACID, I am pretty convinced that the fsync approach isn&#x2019;t a workable one for high speed transactional writes. It is just too expensive.  Indeed, when looking at how both SQL Server and Esent handle this, they are using unbufferred write through writes to handle this. Now, those are options that are available to us as well. We have the FILE_FLAG_WRITE_THROUGH and FILE_FLAG_NO_BUFFERING options with Windows (I&#x2019;ll discuss Linux in another post). Ususally FILE_FLAG_NO_BUFFERING is problematic, because it requires you to write with specific memory alignment. However, we are already doing only paged writes, so that isn&#x2019;t an issue. We can already satisfy exactly what FILE_FLAG_NO_BUFFERING requires.  However, using FILE_FLAG_NO_BUFFERING comes with a cost. If you are using unbuffered I/O, you cannot be using the buffer cache. In fact, in order to test our code on cold start, we do an unbuffered I/O to reset it, and the results are pretty drastic. However, the only place were we actually need to do all of this is in the journal file. And we only have a single active one at any given point in time. The problem is, of course, that we want to both read &amp; write from the same file. So I decided to run some tests to see how the system will behave. I wrote the following code:      1: var file = @&quot;C:\Users\Ayende\Documents\visual studio 11\Projects\ConsoleApplication3\ConsoleApplication3\bin\data\test.ts&quot;;   2: using (var fs = new FileStream(file, FileMode.Create))   3: {   4:     fs.SetLength(1024 * 1024 * 10);// 10 MB file   5: }   6:&#xA0;    7: var page = new byte[4096];   8:&#xA0;    9: new Random(123).NextBytes(page);  10:&#xA0;   11: using (var fs = new FileStream(file, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))  12: {  13:     var memoryMappedFile =  14:         MemoryMappedFile.CreateFromFile(new FileStream(file, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite, 4096, FileOptions.None),  15:             &quot;foo&quot;, 1024 * 1024 * 10, MemoryMappedFileAccess.ReadWrite, null,  16:             HandleInheritability.None, false);  17:     var memoryMappedViewAccessor = memoryMappedFile.CreateViewAccessor();  18:&#xA0;   19:&#xA0;   20:     fs.Position = 4096 * 2;  21:     fs.Write(page, 0, page.Length);  22:&#xA0;   23:&#xA0;   24:     memoryMappedViewAccessor.ReadByte(4096 * 2 &#x2B; 8);  25:&#xA0;   26:     fs.Position = 4096 * 4;  27:     fs.Write(page, 0, page.Length);  28:&#xA0;   29:     memoryMappedViewAccessor.ReadByte(4096 * 2 &#x2B; 8);  30:&#xA0;   31:     memoryMappedViewAccessor.ReadByte(4096 * 4 &#x2B; 8);  32:&#xA0;   33: }&#xA;As you can see, what we are doing is actually writing to a file using standard File I/O, and reading via memory mapped file. I&#x2019;m pre-allocating the data, and I am using two handles. Nothing strange happening here.&#xA;And here is the system behavior below. Note that we don&#x2019;t have any ReadFile calls. The answer to the memory mapped reads were done directly from the file system buffers, no need to touch the disk.&#xA;&#xA;Note that this is my baseline test. I want to start adding write through &amp; no buffering and see how it works.&#xA;I changed the fs constructor to be:&#xA;&#xA;&#xA;   1: using (var fs = new FileStream(file, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite, 4096,FileOptions.WriteThrough))&#xA;Which gave us the following:&#xA;&#xA;&#xA;I am not really sure about this behavior, but I am guessing that what actually happened here is that we are seeing several levels of calls (probably we have unbufferred write followed by a memory map write?). Our write to send a page ended up writing a bit more, but that is fine.&#xA;Next, we want to see what is going on with no buffering &amp; write through, which means that I need to write the following:&#xA;&#xA;&#xA;   1: const FileOptions fileFlagNoBuffering = (FileOptions)0x20000000;   2: using (var fs = new FileStream(file, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite, 4096, FileOptions.WriteThrough | fileFlagNoBuffering))&#xA;And we get the following behavior:&#xA;&#xA;And now we can actually see the behavior that I was afraid of. After making the write to the file, we lose that part of the buffer, so we need to read it again from the file.&#xA;However, it is smart enough to know that the data haven&#x2019;t changed, so subsequent reads (even if there have been writes to other parts of the file) can still use the buffered data.&#xA;Finally, we have the final try, with just NoBuffering and no WriteThrough:&#xA;&#xA;According to this blog post, NoBuffering without WriteThrough had a significant performance benefit. However, I don&#x2019;t really see this, and both observation through Process Monitor and the documentation suggests that both Esent and SQL Server are using both flags.&#xA;In fact:&#xA;&#xA;All versions of SQL Server open the log and data files using the Win32 CreateFile function. The dwFlagsAndAttributesmember includes the FILE_FLAG_WRITE_THROUGH option when opened by SQL Server.&#xA;FILE_FLAG_WRITE_THROUGHThis option instructs the system to write through any intermediate cache and go directly to disk. The system can still cache write operations, but cannot lazily flush them.The FILE_FLAG_WRITE_THROUGH option ensures that when a write operation returns successful completion the data is correctly stored in stable storage. This aligns with the Write Ahead Logging (WAL) protocol specification to ensure the data.&#xA;So I think that this is where we will go for now. There is still an issue here, regarding current transaction memory, but I&#x2019;ll address it in my next post.</p>
        <a href="https://ayende.com/blog/164482/some-notes-about-fsync" target="_blank"><h1 class="title mb-6">Some notes about fsync</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 18, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">On my laptop, fsync has effectively no cost. That is probably because of some configuration setting (it is a battery based system, no need to pay the fsync call).&#xA0; On my desktop machine (significantly more powerful than my laptop), I have an fsync times that are an order of magnitude or more higher. In practice, if you work with fsync, you can expect to get a maximum of about 200 &#x2013; 300 fsync calls per second on SSD, and significantly less on HDD. If you are seeing higher numbers than that, you are probably not really doing fsync, and are exposed to data integrity issues if you have a hard crash.  In particular, it appears that for high performance code, you really want to forget all about fsync for ensuring your transactional needs.  And that is before we started talking about the cost of fsync (FlushFileBuffers, to be more accurate) as the file size grows. It appears that there is at least some correlation between the size of the file and the cost of calling fsyn/FlushFileBuffers on it.  Considering that we are talking about potentially very large files, we really want to be careful about it. All in all, I think that we need to say goodbye to relying of fsync for ensuring ACID. But how can we ensure that we&#x2019;ll be properly ACID? Well, the answer is in the previous post, look at how other people are doing it, but I&#x2019;ll expand on that in my next post.</p>
        <a href="https://ayende.com/blog/164577/is-select-broken-memory-mapped-files-with-unbufferred-writes-race-condition" target="_blank"><h1 class="title mb-6">Is select() broken? Memory mapped files with unbufferred writes == race condition?</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 16, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Let me start this post by stating that I am not even sure if what I am trying to do is legal here. But from reading the docs, it does appear to be a valid use of the API, and it does work, most of the time. The full code can be found here: https://gist.github.com/ayende/7495987 The gist of it is that I am trying to do two things:  Write to a file opened with FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING. Read from this file using a memory map. Occasionally, I get into situations where after I wrote to the file, I am not reading what I wrote. I have a repro, and we reproduced this on multiple machines. Both Windows 7 and Windows 8. Here is the relevant code (the full code is in the link), explanation on it below:      1: const uint nNumberOfBytesToWrite = 4096*3;   2: var buffer = (byte*)(VirtualAlloc(IntPtr.Zero, new UIntPtr(nNumberOfBytesToWrite), AllocationType.COMMIT, MemoryProtection.READWRITE)   3:             .ToPointer());   4:&#xA0;    5: for (int i = 0; i &lt; nNumberOfBytesToWrite; i&#x2B;&#x2B;)   6: {   7:     *(buffer &#x2B; i) = 137;   8: }   9:&#xA0;   10: var g = Guid.NewGuid().ToString();  11:&#xA0;   12: var safeHandle = CreateFile(g,  13:     NativeFileAccess.GenericRead | NativeFileAccess.GenericWrite,  14:     NativeFileShare.Read, IntPtr.Zero,  15:     NativeFileCreationDisposition.OpenAlways,  16:     NativeFileAttributes.Write_Through | NativeFileAttributes.NoBuffering | NativeFileAttributes.DeleteOnClose,  17:     IntPtr.Zero);  18:&#xA0;   19: var fileStream = new FileStream(safeHandle, FileAccess.ReadWrite);  20: fileStream.SetLength(1024 * 1024 * 1024); // 1gb  21:&#xA0;   22: if (safeHandle.IsInvalid)  23: {  24:     throw new Win32Exception();  25: }  26:&#xA0;   27: FileStream mms = fileStream;  28: //mms = new FileStream(g, FileMode.Open, FileAccess.Read, FileShare.ReadWrite | FileShare.Delete);  29: var mmf = MemoryMappedFile.CreateFromFile(mms, Guid.NewGuid().ToString(), fileStream.Length,  30:     MemoryMappedFileAccess.Read, null, HandleInheritability.None, true);  31:&#xA0;   32: MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor(0, fileStream.Length, MemoryMappedFileAccess.Read);  33: byte* ptr = null;  34: accessor.SafeMemoryMappedViewHandle.AcquirePointer(ref ptr);  35:&#xA0;   36: Task.Factory.StartNew(() =&gt;  37: {  38:     long lastPos = 0;  39:     while (true)  40:     {  41:         int count = 0;  42:         while (true)  43:         {  44:             if (*(ptr &#x2B; lastPos) != 137)  45:             {  46:                 break;  47:             }  48:             lastPos &#x2B;= 4096;  49:             count &#x2B;&#x2B;;  50:         }  51:         Console.WriteLine();  52:         Console.WriteLine(&quot;Verified {0} MB&quot;, count * 4 / 1024);  53:         Console.WriteLine();  54:         Thread.Sleep(2000);  55:     }  56: });  57:&#xA0;   58: for (int i = 0; i &lt; 1024*64; i&#x2B;&#x2B;)  59: {  60:     var pos = i*nNumberOfBytesToWrite;  61:     if (i%100 == 0)  62:         Console.Write(&quot;\r{0,10:#,#} kb&quot;, pos/1024);  63:     var nativeOverlapped = new NativeOverlapped  64:     {  65:         OffsetHigh = 0,  66:         OffsetLow = (int) pos  67:     };  68:&#xA0;   69:     uint written;  70:     if (WriteFile(safeHandle, buffer, nNumberOfBytesToWrite, out written, &amp;nativeOverlapped) == false)  71:         throw new Win32Exception();  72:&#xA0;   73:     for (int j = 0; j &lt; 3; j&#x2B;&#x2B;)  74:     {  75:         if (*(ptr &#x2B; pos) != 137)  76:         {  77:             throw new Exception(&quot;WTF?!&quot;);  78:         }  79:         pos &#x2B;= 4096;  80:     }  81: }&#xA;This code is doing the following:&#xA;&#xA;We setup a file handle using NoBuffering | Write_Through, and we also map the file using memory map.&#xA;We write 3 pages (12Kb) at a time to the file.&#xA;After the write, we are using memory map to verify that we actually wrote what we wanted to the file.&#xA;_At the same time_ we are reading from the same memory in another thread.&#xA;Occasionally, we get an error where the data we just wrote to the file cannot be read back.&#xA;Now, here is what I think is actually happening:&#xA;&#xA;When we do an unbuffered write, Windows has to mark the relevant pages as invalid.&#xA;I _think_ that it does so before it actually perform the write.&#xA;If you have another thread that access that particular range of memory at the same time, it can load the _previously_ written data.&#xA;The WriteFile actually perform the write, but the pages that map to that portion of the file have already been marked as loaded.&#xA;At that point, when we use the memory mapped pointer to access the data, we get the data that was there before the write.&#xA;As I said, the code above can reproduce this issue (you might have to run it multiple times).&#xA;I am not sure if this is something that is valid issue or just me misusing the code. The docs are pretty clear about using regular i/o &amp; memory mapped i/o. The OS is responsible to keeping them coherent with respect to one another. However, that is certainly not the case here.&#xA;It might be that I am using a single handle for both, and Windows does less checking when that happens? For what it is worth, I have also tried it using different handles, and I don&#x2019;t see the problem in the code above, but I have a more complex scenario where I do see the same issue.&#xA;Of course, FILE_FLAG_OVERLAPPED is not specified, so what I would actually expect here is serialization of the I/O, according to the docs. But mostly I need a sanity check to tell me if I am crazy.</p>
        <a href="https://ayende.com/blog/164481/how-do-they-do-this" target="_blank"><h1 class="title mb-6">How do they DO this?</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 15, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">As mentioned, we are doing some more performance work in Voron. And we got some really surprising results there. Voron is writing at really good rate, (better than anything else we tested against), just not a good enough rate. To be fair, if we haven&#x2019;t seen the Esent benchmark with close to 750k writes / second, we might have been happy, but obviously it is possible to be much faster than we are now. So I decided to figure it out. To start with, I run Voron through a profiler, and verified that the actual cost there was purely in calling FlushFileBuffers (the Windows version to fsync). In fact, in our tests, about 75% of the time was spent just calling this function. The test in questions does 1 million inserts, using 10,000 transactions of 100 items each. But Esent can basically do so many it doesn&#x2019;t even count. So how do they do that? I&#x2019;m going to dedicate this post to discussing the process for finding it out, then spend the next one or two discussing the implications. At this level, we can&#x2019;t really use something like a profiler to figure out what is wrong, we need a more dedicated tool. And in this case, we are talking about Process Monitor. It gives you the ability to see what system calls are being made on your system. Here is what it looks like when we are committing a transaction with Voron:  And here is what it looks like when we are committing a transaction with Esent:  I was curious to test SQL Server too, and here is what it looks like when SQL Server is committing a transaction:  And if I&#x2019;m already doing this, here is SQL CE transaction commit:  No, this isn&#x2019;t a mistake. It didn&#x2019;t do anything. By default, SQL CE only flushes to memory. You have to force it to flush to disk my using tx.Commit(CommitMode.Immediate); If you do that, the transaction commits looks like this:      Not a mistake, you still get nothing. It appears that even with Immediate, it is only writing to disk when it feels like it. At a guess, it is using memory mapped files and doing FlushViewOfFile, instead of calling FlushFileBuffers, but I am not really sure. Since I run the benchmarks without immediate, I decided to try running the SQL CE stuff there again. Here are the numbers:  This brings to mind an interesting questions, what the hell is it doing that takes so long if it doesn&#x2019;t even flush to disk? Anyway, let us look at the SQLite version:  And&#x2026; I don&#x2019;t really know how to comment on that, to tell you the truth. I can&#x2019;t figure out what it is doing, and I probably don&#x2019;t really want to. Now, let us look at LMDB:  I am not really sure how to explain the amount of work done here. I think that work because it uses manual file I/O. When I use the WriteMap option, I get:  Which is more reasonable and expected. I would have shown leveldb as well, but I can&#x2019;t run it on Windows.  I think that this is enough for now. I&#x2019;ll discuss the implications of the difference in behavior in my next post. In the meantime, I would love to know what you think about this.</p>
        <a href="https://ayende.com/blog/164449/setting-the-baseline-for-performance-testing-for-voron" target="_blank"><h1 class="title mb-6">Setting the baseline for performance testing for Voron</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: November 14, 2013
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After finishing up the major change of moving Voron to a Write Ahead Journal, it was time to actually start doing some performance testing.  To make things interesting, I decided that we shouldn&#x2019;t just compare this in isolation, but we should actually compare it to its peers.  Those are early results, and we are going to have to do a lot more work to make sure that everything works faster.  We have run those tests on the following machine:   All the tests were run on a freshly formatted 512GB SSD drive. Note that we are currently showing only the fast runs, we also have a set of tests for much larger data sets (tens of GB) and another for performance over time, but we will deal with those separately. All of the current tests are for writing of 1 million items. Consisting of a 4 bytes integer and a 128 bytes value. We have tested: SQLite, SQL CE, LMDB, Esent and Voron.  For LMDB, because it needed a fixed file size, we set the initial file size to be 64 GB. All the databases were run using the default configuration options, no secondary indexes were used. All the tests were done using a single thread. Note that in all cases we used managed code to run the test. This may impact some of the results because some of those engines are native, and there might be some overhead there. The first test was to see how it performs with sequential writes:   Esent really shines in this, probably because this is pretty much the sweat spot for it. Voron is the second best, but the reason that we do those sorts of tests is to see where we have problems, and I think that we have a problem here, we are supposed to be much better here. In fact, we have earlier tests that show much better performance, so we appear to have a regression. We&#x2019;ll work on that next. Next, let us look at sequential reads:   Here, LMDB eclipses everyone else by far, this is its sweet spot. I am pretty happy about Voron&#x2019;s performance here, especially since it appears to be close to twice as fast as Esent is for this scenario. Next, we have random writes:   Surprisingly, Voron is doing pretty badly here, even though it is doing much better than LMDB (this is its weak spot) or SQLite.  For random reads, however, the situation is nicer to us:   So, we have our baseline. And I want to see how we can do better. Expect the future posts to focus on what exactly is slowing our writes down. In the meantime, we do have some really good news, we tested Voron with and without concurrent flushing to the data file, and there isn&#x2019;t any meaningful difference between the performance of the two options in our current test run.</p>
        <div class="button flex justify-between">
            <a href="277.html"><span class="back arrow"></span></a>

            <a href="279.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
</body>
</html>