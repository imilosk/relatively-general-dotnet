
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 278 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-2771">
            <a href="https://ayende.com/blog/176866/scaffolding-code-as-sign-of-maturity" target="_blank">
                <h2 class="title mb-6" id="article-2771">Scaffolding code as sign of maturity</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 31, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">One of the clearest signs of maturity that I&#x2019;m looking for when reading code is the scaffolding that were used. Just like in physical construction, it is often impossible to start by building everything properly from the get go, and you start by building temporary scaffolding to get you going. In some cases, those can be things that you need to actually build the software, but I have found that scaffolding are mostly useful in debugging and understanding issues. For example, if I&#x2019;m working on a complex data structure, it would be very useful to be able to dump it into a human readable format, so I can visually inspect it and understand how it works. In the recent low level trie example, I have a file dedicated to doing just that, it contains some code to print the trie as well as validate the structure, and it was very useful to figure out certain things.  If the project is big enough, and mature enough, those scaffolding take on a permanent nature. In RavenDB, for example, they are debug endpoint and live visualizations that can help an administrator to figure out exactly what is going on with the system. The more complex the system, the more important the scaffolding become.  One very important consideration is what kind of scaffolding is being built. For example, if you throw a bunch pf printf all over the place while you are debugging, that is helpful, but that isn&#x2019;t something that will remain over time, and in many cases, the second or third time that you find yourself having to add code to help you narrow down a problem, you want to make this sort of code a permeant part of your codebase. One of the more complex pieces in building Voron was the B&#x2B;Tree behavior, in particular when dealing with page splits and variable size data. We build a lot of code that would verify that structure and invariants for us, and it is running as part of our CI builds to ensure that stuff doesn&#x2019;t sneak in. One of the things that we teach our new hires is that one of the things that we need to have not just working code, but also all of the surrounding infrastructure. Everything that I need to work with, diagnose and manage the system in production over long periods of time. I distinctly remember a debugging session where we had to add a whole bunch of diagnostics code to figure out some really gnarly issue. I was pairing with another dev on that on his machine, and we were working on that for a long time. We finally managed to figure out what the problem was and fix that, and I left and got the final PR with the fix later in the day. None of the diagnostics code was in it, and when I asked why the answer was: &#x201C;We fixed the problem, and we didn&#x2019;t need it, so I removed it.&#x201D;  That is not the kind of thing that you remove, that is the kind of thing that you keep, because you can bet your bottom dollar that we&#x2019;ll need it again, when the next problem shows up.</p>
        </article>
        <article id="article-2772">
            <a href="https://andrewlock.net/logging-using-diagnosticsource-in-asp-net-core/" target="_blank">
                <h2 class="title mb-6" id="article-2772">Logging using DiagnosticSource in ASP.NET Core</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 31, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Although ILogger is the most common, there are actually three logging system in ASP.NET Core. In this post I show how to use the DiagnosticSource system&#x2026;</p>
        </article>
        <article id="article-2773">
            <a href="https://www.meziantou.net/improve-the-log-in-experience-with-the-credential-management-api.htm" target="_blank">
                <h2 class="title mb-6" id="article-2773">Improve the login experience with the Credential Management API</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 31, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Many websites require users to log in to access their resources. From a user point of view, the login process can be complicated, and this is more true when you can log in using a login/password or using a social provider (Microsoft, Google, Facebook, etc.). For instance, some users enter their Goo</p>
        </article>
        <article id="article-2774">
            <a href="https://ayende.com/blog/176867/the-crash-at-the-unicode-text" target="_blank">
                <h2 class="title mb-6" id="article-2774">The crash at the Unicode text</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 30, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">So a customer of ours has been putting RavenDB 4.0 through it paces, they have a large database with some pretty nasty indexes. They reported that when importing their existing data, they managed to crash RavenDB. The problem was probably some interaction of indexing and documents, but this was pretty consistent. That was lucky, because I was able to narrow down the problem to the following document.  Literally just a week before getting this bug report we found a bug with multi byte Unicode characters (we were counting them in chars, but using that to index into a byte array), so that was our very first suspicion. In fact, review the relevant portions of the code, we were able to identify another location with a similar problem, and resolve it.  That didn&#x2019;t solve the problem, however. I kept banging my head against the Unicode issue, until I finally just gave up and went to tracing the code very carefully. And then I found it. The underlying issue was that the data here is part of an array inside a document, and we had an index that looked like this:  The idea is that we gather all the titles from the items in the action, and allow to search on those. And somehow, the title from the second entry above was always pointing to invalid memory. It took a bunch more investigation before I found out the root cause.  Here is where we found the problem:  But it is going to take a bit of explaining first. The second title is pretty long, when using UTF8 it is 176 bytes, which is long enough for the blittable format to try to compress it, and it was indeed successfully compressed to a smaller size.  So far, so good, and a pretty awesome feature that we have. But the problem was that when we index a document, we need to access its property, and if it is a compress property, we need to decompress it, and that means that we need to decompress it somewhere. And at the time, using the native temp buffer seemed perfect, after all, it was exactly the kind of thing that it was meant for. But in this case, a bit further down the document we had another compressed field, one that was even larger, so we again asked for a temp buffer. But since this is a temp buffer, and the expectation is that this will be short lived usage, we returned the old buffer and allocated a new one. However, we still maintained reference to the old buffer, and when we tried to index that title, it spat out garbage (because the memory was reused) or just crashed, depending on how severe we set the memory protection mechanism. It was actually something that we already figured out and fixed, but we haven&#x2019;t yet merged that branch, so it was quite annoying when we found the root cause. We&#x2019;ll also be removed the temp buffer concept entirely, we&#x2019;ll have a buffer that you can checkout and return, and not something that can vanish behind you back. But I have to say, that bug was certainly misleading in the extreme. I was sure it had to do with Unicode handling.</p>
        </article>
        <article id="article-2775">
            <a href="https://www.stevejgordon.co.uk/things-ive-learnt-week-29th-january" target="_blank">
                <h2 class="title mb-6" id="article-2775">Things I&#x2019;ve Learnt This Week (29th January)</h2>
            </a>
            <p class="mb-2">by Steve Gordon</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 29, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Whether this will become a regular thing, I&#x2019;m not sure. But starting this week I&#x2019;ve been keeping notes on the things I&#x2019;ve learned, problems I&#x2019;ve faced and resources that I&#x2019;ve read, watched or listened to. I try to consume as much information as possible about ASP.NET and development in a continual drive to learn more [&#x2026;]</p>
        </article>
        <article id="article-2776">
            <a href="https://ayende.com/blog/176865/the-low-level-trie-rust-challenge" target="_blank">
                <h2 class="title mb-6" id="article-2776">The low level trie Rust challenge</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 27, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I have tried to build a low level trie impl in Rust and just gave up because it was too much work making the compiler happy. I then went ahead and wrote in in C&#x2B;&#x2B; in a couple of evenings. I would still like to know whatever this is possible / viable in Rust. I&#x2019;m assuming that this is the case, but I don&#x2019;t know how to start. Any dear reader feels like taking this upon themselves to port the C&#x2B;&#x2B; code to Rust? It is all working and there are unit tests, and I think that the design should match well the Rust design philosophy, but the borrow checker actively worked to me give up doing that in Rust, and I would like to both see this implemented in Rust and hear what the experience was like.</p>
        </article>
        <article id="article-2777">
            <a href="https://ayende.com/blog/176897/nhibernate-profiler-entity-framework-profiler-4-0-beta-release" target="_blank">
                <h2 class="title mb-6" id="article-2777">NHibernate Profiler &amp; Entity Framework Profiler 4.0&#x2013;Beta Release</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 26, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x2019;m happy to announce that the next version of the NHibernate and Entity Framework Profilers is ready for beta testing You can download the new bits from here.  Entity Framework &#x2013; Support for EF Core (on .NET Core and .Net 4.6)  NHibernate Profiler &#x2013; Support for NHibernate 4.1  Persisting interesting sessions across restarts.  Improved filtering of SQL statements and behaviors, persisting your configuration across restarts and generally behaving as a responsible citizen.  The ability to configure profiling via a watched file, to enable admins to enable/disable profiling on the fly.  Allowing you to edit and run a SQL statement as well as compare the database query plan generated so you can get to an optimal solution.  Various usability improvements (auto tracking of interesting data, always on top, compact mode for quick visualizations, better keyboard navigation, etc).    Please take them for a spin and provide us with feedback on it.</p>
        </article>
        <article id="article-2778">
            <a href="https://ayende.com/blog/176834/implementing-low-level-trie-digging-into-the-c-impl" target="_blank">
                <h2 class="title mb-6" id="article-2778">Implementing low level trie</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 26, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The low level trie challenge is storing a trie structure inside a 32KB buffer, and allowing read, write and delete operations on it. The idea is that you can have no additional data about the trie other than the buffer. The full implementation is available on github.  Because of that, you need to think very differently about how you approach the solution. Here is the header file with the main trie operations: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          class trie {&#xA;        &#xA;        &#xA;          &#xA;          public:&#xA;        &#xA;        &#xA;          &#xA;          &#x9;static const int BUFFER_SIZE = 32 * 1024;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;enum result {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;success,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;not_enough_space,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;key_too_large,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;defrag_required,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;max_number_of_items_stored&#xA;        &#xA;        &#xA;          &#xA;          &#x9;};&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie();&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;          &#x9;void defrag();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;bool remove(const std::string&amp; key);&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;          private:&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char _buffer[BUFFER_SIZE];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          trie.h&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; You&#x2019;ll note that the only field that I have on the class is a 32KB buffer. All the data is stored inside it. In order to handle that, we are going to treat this buffer as our main memory and &#x201C;allocate&#x201D; our data inside it. I guess we could do this by using C&#x2B;&#x2B; allocators, but that seem to be very heavy weight and I don&#x2019;t think it will work very well for this scenario. Instead, we define the following basic structures: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          struct trie_header_info&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short next_alloc;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short used_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short items_count;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short reserved;&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          struct node_header_info&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short key_offset;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short key_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short children_offset;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;short value_offset;&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          data-structures.h&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; The trie header is located at the very beginning of the buffer, and contains the basic information about the trie. And then we have each node entry, which is about a specific entry. In particular, the offset fields in the node_header_info are actually pointers into the buffer itself. And the next_alloc field in the trie_header_info is used to &#x201C;allocate&#x201D; additional memory inside the buffer. The idea is that whenever we need more memory, we just take it from the top of the buffer, until we run out of room. Here is how I add the very first entry: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          if (trie_header-&gt;items_count == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie_header-&gt;items_count = 1;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto offset = trie_header-&gt;next_alloc = sizeof(trie_header_info); // ensures that the first node is always in the beginning&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto node_header = (node_header_info*)(_buffer &#x2B; offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie_header-&gt;next_alloc &#x2B;= (short)required_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie_header-&gt;used_size &#x2B;= (short)required_size;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;node_header-&gt;children_offset = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;node_header-&gt;key_offset = offset &#x2B; sizeof(node_header_info);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;node_header-&gt;key_size = (short)(key.length() - position_in_key);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;node_header-&gt;value_offset = node_header-&gt;key_offset &#x2B; node_header-&gt;key_size;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto bound_checked_buffer = stdext::make_checked_array_iterator(&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;base &#x2B; node_header-&gt;key_offset,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;trie::BUFFER_SIZE - node_header-&gt;key_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;std::copy(key.begin() &#x2B; position_in_key, key.end(), bound_checked_buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;*(long*)(base &#x2B; node_header-&gt;key_offset &#x2B; node_header-&gt;key_size) = val;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            &#x9;return trie::result::success;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          write-first-entry.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; I&#x2019;m forcing it into a specific well known place in the buffer (line 4), and then I handle all rest of the memory assignments from there. The same holds true when we start getting into the nested structure. Each entry has a array of offsets that points to its children, which is pointed to by the children_offset value.  When we need to add a new child to a node, we aren&#x2019;t modifying the old array, instead, we are allocating a completely new one, adding the new value and sorting the whole thing. &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          auto children_offsets = ((short*)(base &#x2B; parent-&gt;children_offset &#x2B; sizeof(char)));&#xA;        &#xA;        &#xA;          &#xA;          children_offsets[0] = parent-&gt;children_offset&#xA;        &#xA;        &#xA;          &#xA;            &#x2B; sizeof(char) // length&#xA;        &#xA;        &#xA;          &#xA;            &#x2B; sizeof(short) * (old_number_of_children &#x2B; 1);// offset of 1st child&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          *(char*)(base &#x2B; parent-&gt;children_offset) = 1 &#x2B; old_number_of_children;&#xA;        &#xA;        &#xA;          &#xA;          std::memcpy(&#xA;        &#xA;        &#xA;          &#xA;            (char*)children_offsets &#x2B; sizeof(short), // skip the first value that we just entered&#xA;        &#xA;        &#xA;          &#xA;            (base &#x2B; old_children_offset &#x2B; sizeof(char)),&#xA;        &#xA;        &#xA;          &#xA;            sizeof(short) * old_number_of_children);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // now sort the children by the first char &#xA;        &#xA;        &#xA;          &#xA;          std::sort(children_offsets, children_offsets &#x2B; old_number_of_children &#x2B; 1,&#xA;        &#xA;        &#xA;          &#xA;            [base](short x_offset, short y_offset) {&#xA;        &#xA;        &#xA;          &#xA;            auto x_node = (node_header_info*)(base &#x2B; x_offset);&#xA;        &#xA;        &#xA;          &#xA;            auto y_node = (node_header_info*)(base &#x2B; y_offset);&#xA;        &#xA;        &#xA;          &#xA;            auto x_ch = *(base &#x2B; x_node-&gt;key_offset);&#xA;        &#xA;        &#xA;          &#xA;            auto y_ch = *(base &#x2B; y_node-&gt;key_offset);&#xA;        &#xA;        &#xA;          &#xA;            return x_ch &gt; y_ch;&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          handling-children.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; The sorting thing is actually fun, because it means that when I&#x2019;m reading from the trie, I can reduce the amount of work that I have to do per level.  Here is how I read from the trie: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          std::pair&lt;bool, long&gt; trie::try_read(const std::string&amp; key) {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto trie_header = (trie_header_info*)_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (trie_header-&gt;items_count == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return std::make_pair(false, 0);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int position_in_key = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto match = find_match(_buffer, (node_header_info*)(_buffer &#x2B; sizeof(trie_header_info)), key, position_in_key);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (match.success == false || match.current-&gt;value_offset == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return std::make_pair(false, 0);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto val = *(long*)(_buffer &#x2B; match.current-&gt;value_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return std::make_pair(true, val);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          MatchResult find_match(char* base, node_header_info* current, const std::string&amp; key, int&amp; position_in_key) {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto reamining_match = (key.length() - position_in_key);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (reamining_match == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return MatchResult{ true, current, current-&gt;key_size };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if ((size_t)current-&gt;key_size &gt; reamining_match) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return get_failed_result(base, current, key, position_in_key);// current key is larger than remaining key&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (std::memcmp(base &#x2B; current-&gt;key_offset, key.c_str() &#x2B; position_in_key, current-&gt;key_size) != 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return get_failed_result(base, current, key, position_in_key);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;position_in_key &#x2B;= current-&gt;key_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (position_in_key == key.length()) { // found match&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return MatchResult{ true, current, current-&gt;key_size };&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (current-&gt;children_offset == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return MatchResult{ false, current, current-&gt;key_size }; // no children, can go forward&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto num_of_children = *(char*)(base &#x2B; current-&gt;children_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto children_offsets = (short*)(base &#x2B; current-&gt;children_offset &#x2B; sizeof(char));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto child = find_child(base, key[position_in_key], children_offsets, num_of_children);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (child != nullptr)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return find_match(base, child, key, position_in_key);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return MatchResult{ false, current, current-&gt;key_size }; // no matching children, can&#x27;t go forward&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          node_header_info* find_child(char* base, char first_char, short* children_offsets, short number_of_children) {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto match = std::lower_bound(children_offsets, children_offsets &#x2B; number_of_children, 0,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;[base, first_char](const short x_offset, const short _) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;auto node = (node_header_info*)(base &#x2B; x_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;auto node_first_char = *(base &#x2B; node-&gt;key_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return node_first_char &gt; first_char;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;});&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto node = (node_header_info*)(base &#x2B; *match);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto node_first_char = *(base &#x2B; node-&gt;key_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (node_first_char == first_char)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return node;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return nullptr;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          reading-from-trie.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; We first try to find a match in the trie, starting from the root node. The find_match method is then called to find if the current node is a match, and if not, whatever we can go further. It does so by comparing the key to the stored value, and if there is a partial match,recursing into the next level. A fun part happens inside the find_child method, where we do a sorted search over the children array to find the node with the matching starting byte.  The whole idea is that because I&#x2019;m using constrained memory, I can make do with very little actual work to manage the memory, I&#x2019;m just using and discarding it all the time. But I am keeping track of when I can next allocate the memory, and how much of the buffer is in use. When I hit the memory limit, I&#x2019;m going to defrag the trie. This is like so: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void trie::defrag() {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;std::string s(BUFFER_SIZE, 0);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto temp_buffer = &amp;(s[0]);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;std::memcpy(temp_buffer, _buffer, BUFFER_SIZE);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;std::memset(_buffer, 0, BUFFER_SIZE);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto temp_trie_header = (trie_header_info*)temp_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;auto trie_header = (trie_header_info*)_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie_header-&gt;items_count = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie_header-&gt;next_alloc = sizeof(trie_header_info);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;trie_header-&gt;used_size = sizeof(trie_header_info);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (temp_trie_header-&gt;items_count == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return; // nothing else to do&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;std::stack&lt;std::pair&lt;node_header_info*, short*&gt;&gt; nodes;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;nodes.push(std::make_pair((node_header_info*)(temp_buffer &#x2B; sizeof(trie_header_info)), (short*)nullptr));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;node_header_info* current;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (nodes.size() &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;short* write_position;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;std::tie(current, write_position) = nodes.top();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;nodes.pop();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;auto required_size = current-&gt;key_size &#x2B; sizeof(long) &#x2B; sizeof(node_header_info);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (current-&gt;children_offset != 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;required_size &#x2B;= sizeof(char) &#x2B; (*(temp_buffer &#x2B; current-&gt;children_offset) * sizeof(short));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (write_position != nullptr)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;*write_position = trie_header-&gt;next_alloc;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;auto defraged = (node_header_info*)(_buffer &#x2B; trie_header-&gt;next_alloc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;defraged-&gt;key_offset = trie_header-&gt;next_alloc &#x2B; sizeof(node_header_info);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;defraged-&gt;key_size = current-&gt;key_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;std::memcpy(_buffer &#x2B; trie_header-&gt;next_alloc &#x2B; sizeof(node_header_info), temp_buffer &#x2B; current-&gt;key_offset, current-&gt;key_size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (current-&gt;value_offset == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;defraged-&gt;value_offset = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;else {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;defraged-&gt;value_offset = defraged-&gt;key_offset &#x2B; defraged-&gt;key_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;std::memcpy(_buffer &#x2B; defraged-&gt;value_offset, temp_buffer &#x2B; current-&gt;value_offset, sizeof(long));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;trie_header-&gt;items_count&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (current-&gt;children_offset == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;defraged-&gt;children_offset = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;} &#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;else {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;defraged-&gt;children_offset = defraged-&gt;key_offset &#x2B; defraged-&gt;key_size &#x2B; sizeof(long);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;auto number_of_children_p = (_buffer &#x2B; defraged-&gt;children_offset);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;auto children_offsets = (short*)(temp_buffer &#x2B; current-&gt;children_offset &#x2B; 1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;auto defraged_children = (short*)(_buffer &#x2B; defraged-&gt;children_offset &#x2B; 1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;for (char i = 0; i &lt; *(temp_buffer &#x2B; current-&gt;children_offset); i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;if (children_offsets[i] == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;auto child = (node_header_info*)(temp_buffer &#x2B; children_offsets[i]);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;nodes.push(std::make_pair(child, &amp;defraged_children[*number_of_children_p]));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;(*number_of_children_p)&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;trie_header-&gt;next_alloc &#x2B;= required_size;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;trie_header-&gt;used_size &#x2B;= required_size;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          #if DEBUG&#xA;        &#xA;        &#xA;          &#xA;          &#x9;validate();&#xA;        &#xA;        &#xA;          &#xA;          #endif&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          defrag.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; There is quite a lot going on in there, but the basic idea is that we are going to copy the buffer to a temporary buffer, reset our own buffer (this all happens in the first 4 lines), and then we are going to traverse the data in the temp buffer and insert it into the real buffer directly. One of the things that is most important here is that we properly calculate the size of the children array for each node. I could have probably have done more here:  Ensure that the data is aligned Merge nodes that have only a single child and no value of their own And probably a lot of other stuff, but this has been a fun experiment.</p>
        </article>
        <article id="article-2779">
            <a href="https://ayende.com/blog/176833/implementing-low-level-trie-solving-with-c" target="_blank">
                <h2 class="title mb-6" id="article-2779">Implementing low level trie</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 25, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The low level trie question has been a favorite question of mine for a while. It is simple in concept, but the limitations placed on it make it pretty hard to actually build. Previous posts in this series outlined the approach I had for solving this, but I always got caught up with something and didn&#x2019;t get around to actually sitting down and resolving this completely. As part of learning Rust, I decided to go ahead and implement this low level trie using Rust. I have failed, it was just too much babysitting by the compiler and having to fight it. I knew exactly what I wanted to do, but I kept having to jump through hops to get it to it. Eventually, I just called it quits&#xA0; and decided to abandon the attempt to use Rust.  But I still want to do something out of my comfort zone, so I decided to run this exercise using C&#x2B;&#x2B;. Now, I used to write quite a lot of C&#x2B;&#x2B; (along with VB, VBScript and ASP classic). But that was in the late 90s, and very early 2000s. I heard through the grapevine that someone kicked the C&#x2B;&#x2B; standard committee into high gear and started actually improve the language.  The result was three evenings spent on building a low level trie impl in C&#x2B;&#x2B;, and quite a lot of fun. I&#x2019;ll have another post about the actual details of the implementation, but in this post I mostly wanted to talk about the experience of getting back to C&#x2B;&#x2B;. And it is&#x2026; strange. On the one hand, because I&#x2019;m so used to C# and have used C&#x2B;&#x2B; before, this is oh so comfortable. Like wearing old set of gloves that you forgot that you even had.  On the other hand, I forgotten quite a lot of details about the language and the libraries, and they changed. My old C&#x2B;&#x2B; code would be newing up stuff and fighting to manage memory and very likely leaking like crazy. In this codebase? I don&#x2019;t have a single new call throughout. And being able to do things like lambdas in C&#x2B;&#x2B; feels like magic.  I&#x2019;ll admit that the codebase is heavily influenced by my Rust work. To start with, I&#x2019;m using snake_case convention, and I found that I&#x2019;m using a lot more std::pair that I would expect myself to use.  I would appreciate any code review on this, the core code is about 400 lines or so, and I&#x2019;m mostly interested to know whatever I managed to write idiomatic modern C&#x2B;&#x2B;, and if not, how this can be improved.</p>
        </article>
        <article id="article-2780">
            <a href="https://ardalis.com/bus-or-queue/" target="_blank">
                <h2 class="title mb-6" id="article-2780">Bus or Queue</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 25, 2017
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">A common question I encounter is, &#x201C;what is the difference between a message bus (or service bus) and a message queue?&#x201D; There has been some&#x2026;Keep Reading &#x2192;</p>
        </article>
        <div class="button flex justify-between">
            <a href="277.html"><span class="back arrow"></span></a>

            <a href="279.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>