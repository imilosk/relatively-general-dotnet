
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 832 &#x2022; Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="/pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">
<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline underline"
               href="index.html"> Home </a><a
                aria-current="" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline " href="about.html">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>


<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-8311">
            <a href="https://ayende.com/blog/2099/java-com-wtf" target="_blank">
                <h2 class="title mb-6" id="article-8311">Java.com WTF</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 11, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I found this very amusing:</p>
        </article>
        <article id="article-8312">
            <a href="https://ayende.com/blog/2098/required-position-at-microsoft-the-yagni-guy" target="_blank">
                <h2 class="title mb-6" id="article-8312">Required position at Microsoft: The YAGNI Guy</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 11, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Again from Hammett:Microsoft should hire an YAGNI guy per product. That would be translated into more frequent releases and smaller and practical tools. I dare to say that stock holders will also appreciated it.</p>
        </article>
        <article id="article-8313">
            <a href="https://ayende.com/blog/2097/complex-edm" target="_blank">
                <h2 class="title mb-6" id="article-8313">Complex EDM</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 11, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Hammett&#xA0;posted &quot;Is EDM the unlearned EJB lesson?&quot;, he is not impressed with the amount of complexity that is required. I reviewed EDM a while ago, and came back unimpressed, I guess that I&#x27;ll have to look again to see what they did in the meantime.    Here are some interesting quotes from Hammett&#x27;s post.They have also tried to achieve what seems to be unique features on their Entity framework, which is the ability to compose an entity as a logical view of n tables.    This is something that Hibernate (but not yet NHibernate) actually supports, using the &lt;join table=&quot;employees&quot;/&gt;&#xA0;syntax. You can get some of the details here. I remembered seeing something about that in the Hibernate documentation, and indeed, I found this:We consider it an essential element of good object model design that the object model be at least as granular as the relational model. If the original data modeller decided that certain columns should be split across two different tables, then there must have been some kind of conceptual justification for that. There is no reason not to also make that distinction in the object model.    I can certainly agree with the sentiment above.     The only cases when I wanted to do something like this was when there was something really bad in the data model in the first place. I should mention that this is also extremely easy to build using the Delegate pattern at any rate. Scratch that one as an important feature.If you have to rely on tools to use a technology which otherwise you just couldn&#x2019;t do it, maybe there&#x2019;s something wrong with it!    Oh, yeah! With that we are fully in agreement.&#xA0;I am so pleased that Microsoft released the .Net 3.0 without releasing all the tools for it. It means that the technology had to be usable with the crutches of the tools.</p>
        </article>
        <article id="article-8314">
            <a href="https://ayende.com/blog/2096/on-the-framework-design-principles-from-raymond-lewallen" target="_blank">
                <h2 class="title mb-6" id="article-8314">On the Framework Design Principles from Raymond Lewallen</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 10, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Raymond Lewallen&#xA0;posted his presentation from Framework Design Principles. I mostly agree with what he has to says, except that on slide #5 he has this:Don&#x2019;t supply virtual members if you don&#x2019;t have to.    &#xA0;- Can cause problems by users of your framework who don&#x2019;t understand it.    &#xA0;- Virtual members cannot be inlined.    What?!    The first issue is very simple, if a programmer do not understand what a virtual method is, he has no business touching. This is such a basic gap that you just can&#x27;t fill with trying to protect the user. Check the Daily WTF story&#xA0;about such a programmer.    The second issue is a more serious matter, and is actually the reason that in .Net 2.0 List&lt;T&gt; has no virtual memebers. My personal opinion in this matter is probably already known, this is the wrong design desicion to make. Especially since so much of .Net 2.0 (controls, data binding) assumes that you are working with List&lt;T&gt; and not with the interface.    The JIT is capable of inline interface methods, as a matter of fact, so if you think that you class will see as much perf critical code paths as List&lt;T&gt;, make the methods non virtual and always use the interface. One of the big things about OO is that you can use polymorphism to cleanly modify the actions of the system. You should always leave a way for a programmer to come in and change what the system does.    A simple example: I want to use WithEventsList&lt;T&gt;, which will raise Added, Removed, Cleared events at the appropriate times. Not a hard thing to do, except that I can&#x27;t use List&lt;T&gt; as a base class, all those methods are non virtual, I have no way to extend the functionality of the class.    Speaking about interfaces, this is what Raymond had to say about them;- Interfaces define symantics, not contracts.    - Use abstract classes, not interfaces, to decouple contract from implementation.    I am pretty sure that I don&#x27;t&#xA0;agree with the above, but I am not sure what the meaning is, Raymond, can you clarify?</p>
        </article>
        <article id="article-8315">
            <a href="https://ayende.com/blog/2095/wcf-mocking-and-ioc-oh-my" target="_blank">
                <h2 class="title mb-6" id="article-8315">WCF, Mocking and IoC: Oh MY!</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 10, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Introduction:I started writing a little post about what I want to do with WCF, and I ended both doing it and documenting it. It will probably be interesting to a small group of people.Please note that a rudimetry understanding of WCF, IoC and Mocking would probably be helpful, although I made the best to explain most concepts. At times I took some shortcuts by using advance features of all three frameworks, those are usually very well documented, but I am always open for questions.You can find the sample code here    I need to consume a service provided by a third party, and I would really not like to do production debugging on it. So I will use unit tests to provide me with an assurance that I am handling all the assumption correctly. Like I said, this service is provided by a 3rd party, so I don&#x27;t care how it is implemented. I do care how easy it is for me to cunsume and use this service, and I like to learn new stuff every now and then, so I decided to use WCF to do this interaction.    Here is the service documentation:Orders Service - Submit Order:This operation will take an order message and submit it for processing. Once the order has been successfully submitted, it is the responsability of the service to ensure that it won&#x27;t be dropped. Clients that use this operation can assume that an order is never lost.However, if an error occurs during the submittion process, the order is not submitted, and a client must take whatever steps neccesary to recover from that (show an error to the user, log and retry at a later time, etc).    I have a set of tools that I like to work with, and I don&#x27;t see a reason why using WCF would change that, therefor, I am probably going to have to do some work to integrate WCF into the set of tools that I can use. Let us start by defining the entities we are going to work with:        For simplicity sake, I am going to ignore a lot of other interesting properties (shipping address, billing, etc). My recommended way of operation is Test First, so let us try writing the test code for the OrderController:            [TestFixture]                                public class OrderControllerFixture                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [Test]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void CanCreateController()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; IOrderService orderService = null;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController controller = new OrderController(orderService);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        I don&#x27;t have anything else, but I think that I would need an order service and an order controller. The distinction is important. The IOrderService is concerned mainly with the &quot;how&quot; - in this case, submitting an order for processing. The OrderController is concerned mainly with the &quot;why&quot;, it takes a request (usually from a user) and turn it into an action with a business meaning.    In this case, I specify that OrderController takes a IOrderService in its constructor. I won&#x27;t bore you with the details of how I build a class and constructor.&#xA0;&#xA0;Now, I can test write the next test:            [Test]                                public void WillSubmitOrderToService()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; MockRepository mocks = new MockRepository();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; IOrderService orderService = mocks.CreateMock&lt;IOrderService&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController controller = new OrderController(orderService);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; controller.SubmitOrder(orderId);                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.VerifyAll();                                }        Couple of things to note here, I am creating a mock of IOrderService, and then I setup an expectation that its SubmitOrder will be called (and I don&#x27;t care about the arguments). I then create the controller with the mocked order service, and submit an order.    I had to think for a couple of minutes when I wrote the test, what should the controller&#x27;s SubmitOrder take? I am going to use this over the web, and probably this will be used as the last stage of a wizard. This indicate to me that an integer (primary key) is a good idea, since it is something that can easily be passed from the request/view. This also means that I need some sort of persistent storage, likely a database. For simplicity sake, I am going to hand-wave this, assume that I am using Active Record and that I have already set the data up correctly.    The next decision is what should the order service SubmitOrder should accept. My business requirements are such that it should accept the entire Order object (and all its assoicated objects, such as order lines, products, etc), because the service would also need to print a reciept of the order as well as bill it.    Running the test now will fail, because the SubmitOrder on the controller it empty, I added an simple implementation that made it work:             [Transient]        public     class OrderController    {    &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void SubmitOrder(int orderId)    &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                    &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        The job of the next test is to assert that we send a valid order:            [Test]                                public void WillSubmitOrderWithSameIdAsTheOnePassedToController()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; MockRepository mocks = new MockRepository();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; IOrderService orderService = mocks.CreateMock&lt;IOrderService&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.Constraints(Is.NotNull() &amp;&amp; Property.Value(&quot;Id&quot;, 5));                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController controller = new OrderController(orderService);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; controller.SubmitOrder(orderId);                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.VerifyAll();                                }        The only thing that I changed was the expectation, now I am not satisfied with merely a call to the service&#x27;s SubmitOrder method, but I also assert that it is not null and that the Id property equals to 5. Running this test lead to the following error:TestCase &#x27;OrderControllerFixture.WillSubmitOrderWithSameIdAsTheOnePassedToController&#x27;    failed: IOrderService.SubmitOrder(null); Expected #0, Actual #1.    IOrderService.SubmitOrder(not equal to null and property &#x27;Id&#x27; equal to 5); Expected #1, Actual #0.    You can bet that I am proud of Rhino Mocks for the above message :-) At any rate, let us change the SubmitOrder implementation so the test will pass:             [Transient]        public     class OrderController    {                    &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void SubmitOrder(int orderId)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Order o = GetOrderById(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(o);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private static Order GetOrderById(int orderId)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Order o = new Order();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; o.Id = orderId;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return o;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        (Remember: I&#xA0;do not really care about the persistance of orders right now. This is simple and works). The tests works, but I see duplication in the tests that I can remove. The new test fixture looks like this:            [TestFixture]                                public class OrderControllerFixture                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; IOrderService orderService;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; MockRepository mocks;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private OrderController controller;                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [SetUp]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void TestInitialize()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks = new MockRepository();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService = mocks.CreateMock&lt;IOrderService&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; controller = new OrderController(orderService);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [TearDown]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void TestCleanup()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.VerifyAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [Test]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void WillSubmitOrderToService()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; controller.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [Test]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void WillSubmitOrderWithSameIdAsTheOnePassedToController()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.Constraints(Is.NotNull() &amp;&amp; Property.Value(&quot;Id&quot;, 5));                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; controller.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        I removed the CanCreateOrderController, since I have moved it to the setup method anyway. Now, we need to have some way to notify the user, so we create a new test:            [Test]                                public void WillReturnTrueIfOrderSubmittedSuccessfully()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = controller.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsTrue(result, &quot;Should return true is send was successful&quot;);                                }        To make this test pass, I modified the SubmitOrder method to return a boolean and added a &quot;return true&quot; statement at the end of the method. Note that I do not care what I pass to the service&#x27;s SubmitOrder() here, so I changed the expectation to a less restrictive one, in general, it is a best practice not to specify things that you aren&#x27;t testing explicitly, otherwise, your tests may be extremely fragile.    Now that I got a passing test for a successful submittion, let us try to see what the failure mode that we have are. As far as I am concerned, there are two failure modes that I can identify at the moment, infrastructure failures (the service is down) or business failures (the submitted order is not valid, for instnace, not enough credit to pay it remained).    Now, let us think about the way WCF work, we have this seperation there as well, we have CommunicationException and FaultException, with the same overall meaning. I am going to make several assumptions now:            Asserting that the configuration is correct is not the job of the OrderController, therefor, it assumes that the service it was configure to use is valid.            A communication error is trasient in nature and should be retried if they failed, up to a pre-defined limit.            A business errors cannot be recovered by a retry.    With those assumptions in mind, I can write the following test:            [Test]                                public void WillReturnFalseIfOrderSubmittedRaisedFaultException()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments()                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Throw(new FaultException(&quot;Just Because I felt like it&quot;));                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = controller.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsFalse(result, &quot;Should return true is send failed beause of a fault exeption&quot;);                                }        This obviously fails, because the controller does not catch any exceptions. A simple implementation that fix it is:            public bool SubmitOrder(int orderId)                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Order o = GetOrderById(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; try                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(o);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; catch                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return false;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return true;                                }        When I see code like this I usually wince, so we need a new test that will help me fix it, the easiest test that I can think about which would move us in the right direction is retries on communication failures:            [Test]                                public void WillRetryThreeTimesIfCommunicationExceptionIsRaisedAndThenReturnFalse()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;orderService.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments()                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Throw(new CommunicationException(&quot;Just Because I felt like it&quot;))                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Repeat.Times(3);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; mocks.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = controller.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsFalse(result, &quot;Should return true is send failed beause of a communication exeption for three times&quot;);                                }        Running this test produce this error:TestCase &#x27;OrderControllerFixture.TestInitialize.WillRetryThreeTimesIfCommunicationExceptionIsRaisedAndThenReturnFalse.TestCleanup&#x27;    failed: IOrderService.SubmitOrder(any); Expected #3, Actual #1.    Looks like I need to call SubmitOrder three times to make this test pass. I whipped up the following code:            public bool SubmitOrder(int orderId)                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Order o = GetOrderById(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int retries = 3;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; while (retries != 0)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; try                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(o);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; break;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; catch (CommunicationException e)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; retries -= 1;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if(retries==0)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return false;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; catch                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return false;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return true;                                }        This is really ugly code, but let us try the tests first before we refactor. Hm, looks like this test pass, but the previous one (WillReturnFalseIfOrderSubmittedRaisedFaultException) now breaks. For some reason it is looks like the CommunicationException clause is catching the FaultException. Taking a look at the hierarchy, it looks like FaultException inherits from CommunicationException. This looks better:            public bool SubmitOrder(int orderId)                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Order o = GetOrderById(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int retries = 3;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; while (retries != 0)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; retries -= 1;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; try                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderService.SubmitOrder(o);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; break;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; catch(FaultException)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return false;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; catch (CommunicationException)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if(retries==0)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return false;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return true;                                }        It also passes all the test. I am still not really happy with the code above, I think that it is too complex, but at the moment I can&#x27;t think of a good way to improve it in a way that would improve readabily. (For simplicity sake, I am explicitly ignoring user error message and logging).    Now, if it was a normal blog post about TDD, I would have declared at this point that TDD can bring peace to the middle east and go fishing toads from the pool, but I need to integrate that with WCF and my normal method of working, so this is harder.    The first problem is that I need to expose IOrderService and Order/OrderLine/Product to WCF:            [ServiceContract(Namespace = &quot;http://www.ayende.com/WCF/TestDriven/&quot;)]                                public interface IOrderService                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [OperationContract]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; void SubmitOrder(Order o);                                }        And the Order class:            [DataContract(Namespace = &quot;http://www.ayende.com/WCF/TestDriven/&quot;)]                                public class Order                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private int id;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private List&lt;OrderLine&gt; orderLines = new List&lt;OrderLine&gt;();                                &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [DataMember]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public int Id                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; get { return id; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; set { id = value; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [DataMember]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public List&lt;OrderLine&gt; OrderLines                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; get { return orderLines; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; set { orderLines = value; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }                        I assume that you can figure out how OrderLine and Product looks like ;-)    The second problem that I need to overcome is that I never create my controllers myself, I let Windsor do it for me:            OrderController controller = IoC.Resolve&lt;OrderController&gt;();        The problem here is that OrderController need to get a WCF Client Proxy, which Windsor has no idea how to give. This requires some thinking. WCF is configurable to the N-th degree, and I am probably no going to need most of this configuration power at all.&#xA0;This will soon make my life a lot simpler.    Now, Windsor doesn&#x27;t know WCF, but it is extremely extensible, so all I need to do is to tell it: &quot;Windsor, meet WCF&quot; and it work with it. Let us build the WcfClientFacility. Before we start, what is a facility? A facility is a piece of code that extend Windsor, it has access to almost everything that Windsor can do, and it can modify the way Windsor (to the degree that 99% of the time you can just add functionality to Windsor without modifying Windsor itelf). Facilities has a lot of uses in Castle communities.     We start with the WcfClientFacility itself:            public class WcfClientFacility : AbstractFacility                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private readonly WcfClientConfiguration[] registeredServicesConfigurations;                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public WcfClientFacility(params WcfClientConfiguration[] registeredServicesConfigurations)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; this.registeredServicesConfigurations = registeredServicesConfigurations;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; protected override void Init()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Kernel.Resolver.AddSubResolver(new WcfClientResolver(registeredServicesConfigurations));                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; foreach (WcfClientConfiguration configuration in registeredServicesConfigurations)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ComponentModel model = new ComponentModel(configuration.Type.FullName, configuration.Type, configuration.Type);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; model.CustomComponentActivator = typeof(WcfClientActivator);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; model.LifestyleType = LifestyleType.Transient;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Kernel.AddCustomComponent(model);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        The facility accept an array of WcfClientConfiguration, which&#xA0;contains the neccesary configration for a setting up the client. It first add a resolver (which we will touch in a minute) to the kernel, and then add all the interfaces to the container as components. I am doing both here because I would like to either declare a dependency in a constructor or a property (which is where the resolver comes to play) or I want to get a WCF Client directory from the container, like this:            IOrderService orderService = IoC.Resolve&lt;IOrderService&gt;();                        A couple of things to note about the component registration, I am registering a custom component activator (which just forward to the resolver, as a matter of fact) and set the lifestyle as Transient, which means that a new instance will be created when it is requested. This is useful because in many cases, a client proxy may actualy be stateful (if the service on the other side uses sessions, for instance), or an server side error has turned the client unusable, in which case the last thing that you want is that the bad client will be returned on subsequent requests.    Now, let us look at the WcfActivator:            public class WcfClientActivator : AbstractComponentActivator                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public WcfClientActivator(ComponentModel model, IKernel kernel,                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; : base(model, kernel, onCreation, onDestruction)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; protected override object InternalCreate(CreationContext context)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Type type = context.Handler.ComponentModel.Service;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; DependencyModel dependencyModel = new DependencyModel(DependencyType.Service, &quot;wcf&quot;, type, false);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return Kernel.Resolver.Resolve(context, null, context.Handler.ComponentModel, dependencyModel);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /// &lt;summary&gt;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /// Can we tell WCF that we don&#x27;t want an instance anymore?                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /// Right now I don&#x27;t know how, so we will live without it                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /// &lt;/summary&gt;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; protected override void InternalDestroy(object instance)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }                        This is called when a request to resolve a WCF component arrive, as you can see, it simply delegate the call to the resolver. The resolver is a bit complex, mostly because WCF doesn&#x27;t support untyped model:            public class WcfClientResolver : ISubDependencyResolver                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private readonly WcfClientConfiguration[] registeredServicesConfigurations;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; private delegate object CreateChannel();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Dictionary&lt;Type, CreateChannel&gt; cachedDelegates = new Dictionary&lt;Type, CreateChannel&gt;();                                &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public WcfClientResolver(WcfClientConfiguration[] registeredServicesConfigurations)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; this.registeredServicesConfigurations = registeredServicesConfigurations;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public object Resolve(CreationContext context, ISubDependencyResolver parentResolver,                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ComponentModel model, DependencyModel dependency)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; foreach (WcfClientConfiguration proxy in registeredServicesConfigurations)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (proxy.Type == dependency.TargetType)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; CreateChannel createChannel = GetCreationDelegate(proxy);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return createChannel();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; throw new InvalidOperationException(string.Format(&quot;Could not find a proxy type matching {0}&quot;, dependency.TargetType));                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                                &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public bool CanResolve(CreationContext context, ISubDependencyResolver parentResolver,                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ComponentModel model, DependencyModel dependency)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; foreach (WcfClientConfiguration configuration in registeredServicesConfigurations)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (dependency.TargetType == configuration.Type)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return true;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return false;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        The resolver was created in the Init() method of the WcfClientFacility. It has two important method, CanResolve() (to which it will answer in the affirmative if the type that is a WCF [ServiceContract] that it had got) and Resolve(), which delegate the actual resolving to a delegate that it got from the GetCreationDelegate(). I am not showing the GetCreationDelegate above, here it is:            private CreateChannel GetCreationDelegate(WcfClientConfiguration configuration)                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; CreateChannel creation;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (cachedDelegates.TryGetValue(configuration.Type, out creation))                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return creation;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; lock (cachedDelegates)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (cachedDelegates.TryGetValue(configuration.Type, out creation))                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return creation;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Type type = typeof(ChannelFactory&lt;&gt;).MakeGenericType(configuration.Type);                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; object target;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (configuration.EndpointName != null)                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; //new ChannelFactory&lt;T&gt;(configuration.EndpointName).CreateChannel() - get the configuration from the app.config                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; target = Activator.CreateInstance(type, configuration.EndpointName);                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; else//we had the binding, contract explicty set for us.                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; // new ChannelFactory&lt;T&gt;(configuration.Binding, configuration.EndpointAddress).CreateChannel()                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; target = Activator.CreateInstance(type, configuration.Binding, configuration.EndpointAddress);                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; MethodInfo methodInfo = type.GetMethod(&quot;CreateChannel&quot;, new Type[] { });                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; creation = (CreateChannel)Delegate.CreateDelegate(typeof(CreateChannel), target, methodInfo);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; cachedDelegates[configuration.Type] = creation;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return creation;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        What does this do??    Well, the major issue is that WCF doesn&#x27;t have untyped API, which means that I can&#x27;t do something like &quot;new ChannelFactory(typeof(IOrderService)).CreateChannel()&quot;. I have to call new ChannelFactory&lt;IOrderService&gt;().CreateChannel(). The code above deals with transforming the typed API to an untyped one.     One thing that is very important to note is that we have two ways to create the client, the first is by specifying an endpoint name, in which case it will go and look in the app.config for the configuration, the second is by specifying the EndpointAddress and Binding yourself, this will be useful in a moment.     The rest of this method just deal with creating a delegate to the CreateChannel method, and then storing it in a cache, for future reference.     Okay, so I made you sit through building a TDD service and adding a facility to Windsor, where am I driving at?    Well, consider what I can now do. We will start with the configuration:            import WCF.TDD                        import System.ServiceModel                                &#xA0;                        orderServiceClient = WcfClientConfiguration(                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Type: IOrderService,                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Binding: NetNamedPipeBinding(),                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; EndpointAddress: EndpointAddress(&quot;net.pipe://localhost/TDD.WCF.Order&quot;) )                                &#xA0;                        IoC.Container.AddFacility( &quot;wcf&quot;, WcfClientFacility( orderServiceClient ) )                        Component(&quot;orderController&quot;, OrderController)        And move to the actual code:            IWindsorContainer container = new RhinoContainer(&quot;Windsor.boo&quot;);                                OrderController orderController = container.Resolve&lt;OrderController&gt;();        We now have a fully functional orderController that can make use of a WCF client, and we didn&#x27;t have to do anything special. As you saw before, we can mock this easily, so we have no dependency on WCF to run or test this code. To be rather exact, we do depend on WCF, after all, we need to catch WCF exception like CommuniationException and FaultException. The difference is that we have do dependency on a running service, which mean that we can build / test our application in isolation. For instance, the service that we outlined above doesn&#x27;t even exist.    Now let us take it a bit further, shall we?    After testing my controller in isolation, I would like to test it during integration, but I have no control over the external service, and I certainly can&#x27;t start sending requests to a service just for testing. (Mr. Foo get really annoyed when this happens). I still want to ensure that I am using WCF correctly, that I get the responses that I expect, etc. Considerring how complex WCF is, I think that this is certainly something that I ought to test.    Let us see how we can achieve that... here is what I want:            [TestFixture]                                public class Integration_OrderControllerFixture                        {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; IOrderService orderServiceMock;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; MockRepository serviceMockRepository;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Uri uri = new Uri(&quot;net.pipe://localhost/TDD.WCF.Order&quot;);                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [TestFixtureSetUp]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void TestFixtureInitialize()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository = new MockRepository();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock = serviceMockRepository.CreateMock&lt;IOrderService&gt;();&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;                                 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                                &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [Test]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void CanCallMockedWCFService()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; IOrderService orderServiceClient = new ChannelFactory&lt;IOrderService&gt;(new NetNamedPipeBinding(), uri.AbsoluteUri)        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .CreateChannel();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceClient.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; [TearDown]                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; public void TestCleanup()                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.VerifyAll();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }                                }        Looks like I want to be able to make a call to the mocked instnace via WCF, how can we do it? We can utilize a WCF feature that let me pass it an initialized instance of a service. If we will pass it a mock object, what would happen?     I added a ServiceHost member variable, and initialized in the test fixture setup:            [TestFixtureSetUp]                                public void TestFixtureInitialize()                                {        &#xA0;                            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;container = new RhinoContainer(&quot;windsor.boo&quot;);                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository = new MockRepository();        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock = serviceMockRepository.CreateMock&lt;IOrderService&gt;();        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceHost = new ServiceHost(orderServiceMock, uri);        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceHost.AddServiceEndpoint(typeof(IOrderService), new NetNamedPipeBinding(), uri);        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceHost.Description.Behaviors.Find&lt;ServiceBehaviorAttribute&gt;()        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .InstanceContextMode = InstanceContextMode.Single;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceHost.Open();                                }        Here are a couple of interesting things to note:            We create a RhinoContainer we the same configuration as we have above.            We pass the service host the mock instance that we got from Rhino Mocks.            We configure an end point for the interface.            Finally, we specify that the instance mode for this service host is a singleton. (Required if you are passing an external instance.    Running the test now pass! We have successfully mocked a service on the other side of the wire!    Now let us implement the rest of the tests. Before I can add another test, however, I need to fix an issue with the fixture, I am using [TestFixtureSetUp] to build the service host and the mock object, but I am using [TearDown] (not [TestFixtureTearDown]) to verify the mock. The reason for this is that I have [Setup] and [TestFixtureTearDown] as well that I didn&#x27;t show:            [SetUp]                                public void TestInitialize()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.BackToRecord(orderServiceMock);                                }                        [TestFixtureTearDown]                                public void TestFixtureCleanup()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceHost.Close();                                 }        The [SetUp] method will return the mocked orderServiceMock to recording state, and the [TestFixtureTearDown] will close the service host, freeing resources.    Now, for our successful test:            [Test]                                public void WillSubmitOrderWithSameIdAsTheOnePassedToController()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.Constraints(Is.NotNull() &amp;&amp; Property.Value(&quot;Id&quot;, 5));                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController orderController = container.Resolve&lt;OrderController&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = orderController.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsTrue(result, &quot;Should return true when successful&quot;);                                }        What just happened?     I used everything that I talked about it before (WcfClientFacility, Mocks, and WCF) in order to get this test to work, let us break it to individual steps:            We define an expectation that the service&#x27;s SubmitOrder will be called with a non-null value whose Id equals 5. Note that this assertion is actually happening on the other side of the wire! In other words, what we are actually testing here is that the data that the controller sent was actually correctly recieved on the other end.            We request a controller from the container, and get a fully intialized object, this included calling the WcfClientResolver and getting a client proxy from WCF.            We make a call that eventually get back to the mock, where Rhino Mocks verify that the expectation is met.    Now, let us try something more complex, like throwing a FaultException:            [Test]                                public void WillReturnFalseIfOrderSubmittedRaisedFaultException()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments()                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Throw(new FaultException(&quot;Just Because I felt like it&quot;));                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController orderController = container.Resolve&lt;OrderController&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = orderController.SubmitOrder(orderId);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsFalse(result, &quot;Should return true is send failed beause of a fault exeption&quot;);                                }        Yep, it just works :-)    However, trying to run this test:            [Test]                                public void WillRetryThreeTimesIfCommunicationExceptionIsRaisedAndThenReturnFalse()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments()                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Throw(new CommunicationException(&quot;Just Because I felt like it&quot;))                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Repeat.Times(3);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController orderController = container.Resolve&lt;OrderController&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = orderController.SubmitOrder(orderId);                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsFalse(result, &quot;Should return true is send failed beause of a fault exeption&quot;);                                }        Result in a failure:TestCase &#x27;Integration_OrderControllerFixture.TestInitialize.WillRetryThreeTimesIfCommunicationExceptionIsRaisedAndThenReturnFalse.TestCleanup&#x27;    failed: IOrderService.SubmitOrder(any); Expected #3, Actual #1.    This looks like we only called the service SubmitOrder() once, but why? The reason here is that if WCF detect an exception that is not FaultException it will convert it to a FaultException (that is technically not correct, it is more complex than that, but this is enough).    Here is my new attempt:            [Test]                                public void WillReturnFalseAndNotThrowIfCantContactService()                                {                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; orderServiceMock.SubmitOrder(null);                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LastCall.IgnoreArguments()                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; .Repeat.Never();                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceMockRepository.ReplayAll();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; serviceHost.Close();                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int orderId = 5;                                &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; OrderController orderController = container.Resolve&lt;OrderController&gt;();                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; bool result = orderController.SubmitOrder(orderId);                                        &#xA0;                        &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Assert.IsFalse(result, &quot;Should return true is send failed beause of a fault exeption&quot;);                                }        What do I do here? I specify that the SubmitOrder should not be called, and then I close the service host, now if clients attempt to access it, they will get CommunicationException, which is what I wanted to test.     Note that I changed the name of the test, because it is no longer testing that we are retrying three times. Usually, in those cases I would rely on the logging information to verify that (and verify that the logs are going out :-) ), in this case, it is a demo and I already have the unit tests that verify that this is indeed the correct behavior.    Well, that was long enough, by my count, this is over 20 printed pages, which probably means that you already gave up on this post long ago. At any rate, I planned to post about how to integrate WCF services (and not just clients) into Windsor, but I believe that this can certainly wait for another day.    You can find the code here, have fun.</p>
        </article>
        <article id="article-8316">
            <a href="https://ayende.com/blog/2094/mocking-wcf" target="_blank">
                <h2 class="title mb-6" id="article-8316">Mocking WCF</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 10, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Well, the tests for this are passing:            IoC.AddIntegrationWith(                        &#xA0; new WindowsCommunicationFoundation().Behaviors.Add( new RhinoMocks() )                );        :-)    That was tough, but I got it to work in a fashion that I like. This means WCF integration with Windsor, support for mocking WCF services on both ends of the wire and probably a couple other things that I am forgetting. I am in the middle of writing a blog post about it, and I had to stop when I got everything to work just right. That post is already 13 pages long, and I just had to post something as things were happening.</p>
        </article>
        <article id="article-8317">
            <a href="https://ayende.com/blog/2093/first-impressions-from-wcf" target="_blank">
                <h2 class="title mb-6" id="article-8317">First impressions from WCF</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 10, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">About a year ago, I sat on a WCF lecture in a user group. That was about 1.5 hours WCF (then still called Indigo) that lasted for a long time. I almost explicitly avoided learning anything about the WinFX set of technologies. They had no relation to my current projects, and I had enough on my table as it was. This has changed recently, especially since the RTM of .Net 3.0     I am now learning about WCF, and I thought that I would detail what I think about it as I got along.     Before even starting, I feel that I must point out something. Just about everyone that I talk to feel the need to point out that you can modify the service binding without touching the code. For me, this is a major non-issue. I took a brief look at the WCF configuration files, and I started to develop a severe case of Xmlitis. Beyond this, I am not impressed with changing the configuration to completely change the actions of the code. It is very basic stuff. [And no, I am not attacking WCF for this, I just annoyed by people who feel the need to point this as a major advantage.]     &#xA0;After learning a bit about the way WCF works, I can say that this is an illusion, while you configure much in the config file, there are quite a bit of implication of those configuration that any real service would have a fairly static configuration by its very nature. Just looking at the feature matrix of each protocol and comparing it to the things I need can lock me to a specific mode of operation.     This gets really interesting when you consider a simple case of throwing an exception from a service, and all the ways that the protocol, binding etc will affect it, will it break the channel or not, can the client know about it or not, what happens if a callback it used and it throws exception when called from within the service operation method. There are answers to all of the above, but they goes like this:     If Net TCP is used, then&#x2026;, If Http Dual is used, then&#x2026;     I wonder how big is the full feature matrix (and in how many dimentions it needs to be). WCF is huge in the number of paraemters that you can play with, and the number of combinations and possiblities that you end up with.     What I find interesting is that WCF is very similar (conceptually) to the way an IoC container work, in fact, I can probably draw direct correlations between Windsor and WCF in many areas.</p>
        </article>
        <article id="article-8318">
            <a href="https://ayende.com/blog/2092/wcf-attack-of-the-generics" target="_blank">
                <h2 class="title mb-6" id="article-8318">WCF: Attack Of The Generics</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 10, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I am trying to learn WCF, and I am simply amazed at the amount of Something&lt;T&gt; that they have all over the place. Yes, strongly typing it a wonderful thing, but I think that they went too far with it. (And I am speaking as someone who used generics to give you compile time errors about misformed database queries!)    Let us take ChannelFactory&lt;T&gt; for instnace, I can&#x27;t use it without specifying a type parameter. All fine and good, until I need to construct a proxy from its System.Type, in a late bound fashion. Then it starts to get ugly. This is particulary annoying since as far as I can reflect, I am seeing that the underlying ServiceChannelFactory does not use the generic model, so I could make it work with a System.Type object. The problem is that again, someone decided to slap internal on useful types.    This leads to... interesting code, shall we say, when it comes to dealing with ChannelFactory in a generic fashion (i.e, not against a specific service, but against several). This is me after about 30 minutes of starting to play with WCF. I just hate it when I run into brick walls so fast.</p>
        </article>
        <article id="article-8319">
            <a href="https://ayende.com/blog/2091/working-on-fine-art" target="_blank">
                <h2 class="title mb-6" id="article-8319">Working on Fine Art</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 10, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">There is a tendecy for developers to disregard looks for function. I am certainly one of those :-) For a long time, I used to work on UI that were functional, but looked like this:        This is functional login and it certainly work in the sense that this is doing what the spec says it should. But compare it to this:        There isn&#x27;t any additional functionality implemented, but there is a host of stuff that are visible that make the work much easier. You can see what you need to do (remember me, email password, create account), and it make it much easier to show the work in progress to customers.    One thing that is not immediately evident, however, is that it feels much better to work on something beautiful that something merely functional. A while ago I implemented a login page that had a whole lot of stuff in the back end that were really cool. But it wasn&#x27;t until I saw the page (which looked very much like it would look in the end), that I felt a surge of satisfaction.    There is a whole list of reasons that&#xA0;I could give for why working on near finished UI at all times is good, from demoability to ensuring functionability, but the most important reason in my opinion is that it helps to know that you are working on something pretty. And that can give a sense of satisfaction no abstract factory can build for you :-)</p>
        </article>
        <article id="article-8320">
            <a href="https://ardalis.com/sql-reporting-services-401-error/" target="_blank">
                <h2 class="title mb-6" id="article-8320">SQL Reporting Services 401 Error</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: February 09, 2007
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you just installed SQL Server Reporting Services and you are getting a 401.1 Unauthorized error when you try to go to the http&#x2026;Keep Reading &#x2192;</p>
        </article>
        <div class="button flex justify-between">
            <a href="831.html"><span class="back arrow"></span></a>

            <a href="833.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>

<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;🚀&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="about.html"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="/pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>
