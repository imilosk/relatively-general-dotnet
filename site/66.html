
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 66 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-651">
            <a href="https://ayende.com/blog/199361-B/fight-for-every-byte-it-takes-variable-size-data" target="_blank">
                <h2 class="title mb-6" id="article-651">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 25, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my previous post, we stored keys and values as raw numbers inside the 8KB page. That was simple, but wasteful. For many scenarios, we are never going to need to utilize the full 8 bytes range for a long. Most numbers are far smaller.&#xA;In the example I gave in the last post, we are storing the following range of numbers (file offsets, basically). I&#x2019;m using two test scenarios, one where I&#x2019;m testing the full range (for correctness) and one where I&#x2019;m testing files under 512 GB in size. Given that we are trying to compress the space, once we hit the 512GB mark, it is probably less urgent, after all.&#xA;Here are the number generations that I&#x2019;m using:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          IEnumerable&lt;long&gt; Generate_Full()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var rand = new Random(2023_04_21);&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  yield return rand.Next(100) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 3 =&gt; rand.NextInt64(0, 1L &lt;&lt; 7),  // 3%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 10 =&gt; rand.NextInt64(0, 1L &lt;&lt; 15),// 7%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 35 =&gt; rand.NextInt64(0, 1L &lt;&lt; 23),// 25%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 75 =&gt; rand.NextInt64(0, 1L &lt;&lt; 31),// 35%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 90 =&gt; rand.NextInt64(0, 1L &lt;&lt; 39),// 15%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 95 =&gt; rand.NextInt64(0, 1L &lt;&lt; 47),// 5%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 98 =&gt; rand.NextInt64(0, 1L &lt;&lt; 55),// 3%&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; rand.NextInt64(0, 1L &lt;&lt; 62)    // 2%&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          IEnumerable&lt;long&gt; Generate_Realistic()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var rand = new Random(2023_04_21);&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  yield return rand.Next(100) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 1 =&gt; rand.NextInt64(0, 1L &lt;&lt; 7),  // 1%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 3 =&gt; rand.NextInt64(0, 1L &lt;&lt; 15), // 2%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 30 =&gt; rand.NextInt64(0, 1L &lt;&lt; 23),// 27%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 75 =&gt; rand.NextInt64(0, 1L &lt;&lt; 31),// 35%&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; rand.NextInt64(0, 1L &lt;&lt; 39),   // 25%&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Generate.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;What this means is:&#xA;&#xA;&#xA;&#xA;Full data set&#xA;Realistic data set&#xA;&#xA;&#xA;&#xA;&#xA;&#xA0; 3% in the first 128 bytes&#xA;&#xA0; 7% in the first 64 KB&#xA;25% in the first 8 MB&#xA;35% in the first 2 GB&#xA;15% in the first 512 GB&#xA;5% in the first 128 TB&#xA;3% in the first 32 Petabytes&#xA;2% in the first 4 Exabytes&#xA;&#xA;&#xA;&#xA;&#xA;&#xA0; 1% in the first 128 bytes&#xA;&#xA0; 2% in the first 64 KB&#xA;27% in the first 8 MB&#xA;35% in the first 2 GB&#xA;25% in the first 512 GB&#xA;&#xA;&#xA0;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;This is meant to verify that we can handle any scenario, in practice, we can usually focus on the first 512 GB, which is far more common.&#xA;Using both approaches, I can fit using my previous approach, up to 511 entries per page. That makes sense, we are storing the data raw, so how can we do better? Most of the time, we don&#x2019;t need anywhere near 8 bytes per value. For that reason, we have variable length encoding, which has many names, such as variable size int, 7 bits integers, etc. I adapted some methods from the .NET codebase to allow me to operate on Spans, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static int Write7BitEncodedInt64(long value, Span&lt;byte&gt; buffer)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              // Adapted from: https://github.com/dotnet/runtime/blob/2087ceb0c70f0c13e79fbbdec90efd242e1f2cd4/src/libraries/System.Private.CoreLib/src/System/IO/BinaryWriter.cs#L492&#xA;        &#xA;        &#xA;          &#xA;              ulong uValue = (ulong)value;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // Write out an int 7 bits at a time. The high bit of the byte,&#xA;        &#xA;        &#xA;          &#xA;              // when on, tells reader to continue reading more bytes.&#xA;        &#xA;        &#xA;          &#xA;              //&#xA;        &#xA;        &#xA;          &#xA;              // Using the constants 0x7F and ~0x7F below offers smaller&#xA;        &#xA;        &#xA;          &#xA;              // codegen than using the constant 0x80.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int index = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (uValue &gt; 0x7Fu)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  buffer[index&#x2B;&#x2B;] = ((byte)((uint)uValue | ~0x7Fu));&#xA;        &#xA;        &#xA;          &#xA;                  uValue &gt;&gt;= 7;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              buffer[index&#x2B;&#x2B;] = ((byte)uValue);&#xA;        &#xA;        &#xA;          &#xA;              return index;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private static long Read7BitEncodedInt64(Span&lt;byte&gt; buffer, out int len)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              // Adapted from: https://github.com/dotnet/runtime/blob/2087ceb0c70f0c13e79fbbdec90efd242e1f2cd4/src/libraries/System.Private.CoreLib/src/System/IO/BinaryReader.cs#L588&#xA;        &#xA;        &#xA;          &#xA;              ulong result = 0;&#xA;        &#xA;        &#xA;          &#xA;              byte byteReadJustNow;&#xA;        &#xA;        &#xA;          &#xA;              len = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // Read the integer 7 bits at a time. The high bit&#xA;        &#xA;        &#xA;          &#xA;              // of the byte when on means to continue reading more bytes.&#xA;        &#xA;        &#xA;          &#xA;              //&#xA;        &#xA;        &#xA;          &#xA;              // There are two failure cases: we&#x27;ve read more than 10 bytes,&#xA;        &#xA;        &#xA;          &#xA;              // or the tenth byte is about to cause integer overflow.&#xA;        &#xA;        &#xA;          &#xA;              // This means that we can read the first 9 bytes without&#xA;        &#xA;        &#xA;          &#xA;              // worrying about integer overflow.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              const int MaxBytesWithoutOverflow = 9;&#xA;        &#xA;        &#xA;          &#xA;              for (int shift = 0; shift &lt; MaxBytesWithoutOverflow * 7; shift &#x2B;= 7)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // ReadByte handles end of stream cases for us.&#xA;        &#xA;        &#xA;          &#xA;                  byteReadJustNow = buffer[len&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;                  result |= (byteReadJustNow &amp; 0x7Ful) &lt;&lt; shift;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (byteReadJustNow &lt;= 0x7Fu)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      return (long)result; // early exit&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // Read the 10th byte. Since we already read 63 bits,&#xA;        &#xA;        &#xA;          &#xA;              // the value of this byte must fit within 1 bit (64 - 63),&#xA;        &#xA;        &#xA;          &#xA;              // and it must not have the high bit set.&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              byteReadJustNow = buffer[len&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;              if (byteReadJustNow &gt; 0b_1u)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  throw new FormatException(&quot;Format_Bad7BitInt&quot;);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              result |= (ulong)byteReadJustNow &lt;&lt; (MaxBytesWithoutOverflow * 7);&#xA;        &#xA;        &#xA;          &#xA;              return (long)result;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          varint.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Let&#x2019;s check what sort of savings we can get using this approach:&#xA;&#xA;Under 127 bytes&#x2013; 1 byte&#xA;128 bytes .. 32 KB &#x2013; 2 bytes&#xA;32KB .. 8MB &#x2013; 3 bytes&#xA;8MB .. 2GB &#x2013; 4 bytes&#xA;2 GB .. 512 GB &#x2013; 5 bytes&#xA;512GB .. 128 TB &#x2013; 6 bytes&#xA;128TB .. 32 Petabytes &#x2013; 7 bytes&#xA;32 Petabytes .. 8 Exabytes &#x2013; 8 bytes&#xA;Greater than 8 Exabytes &#x2013; 9 bytes&#xA;&#xA;That is really cool, since for the realistic data set, we can pack a lot more data into the page.&#xA;It comes with a serious issue, however. The data is no longer fixed size (well, that is the point, no?). Why is that a problem? Because we want to be able to do a binary search on that, which means that we need to be able to access the data by index. As usual, the solution is to utilize indirection. We&#x2019;ll dedicate the bottom of the page to an array of fixed-size int (16 bits &#x2013; sufficient to cover the 8KB range of the page) that will point to the actual location of the entry. Like before, we are going to reserve the first few bytes as a header, in this case we&#x2019;ll use 4 bytes, divided into two shorts. Those will keep track of the writes to the bottom and the top of the page.&#xA;At the bottom, we&#x2019;ll have the actual offsets that point to the entries, and at the top, we write the actual entries. Here is what this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static Span&lt;ushort&gt; OffsetsFor(Span&lt;byte&gt; page)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var asShorts = MemoryMarshal.Cast&lt;byte, ushort&gt;(page);&#xA;        &#xA;        &#xA;          &#xA;              var bottom = asShorts[0];&#xA;        &#xA;        &#xA;          &#xA;              var top = asShorts[1]; // unused here, included for clarity&#xA;        &#xA;        &#xA;          &#xA;              return MemoryMarshal.CreateSpan(ref asShorts[2], (bottom - 4) / 2);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Header.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Let&#x2019;s see how our reading from the page will look now. As you can see, it is very similar to what we had before, but instead of going directly to the key by its offset, we have to use the indirection:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static bool TryGetValue(Span&lt;byte&gt; page, long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var idx = BinarySearch(page, key);&#xA;        &#xA;        &#xA;          &#xA;              if (idx &lt; 0) // update&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  val = default;&#xA;        &#xA;        &#xA;          &#xA;                  return false;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;              var entryOffset = offsets[idx];&#xA;        &#xA;        &#xA;          &#xA;              _ = Read7BitEncodedInt64(page[entryOffset..], out var keyLen);&#xA;        &#xA;        &#xA;          &#xA;              val = Read7BitEncodedInt64(page[(entryOffset &#x2B; keyLen)..], out _);&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          TryGetValue.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The offsets array contains the location of the entry in the page, and that is laid out as the [varint-key][varint-val]. So we read (and discard) the key from the offset we found (we have to do that to discover its size) and then we read and return the actual value.&#xA;Let&#x2019;s look at how we implemented the actual binary search in the page:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static int BinarySearch(Span&lt;byte&gt; page, long key)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;              int lo = 0, hi = offsets.Length - 1;&#xA;        &#xA;        &#xA;          &#xA;              while (lo &lt;= hi)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  int mid = (lo &#x2B; hi) &gt;&gt; 1;&#xA;        &#xA;        &#xA;          &#xA;                  var entryOffset = offsets[mid];&#xA;        &#xA;        &#xA;          &#xA;                  var cur = Read7BitEncodedInt64(page[entryOffset..], out _);&#xA;        &#xA;        &#xA;          &#xA;                  int cmp = key.CompareTo(cur);&#xA;        &#xA;        &#xA;          &#xA;                  if (cmp == 0)&#xA;        &#xA;        &#xA;          &#xA;                      return mid;&#xA;        &#xA;        &#xA;          &#xA;                  if (cmp &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      lo = mid &#x2B; 1;&#xA;        &#xA;        &#xA;          &#xA;                  else&#xA;        &#xA;        &#xA;          &#xA;                      hi = mid - 1;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // where it is *supposed* to go&#xA;        &#xA;        &#xA;          &#xA;              return ~lo;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          BinarySearch.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is a bog standard binary search, with the only interesting bit that we are going through the offsets array to find the actual location of the key, which we then read using variable size decoding.&#xA;The interesting part of this model happens when we need to set a value. Here is what this looks like, with my notes following the code.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static bool Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // header is 4 bytes [bottom, top] &#xA;        &#xA;        &#xA;          &#xA;              ref var bottom = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              ref var top = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[1]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (bottom == 0) // init empty page &#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  top = 8192; // top of the page&#xA;        &#xA;        &#xA;          &#xA;                  bottom = 4; // leave 4 bytes for the bottom/top header&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var usableSpace = top - bottom;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;byte&gt; temp = stackalloc byte[18]; // max varint = 9 - we need to encode 2&#xA;        &#xA;        &#xA;          &#xA;              var reqEntryLen = Write7BitEncodedInt64(key, temp);&#xA;        &#xA;        &#xA;          &#xA;              reqEntryLen &#x2B;= Write7BitEncodedInt64(val, temp[reqEntryLen..]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var idx = BinarySearch(page, key);&#xA;        &#xA;        &#xA;          &#xA;              Span&lt;ushort&gt; offsets;&#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // let&#x27;s check if we can update?&#xA;        &#xA;        &#xA;          &#xA;                  offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;                  var entryOffset = offsets[idx];&#xA;        &#xA;        &#xA;          &#xA;                  Read7BitEncodedInt64(page[entryOffset..], out var keyLen);&#xA;        &#xA;        &#xA;          &#xA;                  Read7BitEncodedInt64(page[(entryOffset &#x2B; keyLen)..], out var valLen);&#xA;        &#xA;        &#xA;          &#xA;                  if (reqEntryLen &gt; keyLen &#x2B; valLen) // cannot fit, need new allocation&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (reqEntryLen &gt; usableSpace)&#xA;        &#xA;        &#xA;          &#xA;                          return false; // we are full, need to split the page&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  else&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      // can fit, just copy &amp; done&#xA;        &#xA;        &#xA;          &#xA;                      temp[..reqEntryLen].CopyTo(page[entryOffset..]);&#xA;        &#xA;        &#xA;          &#xA;                      return true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              else // increase size of offsets array&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (reqEntryLen &#x2B; sizeof(ushort) &gt; usableSpace)&#xA;        &#xA;        &#xA;          &#xA;                      return false; // we are full, need to split the page&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  idx = ~idx;&#xA;        &#xA;        &#xA;          &#xA;                  bottom &#x2B;= 2;&#xA;        &#xA;        &#xA;          &#xA;                  offsets = OffsetsFor(page);&#xA;        &#xA;        &#xA;          &#xA;                  offsets[idx..(offsets.Length - 1)].CopyTo(offsets[(idx &#x2B; 1)..]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              top -= (ushort)reqEntryLen;&#xA;        &#xA;        &#xA;          &#xA;              offsets[idx] = top; // new data location&#xA;        &#xA;        &#xA;          &#xA;              temp[..reqEntryLen].CopyTo(page[top..]);&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Set.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is quite a lot, I&#x2019;ll admit. Let&#x2019;s try to break up into individual pieces what is going on here.&#xA;First, we get the header values (bottom, top) and initialize them if empty (note that bottom is set to 4, after the header, while top is set to the end of the buffer). The idea is that the bottom grows up and the top grows down. This is called Slotted Page design and it is a staple of database design.&#xA;We then encode the key and the value into a temporary buffer. We need to do that so we&#x2019;ll know what size the entry will take. Then we need to figure out if we are updating an existing record or creating a new one.&#xA;Updating an existing record is complex. This is because the size of the new record may be greater than the size of the old one. So we can&#x2019;t put it in the same location. I&#x2019;m handling this by just allocating new space for this entry, ignoring the old space that was allocated to it.&#xA;&#xA;I&#x2019;m not handling any deletes / space reclamation on this series. That is a separate subject, not complex, but fairly tedious to do properly. So I&#x2019;m going to focus solely on writes.&#xA;&#xA;Updates to an existing entry that also change its size aren&#x2019;t in my test dataset, so I&#x2019;m not worried about it too much here. I mention this to point out that variable length records bring with them considerations that we wouldn&#x2019;t have run into with the fixed-size model.&#xA;And after all of this work? What are the results?&#xA;With the fixed-size version, we could fit 511 entries into the page. With the variable size int, however, we can do better.&#xA;For the realistic dataset, I can fit 712 entries for the page, and for the full dataset, 710 (there are very few very big elements even there, but we can see that it has an impact).&#xA;511 vs. 712 may not sound like much, but that is 40% increase in the number of entries that I can fit. To give some context, using 8KB pages, that is a difference of 5 MB per million entries. That adds up.&#xA;The question is, can we do better? More on that in my next post&#x2026;</p>
        </article>
        <article id="article-652">
            <a href="https://andrewlock.net/super-charging-git-rebase-with-git-absorb/" target="_blank">
                <h2 class="title mb-6" id="article-652">Super-charging &#x27;git rebase&#x27; with &#x27;git absorb&#x27;</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 25, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I describe the git-absorb tool, and show how it can super-charge your git rebase workflow, removing a huge amount of manual work!&#x2026;</p>
        </article>
        <article id="article-653">
            <a href="https://ayende.com/blog/199329-B/fight-for-every-byte-it-takes-storing-raw-numbers" target="_blank">
                <h2 class="title mb-6" id="article-653">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 24, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I write databases for a living, which means that I&#x2019;m thinking a lot about persistence. Here is a fun challenge that we went through recently. We have the need to store a list of keys and values and then lookup a value by key. Pretty standard stuff. The keys and values are both 64 bits integers. In other words, what I would like to have is:&#xA;&#xA;Dictionary&lt;long,long&gt; lookup;&#xA;&#xA;That would be perfect, except that I&#x2019;ve to persist the data, which means that I have to work with raw bytes. It&#x2019;s easiest to think about it if we have some code in front of us. Here is the interface that I need to implement:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // impl...&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          bool TryGetValue(Span&lt;byte&gt; page, long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // impl...&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Page.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we have a byte buffer (8KB in size) and we want to add or lookup values from the buffer. All the data resides&#xA0;in the buffer, nothing is external. And we cannot unpack it in memory, because this is used for lookups, so this needs to be really fast.&#xA;The keys we are storing are file offsets, so they correlate quite nicely to the overall size of the file. Meaning that you&#x2019;ll have a lot of small values, but also large ones. Given a key, we need to be able to look its value quickly, since we may run this lookup billions of times.&#xA;Given that I have 8KB of data, I can do the following, just treat the buffer as a sorted array, which means that I get a pretty easy way to search for a particular value and a simple way to actually store things.&#xA;Theoretically, given an 8KB page, and 16 bytes per each (key, value) entry, we can store up to 512 entries per page. But it turns out that this is just a theory. We also need to keep track of the number of items that we have, and that takes some space. Just a couple of bytes, but it means that we don&#x2019;t have those bytes available. A page can now contain up to 511 entries, and even at full capacity, we have 14 bytes wasted (2 for the number of entries, and the rest are unused).&#xA;Here is what this looks like in code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          bool Set(Span&lt;byte&gt; page, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // takes two bytes, but we reserve 8 bytes to make alignment easier&#xA;        &#xA;        &#xA;          &#xA;              ref var numberOfItems = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              // actual usable range&#xA;        &#xA;        &#xA;          &#xA;              var entries = MemoryMarshal.CreateSpan(ref MemoryMarshal.Cast&lt;byte, long&gt;(page)[1], page.Length / sizeof(long) - 1);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var keys = entries[..numberOfItems]; // from the bottom&#xA;        &#xA;        &#xA;          &#xA;              var values = entries[(entries.Length - numberOfItems)..]; // from the top&#xA;        &#xA;        &#xA;          &#xA;              var idx = keys.BinarySearch(key); // makes searching easy&#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0) // update&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  values[idx] = val;&#xA;        &#xA;        &#xA;          &#xA;                  return true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if (numberOfItems &gt;= entries.Length / 2)&#xA;        &#xA;        &#xA;          &#xA;                  return false; // we are full, need to split the page&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;              idx = ~idx; // find where it *should* go&#xA;        &#xA;        &#xA;          &#xA;              numberOfItems&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              // now extend the ranges&#xA;        &#xA;        &#xA;          &#xA;              keys = entries[..numberOfItems];&#xA;        &#xA;        &#xA;          &#xA;              values = entries[(entries.Length - numberOfItems)..];&#xA;        &#xA;        &#xA;          &#xA;              // move the existing entries to make room for the new one&#xA;        &#xA;        &#xA;          &#xA;              keys[..idx].CopyTo(keys[idx..]);&#xA;        &#xA;        &#xA;          &#xA;              values[1..(idx &#x2B; 1)].CopyTo(values[0..idx]);&#xA;        &#xA;        &#xA;          &#xA;              keys[idx] = key;&#xA;        &#xA;        &#xA;          &#xA;              values[idx] = val;&#xA;        &#xA;        &#xA;          &#xA;              return true;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          bool TryGetValue(Span&lt;byte&gt; page, long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Debug.Assert(page.Length == 8192);&#xA;        &#xA;        &#xA;          &#xA;              // takes two bytes, but we reserve 8 bytes to make alignment easier&#xA;        &#xA;        &#xA;          &#xA;              ref var numberOfItems = ref Unsafe.AsRef(MemoryMarshal.Cast&lt;byte, ushort&gt;(page)[0]);&#xA;        &#xA;        &#xA;          &#xA;              // actual usable range&#xA;        &#xA;        &#xA;          &#xA;              var entries = MemoryMarshal.CreateSpan(ref MemoryMarshal.Cast&lt;byte, long&gt;(page)[1], page.Length / sizeof(long) - 1);&#xA;        &#xA;        &#xA;          &#xA;              var keys = entries[..numberOfItems]; &#xA;        &#xA;        &#xA;          &#xA;              var values = entries[(entries.Length - numberOfItems)..];&#xA;        &#xA;        &#xA;          &#xA;              var idx = keys.BinarySearch(key); &#xA;        &#xA;        &#xA;          &#xA;              if (idx &gt;= 0) // update&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  val = values[idx];&#xA;        &#xA;        &#xA;          &#xA;                  return true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              val = default;&#xA;        &#xA;        &#xA;          &#xA;              return false;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          SimpleArray.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we are creating two arrays, the keys are growing from the bottom of the page and the values are growing from the top. The idea is that I can utilize the BinarySearch() method to quickly find the index of a key (or where it&#xA0;ought) to go. From there, I can look at the corresponding values array to get the actual value. The fact that they are growing separately (and toward each other) means that I don&#x2019;t need to move as much memory if I&#x2019;m getting values out of order.&#xA;For now, I want to set up the playground in which we&#x2019;ll operate. The type of data that you write into such a system is important. I decided to use the following code to generate the test set:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          IEnumerable&lt;long&gt; Generate()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var rand = new Random(2023_04_21);&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  yield return rand.Next(100) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 3 =&gt; rand.NextInt64(0, 1L &lt;&lt; 7),  // 3%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 10 =&gt; rand.NextInt64(0, 1L &lt;&lt; 15),// 7%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 35 =&gt; rand.NextInt64(0, 1L &lt;&lt; 23),// 25%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 75 =&gt; rand.NextInt64(0, 1L &lt;&lt; 31),// 35%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 90 =&gt; rand.NextInt64(0, 1L &lt;&lt; 39),// 15%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 95 =&gt; rand.NextInt64(0, 1L &lt;&lt; 47),// 5%&#xA;        &#xA;        &#xA;          &#xA;                      &lt; 98 =&gt; rand.NextInt64(0, 1L &lt;&lt; 55),// 3%&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; rand.NextInt64(0, 1L &lt;&lt; 62)    // 2%&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Generate.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is that we&#x2019;ll generate a random set of numbers, in the given distribution. Most of the values are in the range of 8MB to 512GB, representing a pretty good scenario overall, I think.&#xA;And with that, we just need to figure out what metrics we want to use for this purpose. My goal is to push as many values as I can into the buffer, while maintaining the ability to get a value by its key as fast as possible.&#xA;The current approach, for example, does a binary search on a sorted array plus an extra lookup to the companion values array. You really can&#x2019;t beat this, if you allow to store arbitrary keys. Here is my test bench:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Span&lt;byte&gt; buffer = new byte[8192];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var enumerator = Generate().GetEnumerator();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var index = 0;&#xA;        &#xA;        &#xA;          &#xA;          while (true)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;              var k = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;              enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;              var v = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;              if (Set(buffer, k, v) == false)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  Console.WriteLine(&quot;Inserted: &quot; &#x2B; Validate(buffer, index));&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              index&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              Validate(buffer, index);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          int Validate(Span&lt;byte&gt; buffer, int index)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var enumerator = Generate().GetEnumerator();&#xA;        &#xA;        &#xA;          &#xA;              var dic = new Dictionary&lt;long, long&gt;();&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; index; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;                  var k = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;                  enumerator.MoveNext();&#xA;        &#xA;        &#xA;          &#xA;                  var v = enumerator.Current;&#xA;        &#xA;        &#xA;          &#xA;                  dic[k] = v; // need to handle update to the same value&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              foreach (var (k,expected) in dic)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (TryGetValue(buffer, k, out var actual) == false || expected != actual)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      Console.WriteLine($&quot;Missed: {k}! {expected} != {actual}&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return dic.Count;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Tester.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This will insert key/value pairs into the page until it is full. Note that we allow duplicates (we&#x2019;ll just update the value), so we need to keep track of the number of entries inserted, not just the number of insertions.&#xA0; We also validate the structure at any step of the way, to ensure that we always get the right behavior.&#xA;This code runs as expected and we can put 511 values into the page before it gives up. This approach works, it is simple to reason about and has very few flaws. It is also quite wasteful in terms of information density. I would like to do better than 511 entries / pager. Is it possible to drop below 16 bytes per entry?&#xA;Give it some thought, I&#x2019;m going to present several ways of doing just that in my next post&#x2026;</p>
        </article>
        <article id="article-654">
            <a href="https://www.meziantou.net/retry-a-bash-command.htm" target="_blank">
                <h2 class="title mb-6" id="article-654">Retrying a bash command</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 24, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">There are many reasons for commands to fail. Some of them provide retry options, but others don&#x27;t. In this post, I describe how to retry a bash command multiple times until it succeeds.To retry a command in Bash, you can use a while loop. The loop will execute the command and if the command returns</p>
        </article>
        <article id="article-655">
            <a href="https://ayende.com/blog/199297-C/allocation-sizing-and-freeing-with-double-wide-bitmaps-oh-my" target="_blank">
                <h2 class="title mb-6" id="article-655">Allocation, sizing and freeing with double-wide bitmaps: Oh my!</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 21, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">A few years ago I wrote about how you can use a bitmap to efficiently find space to allocate. I ran into a similar scenario recently and had another thought about that. Let&#x2019;s say that we want to allocate from a buffer, which you can see below:&#xA;&#xA;Set bits in the buffer (marked by X) are busy, and cleared bits are empty. We can find a range of cleared bits to allocate easily enough, as I have shown in my previous post.&#xA;The question we now need to answer is one of freeing the memory. In the image above, you can see that we have two allocations, the yellow one (the first item) and the green one (which is composed of two cells).&#xA;The problem is how do we know what to free in this case? In the case of yellow it is really easy since we can see that it is a single element. But freeing the green element is much harder since we can&#x2019;t tell its size. Usually you need to keep that size somewhere, and usually you store it into the memory itself (taking some part of the allocation to yourself as metdata overhead).&#xA;The advantage of bitmaps is that they are simple, memory efficient, and quite fast. The problem is that they are really limited in what information they give us. The buffer above shows us busy or free, nothing more.&#xA;What if we&#x2019;ll make it more interesting? Instead of using a single bit per cell, we&#x2019;ll use two. Then we have the following states:&#xA;&#xA;0b00 &#x2013; free&#xA;0b11 &#x2013; allocated (and has next)&#xA;0b10 &#x2013; end of allocation&#xA;&#xA;This doubles the memory we use, but also gives us a really important property. Given an index in the bitmap, we can easily ask what the allocated is. We just need to find the next cleared bit, and compute the distance. Let&#x2019;s consider this simple bitmap:&#xA;&#xA;0b_00_01_00_01_11_11_00_01_11_01_01&#xA;&#xA;As you can see, we have the following allocations (I separated each two bits to make it easy to show):&#xA;&#xA;0 &#x2013; 1 cell&#xA;1 &#x2013; 1 cells&#xA;2 &#x2013; 2 cells&#xA;5 &#x2013; 3 cell&#xA;9 &#x2013; 1 cell&#xA;&#xA;The code to do the actual accounting looks like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          int AllocationSize(ulong bitmap, int pos)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offset = pos * 2;&#xA;        &#xA;        &#xA;          &#xA;              if (((bitmap &gt;&gt; offset) &amp; 1) == 0)&#xA;        &#xA;        &#xA;          &#xA;                  return 0;&#xA;        &#xA;        &#xA;          &#xA;              var mask = ulong.MaxValue &lt;&lt; (offset &#x2B; 1);&#xA;        &#xA;        &#xA;          &#xA;              ulong bitset = ~bitmap &amp; mask;&#xA;        &#xA;        &#xA;          &#xA;              var nextSetBit = BitOperations.TrailingZeroCount(bitset);&#xA;        &#xA;        &#xA;          &#xA;              return (nextSetBit &#x2B; 1  - offset) / 2;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          double-bitmap.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And now we have a bitmap where the cost of tracking the size of the allocation is a single additional bit.&#xA;If you are expecting a lot of big allocations, then this may not be worth it, but if you have many small allocations, removing the need to track this is a major benefit.</p>
        </article>
        <article id="article-656">
            <a href="https://ardalis.com/top-free-tools-dotnet-webapi-load-testing-benchmarking/" target="_blank">
                <h2 class="title mb-6" id="article-656">Top Free Tools for .NET Web API Load Testing and Benchmarking</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 20, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x27;m evaluating different approaches to data access and other cross-cutting concerns in .NET 7 Web APIs, both for clients and in preparation&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-657">
            <a href="https://ayende.com/blog/199269-A/deploying-ravendb-with-helm-chart" target="_blank">
                <h2 class="title mb-6" id="article-657">Deploying RavenDB with Helm Chart</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 19, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Helm is the package manager for Kubernetes. It allows you to easily deploy applications and systems to a Kubernetes cluster easily, safely and in a reproducible manner.&#xA;We provide you with a chart so you can use Helm to deploy RavenDB clusters.&#xA;You can visit this link for a full discussion on how to do so.</p>
        </article>
        <article id="article-658">
            <a href="https://andrewlock.net/smoother-rebases-with-auto-squashing-git-commits/" target="_blank">
                <h2 class="title mb-6" id="article-658">Smoother rebases with auto-squashing Git commits</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 18, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I introduce the --autosquash flag for git interactive rebases, describe what it does and how to format your commits to use it&#x2026;</p>
        </article>
        <article id="article-659">
            <a href="https://ayende.com/blog/199268-A/looking-into-coraxs-posting-lists-part-iii" target="_blank">
                <h2 class="title mb-6" id="article-659">Looking into Corax&#x2019;s posting lists: Part III</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 17, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We looked into the internal of Corax&#x2019;s posting list and in the last post I mentioned that we have a problem with the Baseline of the page.&#xA;We are by no means the first people to work with posting lists, and there is a wide body of knowledge on the topic. When it came time to figure out the compression format for our posting list, we used the PFOR format (Patched Frame of Reference). It, like pretty much all other integer compression methods, uses 32 bits integers. Corax utilizes 64 bits integer as the document ids, so that was a problem. We solved that problem by using a Baseline for each page. In other words, each page would be able to contain values in a range of 2.1 billion of one another. That is a very reasonable range, given that a page is 8KB in size.&#xA;There was a problem as we built more features into Corax. The posting list needed to store not just the document id, but also the frequency of the term in the source document. It turns out that we need 8 bits to do so, and we already have 64 bits range so&#x2026; Instead of creating another location to store the frequencies, we put them directly inside the posting list. But that meant that we reserved a range of bits. We have 64 bits overall, so not a big problem, right? Except that on a page basis, we have a lot less. Before, a page could contain a range of 2.1 billion, but we reserved 10 bits (frequency and tag, the details of which are not important to our story) and we ended up with a range that is 4 million per page. That little tidbit meant that we could only store in a page items that were within 4MB of one another. And that was a problem. Whenever we had a posting list where two values would be more than 4MB from one another, we would need to split the page. And since the posting list and the entries live on the same file, having more page splits means that entries are now further apart.&#xA;Here is an example of what this looks like:&#xA;&#xA;The index is taking more space than the source data, and most of that is used to store&#x2026; nothing, since we ended up with a very wide posting list containing very few entries. One of the cases of two independent issues compounding each other very quickly.&#xA;So we changed things again, instead of limiting ourselves to 32 bits range per page, we changed the PFor format to allow for 64 bits integers directly. Once again, that leads to simplification in the codebase and has greatly reduced the amount of disk space that we are actually using.&#xA;To give some context, here is the current amount of disk space taken by the same entity that previously took 800&#x2B;GB:&#xA;&#xA;The problem wasn&#x2019;t with the number of entries, but that each entry would consume 8KB of disk space on its own, and in the image, you are seeing the number of posting lists, not the number of posting lists entries.</p>
        </article>
        <article id="article-660">
            <a href="https://www.meziantou.net/detecting-dark-and-light-themes-in-a-wpf-application.htm" target="_blank">
                <h2 class="title mb-6" id="article-660">Detecting Dark and Light themes in a WPF application</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 17, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If an application support both light and dark themes, it is important to detect the current system theme and update the application accordingly. In this post, I describe how to detect if a WPF application should use a light or dark theme.#Method 1: Using the registry and the Windows message loopWin</p>
        </article>
        <div class="button flex justify-between">
            <a href="65.html"><span class="back arrow"></span></a>

            <a href="67.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>