
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 67 &#x2022; Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="/pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">
<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline underline"
               href="index.html"> Home </a><a
                aria-current="" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline " href="about.html">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>


<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-661">
            <a href="https://ayende.com/blog/199524-C/integer-compression-the-fastpfor-code" target="_blank">
                <h2 class="title mb-6" id="article-661">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 14, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">As I mentioned, I spent quite a lot of time trying to understand the mechanism behind how the FastPFor algorithm works. A large part of that was the fact that I didn&#x2019;t initially distinguish the separate steps in the process. Finding the bits&#x27; widths, packing the bits, metadata and exception management are all integral to how this works, and I tried to grok it all in one shot. I kept getting lost in 14KLOC files with dense SIMD instructions.&#xA;When looking at the code, it is also important to keep in mind that this is not a library that you are meant to pick up &amp; use. This is a research project. As such, there was enough work done to show the results, but all the spit &amp; polish that are associated with making a library ready for general consumption weren&#x2019;t done.&#xA;A simple example of that is that the code just assumes that the output buffer provided will be large enough (with no way to estimate upfront) and will overflow the buffer if that happens. Perfectly acceptable for research code, hell no for production usage, naturally.&#xA;In the same manner, the repository contains a lot of code. Most of that is being used as part of comparing the FastPFor algorithm to various other options. That can make it hard to understand what are the core parts of the algorithm and what is effectively chuff.&#xA;To be honest, the hardest part for me, however, was figuring out the memory allocation patterns that are going on in here. There is a high usage of C&#x2B;&#x2B; containers, with implicit allocations and hidden memory management. Here is a piece of code that I had to struggle to understand for quite some time, for example:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          template &lt;class STLContainer&gt;&#xA;        &#xA;        &#xA;          &#xA;          static uint32_t *packmeupwithoutmasksimd(STLContainer &amp;source, uint32_t *out,&#xA;        &#xA;        &#xA;          &#xA;                                                   const uint32_t bit) {&#xA;        &#xA;        &#xA;          &#xA;            const uint32_t size = static_cast&lt;uint32_t&gt;(source.size());&#xA;        &#xA;        &#xA;          &#xA;            *out = size;&#xA;        &#xA;        &#xA;          &#xA;            out&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            if (source.size() == 0)&#xA;        &#xA;        &#xA;          &#xA;              return out;&#xA;        &#xA;        &#xA;          &#xA;            source.resize((source.size() &#x2B; 32 - 1) / 32 * 32);&#xA;        &#xA;        &#xA;          &#xA;            uint32_t j = 0;&#xA;        &#xA;        &#xA;          &#xA;            for (; j &#x2B; 128 &lt;= size; j &#x2B;= 128) {&#xA;        &#xA;        &#xA;          &#xA;              usimdpackwithoutmask(&amp;source[j], reinterpret_cast&lt;__m128i *&gt;(out), bit);&#xA;        &#xA;        &#xA;          &#xA;              out &#x2B;= 4 * bit;&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            for (; j &lt; size; j &#x2B;= 32) {&#xA;        &#xA;        &#xA;          &#xA;              fastpackwithoutmask(&amp;source[j], out, bit);&#xA;        &#xA;        &#xA;          &#xA;              out &#x2B;= bit;&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            out -= (j - size) * bit / 32;&#xA;        &#xA;        &#xA;          &#xA;            source.resize(size);&#xA;        &#xA;        &#xA;          &#xA;            return out;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          packmeupwithoutmasksimd.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This does bit-packing using SIMD without a mask (the naming convention is something that you really have to get used to, I don&#x2019;t think I encountered justlowercase before).&#xA;Note the call to fastpackwithoutmask() in there, it assumes that the provided buffer has exactly 32 elements. A lot of the code in the project assumes that you are passed a buffer of a certain size and operate on that directly. That produces great results in terms of efficiency and code density. But when I read this code it was &#x201C;obvious&#x201D; to me that there is an out-of-band work here. If the provided buffer isn&#x2019;t perfectly aligned on 32 boundary, that method will write read or write beyond the end of the buffer.&#xA;Look at line 9 there, where the source container is being resized to ensure that this is fine, since we increase the container size to be exactly 32 elements aligned. We revert this operation later in line 20.&#xA;For some SIMD instructions, it matters the alignment of the buffers we are working on. This is handled using a custom allocator on the containers, which is not usually something that I would pay attention to.&#xA;In short, from my perspective, there is a lot of hidden behavior in non-trivial C&#x2B;&#x2B; code usage there that masks the actual behavior of the algorithm in question.&#xA;If you are looking at FastPFor (and if you care enough to look at this series of posts, you probably should), take into consideration that this code shouldn&#x2019;t be applied as is, but should probably be adapted for your needs.&#xA;In the next post, I&#x2019;m going to start discussing how we did just that for RavenDB.</p>
        </article>
        <article id="article-662">
            <a href="https://ayende.com/blog/199523-C/integer-compression-understanding-fastpfor" target="_blank">
                <h2 class="title mb-6" id="article-662">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 13, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The FastPFor is an integer compression algorithm that was published in 2012 initially. You can read the paper about it here: Decoding billions of integers per second through vectorization.&#xA;I&#x2019;ve run into this algorithm many times in the past. You pretty much can&#x2019;t be in the database arena and not run into that. It is an interesting paper, and it has a GitHub repository with the code, which is great. Except that I couldn&#x2019;t figure out what was going on there.&#xA;I actually tried stepping through the code a bunch of times, and I always ended up getting lost. The code is in C&#x2B;&#x2B; and makes heavy use of templates, containers and non-trivial amounts of magic. To give some context, I gave up when I run into these code snippers:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          /*assumes that integers fit in the prescribed number of bits */&#xA;        &#xA;        &#xA;          &#xA;          void __fastpackwithoutmask6(const uint32_t *__restrict__ in,&#xA;        &#xA;        &#xA;          &#xA;                                      uint32_t *__restrict__ out) {&#xA;        &#xA;        &#xA;          &#xA;            Unroller&lt;6&gt;::PackNoMask(in, out);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          /*assumes that integers fit in the prescribed number of bits */&#xA;        &#xA;        &#xA;          &#xA;          void __fastpackwithoutmask7(const uint32_t *__restrict__ in,&#xA;        &#xA;        &#xA;          &#xA;                                      uint32_t *__restrict__ out) {&#xA;        &#xA;        &#xA;          &#xA;            Unroller&lt;7&gt;::PackNoMask(in, out);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          static void __SIMD_fastpackwithoutmask7_32(const uint32_t *__restrict__ _in,&#xA;        &#xA;        &#xA;          &#xA;                                                     __m128i *__restrict__ out) {&#xA;        &#xA;        &#xA;          &#xA;            const __m128i *in = reinterpret_cast&lt;const __m128i *&gt;(_in);&#xA;        &#xA;        &#xA;          &#xA;            __m128i OutReg;&#xA;        &#xA;        &#xA;          &#xA;            __m128i InReg = _mm_loadu_si128(in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = InReg;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));&#xA;        &#xA;        &#xA;          &#xA;            _mm_storeu_si128(out, OutReg);&#xA;        &#xA;        &#xA;          &#xA;            &#x2B;&#x2B;out;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_srli_epi32(InReg, 7 - 3);&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_loadu_si128(&#x2B;&#x2B;in);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            // this method goes on for another 100 lines...&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          wow.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The paper itself describes the algorithm, but not in a way that actually made sense to me. I tried looking at the code, and I basically noped out. Too complex for me to understand, it seems.&#xA;But I kept running into this, and we recently had a strong need for something similar. So I basically took the time to meditate on this for a while.&#xA;On a personal level, I realized that I was trying to understand how the whole thing worked by just stepping through the code and reading the paper. The problem was that I was mixing several different layers and wasn&#x2019;t able to create the proper separation between them.&#xA;FastPFor builds upon the previously discussed simdcomp, once you understand that, you can go through this in isolation. For this reason, I first talked about SIMD bit-packing and showed an example usage, before actually diving into how FastPFor itself works.&#xA;As a reminder, simdcomp provides routines for quick packing and unpacking of integers, nothing more. FastPFor is where the actual compression happens. Let&#x2019;s see what is actually going on here. Consider the following list, which we previously discussed:&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;1871143144&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;7984&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;If we&#x2019;ll try bit-pack this list, we&#x2019;ll find out that we aren&#x2019;t gaining much. The first value is 31 bits in length, after all, and that means that we aren&#x2019;t able to save much. We talked about Frame of Reference (FOR) as a way to handle that. We can treat every128 block of numbers as a block that has its own reference point and compute the maximum number of bits for that location. That would actually save us a lot of space, but it isn&#x2019;t ideal. In the case above, most entries in the list can be packed in just 3 bits, except 2. That is where PFor comes into play, which stands for Patched Frame of Reference.&#xA;The key aspects of FastPFor are how it figures out what is the best size to use to pack the numbers, the way it detects what should be patched, and the manner in which it stores this.&#xA;The code boils down to a single function:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void getBestBFromData(const uint32_t *in, uint8_t &amp;bestb, uint8_t &amp;bestcexcept, uint8_t &amp;maxb) {&#xA;        &#xA;        &#xA;          &#xA;            uint32_t freqs[33];&#xA;        &#xA;        &#xA;          &#xA;            for (uint32_t k = 0; k &lt;= 32; &#x2B;&#x2B;k)&#xA;        &#xA;        &#xA;          &#xA;              freqs[k] = 0;&#xA;        &#xA;        &#xA;          &#xA;            for (uint32_t k = 0; k &lt; BlockSize; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;              freqs[asmbits(in[k])]&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            bestb = 32;&#xA;        &#xA;        &#xA;          &#xA;            while (freqs[bestb] == 0)&#xA;        &#xA;        &#xA;          &#xA;              bestb--;&#xA;        &#xA;        &#xA;          &#xA;            maxb = bestb;&#xA;        &#xA;        &#xA;          &#xA;            uint32_t bestcost = bestb * BlockSize;&#xA;        &#xA;        &#xA;          &#xA;            uint32_t cexcept = 0;&#xA;        &#xA;        &#xA;          &#xA;            bestcexcept = static_cast&lt;uint8_t&gt;(cexcept);&#xA;        &#xA;        &#xA;          &#xA;            for (uint32_t b = bestb - 1; b &lt; 32; --b) {&#xA;        &#xA;        &#xA;          &#xA;              cexcept &#x2B;= freqs[b &#x2B; 1];&#xA;        &#xA;        &#xA;          &#xA;              uint32_t thiscost = cexcept * overheadofeachexcept &#x2B;&#xA;        &#xA;        &#xA;          &#xA;                                  cexcept * (maxb - b) &#x2B; b * BlockSize &#x2B;&#xA;        &#xA;        &#xA;          &#xA;                                  8; // the  extra 8 is the cost of storing maxbits&#xA;        &#xA;        &#xA;          &#xA;              if (thiscost &lt; bestcost) {&#xA;        &#xA;        &#xA;          &#xA;                bestcost = thiscost;&#xA;        &#xA;        &#xA;          &#xA;                bestb = static_cast&lt;uint8_t&gt;(b);&#xA;        &#xA;        &#xA;          &#xA;                bestcexcept = static_cast&lt;uint8_t&gt;(cexcept);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getBestBFromData.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What is going on here? This function accepts an array of integers (whose size is 128) and computes the best number of bits to use to pack it.&#xA;How does that work? The first thing this does is compute how many numbers we have for each bit range. This is done using the asmbits() call, which is basically a LeadingZeroCount(). The end result is a frequency map that we can use to estimate how many bits will be required to store the items from this block.&#xA;We start from the maximum number of bits that we need to store all the numbers in the block, and we go down, checking what would be the best cost (in terms of space). Since we need to store exceptions somewhere, we compute the cost of that as we go down in the list.&#xA;This function gives us:&#xA;&#xA;bestb &#x2013; the number of bits needed to pack all the items in the block that would result in the&#xA0;smallest output size&#xA;bestcexception &#x2013; the count of exceptions (numbers that do not fit into bestb bits&#xA;maxb &#x2013; the maximum number of bits that we need to store for this block&#xA;&#xA;That is the key function, the one that is responsible for getting the best compression ratio.&#xA;What I found that made FastPFor challenging to understand is that it has a lot of state that you need to keep track of. What I described so far is a single block, but FastPFor operates over sets of numbers, and so needs to tie all of them together.&#xA;At any given point, FastPFor has:&#xA;&#xA;The block that is being outputted&#xA;The metadata about the entire process&#xA;32 arrays of exceptions&#xA;&#xA;The process interleaves all of them together in interesting ways, and I had a hard time figuring out how it all ties together.&#xA;Let&#x2019;s talk about the way FastPFor processes a single block. We process the data in the array in blocks of 128 numbers at a time, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (const uint32_t *const final = in &#x2B; length; (in &#x2B; BlockSize &lt;= final);&#xA;        &#xA;        &#xA;          &#xA;               in &#x2B;= BlockSize) {&#xA;        &#xA;        &#xA;          &#xA;            uint8_t bestb, bestcexcept, maxb;&#xA;        &#xA;        &#xA;          &#xA;            getBestBFromData(in, bestb, bestcexcept, maxb);&#xA;        &#xA;        &#xA;          &#xA;            *bc&#x2B;&#x2B; = bestb;&#xA;        &#xA;        &#xA;          &#xA;            *bc&#x2B;&#x2B; = bestcexcept;&#xA;        &#xA;        &#xA;          &#xA;            if (bestcexcept &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;              *bc&#x2B;&#x2B; = maxb;&#xA;        &#xA;        &#xA;          &#xA;              std::vector&lt;uint32_t, cacheallocator&gt; &amp;thisexceptioncontainer =&#xA;        &#xA;        &#xA;          &#xA;                  datatobepacked[maxb - bestb];&#xA;        &#xA;        &#xA;          &#xA;              const uint32_t maxval = 1U &lt;&lt; bestb;&#xA;        &#xA;        &#xA;          &#xA;              for (uint32_t k = 0; k &lt; BlockSize; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;                if (in[k] &gt;= maxval) {&#xA;        &#xA;        &#xA;          &#xA;                  // we have an exception&#xA;        &#xA;        &#xA;          &#xA;                  thisexceptioncontainer.push_back(in[k] &gt;&gt; bestb);&#xA;        &#xA;        &#xA;          &#xA;                  *bc&#x2B;&#x2B; = static_cast&lt;uint8_t&gt;(k);&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            out = packblockupsimd(in, out, bestb);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ProcessBlock.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The first thing that happens is the computation of the best bits widths for the current block. Then, we use the bc value to record the metadata about the block.&#xA;That is an array of bytes with the following format:&#xA;&#xA;Packed number of bits&#xA;Number of exceptions&#xA;&#xA;If there are exceptions for this block, we also add:&#xA;&#xA;Maximum number of bits&#xA;Offset of exception in the block (repeated as the number of exceptions)&#xA;&#xA;The metadata is shared for the entire encoding operation, across blocks.&#xA;You can see in the code that if bestcexcept (which holds the number of exceptions) is greater than zero, we find the appropriate exceptions buffer to use. That requires a better explanation.&#xA;the getBestBFromData() call gave us two important data points, the best number of bits to pack the numbers, and the maximum number. We are going to pack all the numbers in the block to the output, but what about the exceptions? Where do they go?&#xA;It turns out that we need to store the exceptions, but we don&#x2019;t actually need to store max bits, only the difference between the best number of bits and the maximum. This is what thisexceptioncontainer is holding, the remainding bits for exceptions. It&#x2019;s important to understand that this is done across blocks. So the thisexceptioncontainer value holds exceptions from many different blocks. That will turn out to be very important in just a little bit. We then scan the block and write the remainding bits to the container, and write to the metadata the offset of the value in the block. Since we are using blocks of 128 numbers, this is ensured to fit inside a byte.&#xA;The last step that we do for the block is to call: packblockupsimd(), this ends up calling to simdpack() and packs all the numbers from the block to bestb bits in the output.&#xA;It&#x2019;s really important to understand that we still have two data items that haven&#x2019;t been written. The first is the metadata for the encoding process (bits in blocks, exceptions offsets, etc). The second is the set of exceptions themselves.&#xA;This process repeats itself for each block, until the end of the buffer. It is at this point that we need to write the remaining data to the output. Here is what the code looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const uint32_t bytescontainersize =&#xA;        &#xA;        &#xA;          &#xA;              static_cast&lt;uint32_t&gt;(bc - &amp;bytescontainer[0]);&#xA;        &#xA;        &#xA;          &#xA;          *(out&#x2B;&#x2B;) = bytescontainersize;&#xA;        &#xA;        &#xA;          &#xA;          memcpy(out, &amp;bytescontainer[0], bytescontainersize);&#xA;        &#xA;        &#xA;          &#xA;          uint8_t* pad8 = (uint8_t*)out &#x2B; bytescontainersize;&#xA;        &#xA;        &#xA;          &#xA;          out &#x2B;= (bytescontainersize &#x2B; sizeof(uint32_t) - 1) / sizeof(uint32_t);&#xA;        &#xA;        &#xA;          &#xA;          while (pad8 &lt; (uint8_t*)out)&#xA;        &#xA;        &#xA;          &#xA;              *pad8&#x2B;&#x2B; = 0; // clear padding bytes&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uint32_t bitmap = 0;&#xA;        &#xA;        &#xA;          &#xA;          for (uint32_t k = 2; k &lt;= 32; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;              if (datatobepacked[k].size() != 0)&#xA;        &#xA;        &#xA;          &#xA;                  bitmap |= (1U &lt;&lt; (k - 1));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          *(out&#x2B;&#x2B;) = bitmap;&#xA;        &#xA;        &#xA;          &#xA;          for (uint32_t k = 2; k &lt;= 32; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;              if (datatobepacked[k].size() &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;                  out = packmeupwithoutmasksimd(datatobepacked[k], out, k);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          final.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What is going on? This is dense, and it takes a while to unpack (pun intended) what is going on here.&#xA;First, we write the size of the metadata and then we copy the metadata that we have to the output. That is the description of all the blocks that we just went over. Then, we run over the set of exceptions that we gathered. Remember, the datatobepacked is an array that holds lists of exception data for each bit range that we have to store. We iterate over all the bit widths where we wrote exception data and generate a bitmap. That will help us later during the decoding process.&#xA;Finally, we run over the same exceptions and write them out. Note that we do that using the same simd bit-packing approach as the rest of the code.&#xA;The end result is that we have the following format:&#xA;&#xA;For decoding, we start from the metadata offset and jump to that. Then we read the exceptions bitmap. That tells us how many exceptions we have and how many bits we have in each one of them. In the image above, you can see that we have 3 exceptions list, for 4 bits, 12 bits and 19 bits.&#xA;We use the simd bit-packing to decode those values into memory. We&#x2019;ll need them shortly.&#xA0; Now, we start iterating over the metadata, each block has an overhead of minimum two metadata bytes (number of bits and number of exceptions). Let&#x2019;s assume that we don&#x2019;t have any exceptions in the block. In that case, the process of decoding is simple. Just do the unpacking from bits to numbers and you are done.&#xA;If we have exceptions, on the other hand, we have to deal with them. At that point, the next metadata byte would contain the maximum number of bits for the exceptions in this block. Using that and the normal number of bits, we can tell where the extra bits are located. Here is the relevant code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (uint32_t run = 0; run &lt; nvalue / BlockSize; &#x2B;&#x2B;run, out &#x2B;= BlockSize) {&#xA;        &#xA;        &#xA;          &#xA;            const uint8_t b = *bytep&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            const uint8_t cexcept = *bytep&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;            in = unpackblocksimd(in, out, b);&#xA;        &#xA;        &#xA;          &#xA;            if (cexcept &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;              const uint8_t maxbits = *bytep&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;              if (maxbits - b == 1) {&#xA;        &#xA;        &#xA;          &#xA;                for (uint32_t k = 0; k &lt; cexcept; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;                  const uint8_t pos = *(bytep&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  out[pos] |= static_cast&lt;uint32_t&gt;(1) &lt;&lt; b;&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              } else {&#xA;        &#xA;        &#xA;          &#xA;                std::vector&lt;uint32_t, cacheallocator&gt;::const_iterator &amp;exceptionsptr =&#xA;        &#xA;        &#xA;          &#xA;                    unpackpointers[maxbits - b];&#xA;        &#xA;        &#xA;          &#xA;                for (uint32_t k = 0; k &lt; cexcept; &#x2B;&#x2B;k) {&#xA;        &#xA;        &#xA;          &#xA;                  const uint8_t pos = *(bytep&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  out[pos] |= (*(exceptionsptr&#x2B;&#x2B;)) &lt;&lt; b;&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          decoding.cpp&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Note that there is a special case here if the difference in the number of bits between the block bits and the maximum number of bits is one. In that case, we don&#x2019;t need to store the data, we already know what the value is then (it&#x2019;s one, after all). So we can compute it once and set it in the output.&#xA;For scenarios where we can&#x2019;t tell from the bit width along, we read the relevant exception array based on the difference between the bits in the block and the exceptions bits. That gives us an array that is shared across blocks. The idea is that the metadata contains the offset in the block, and we read from the relevant array one item at a time. This two-step process will result in us setting the right value and getting ready for the next call, which may be done in a different block.&#xA;Note that the exception bits buffers only care about the number of bits, not where they come from. So two blocks, which have (bestb: 4, maxb: 9) and (bestb: 7: maxb: 10) will both go to the 3 bits container.&#xA;Okay, this blog post is getting long enough, so I think that would be it. Hopefully, it will make it easier to understand exactly how the FastPFor format is working. I&#x2019;m going to be talking more about FastPFor and the format implications in the next post, then move on to actually using that in C#.</p>
        </article>
        <article id="article-663">
            <a href="https://andrewlock.net/supporting-legacy-browsers-and-samesite-cookies-without-useragent-sniffing-in-aspnetcore/" target="_blank">
                <h2 class="title mb-6" id="article-663">Supporting legacy browsers and SameSite cookies without UserAgent sniffing in ASP.NET Core.</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 13, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I explore one way to get ASP.NET Core Identity SameSite cookies working with both legacy and modern browsers&#x2026;</p>
        </article>
        <article id="article-664">
            <a href="https://ayende.com/blog/199522-C/integer-compression-simd-bit-packing-and-unusual-usages" target="_blank">
                <h2 class="title mb-6" id="article-664">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 12, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I talked a bit before about the nature of bit packing and how the simdcomp library isn&#x2019;t actually doing compression. Why do I care about that, then?&#xA;Because the simdcomp library provides a very useful building block. A simple set of functions that allows you to very quickly pack and unpack bits. That is important, since those operations are fast enough that we can treat them as effectively free. Once that exists, we can now start finding interesting usages for those.&#xA;Let&#x2019;s assume that we have the following functions:&#xA;&#xA;Pack(Span&lt;uint&gt; input, Stream output, int bit);&#xA;Unpack(Stream input, Span&lt;uint&gt; output, int bit);&#xA;&#xA;It get a set of numbers and the number of bits and encode or decode them as needed.&#xA;Because those methods are&#xA0;fast, it means that we can play with various interesting designs. For example, let&#x2019;s take dictionary compression. Assume that we have a set of values, such as country names. This looks like this:&#xA;&#xA;[ &quot;United States&quot;, &quot;China&quot;, &quot;Japan&quot;, &quot;India&quot;, &quot;United States&quot;, &quot;Brazil&quot;, &quot;Germany&quot;, &quot;India&quot;, &quot;France&quot;, &quot;China&quot;, &quot;Japan&quot;, &quot;Brazil&quot;, &#x2026; ]&#xA;&#xA;This array contains thousands or millions of entries. We want to encode that in an efficient manner, how can we do that? Here is a simple way to utilize the speed of bit-packing to do something useful:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void Encode(List&lt;string&gt; countries, Stream output)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var nums = new List&lt;int&gt;();&#xA;        &#xA;        &#xA;          &#xA;              var dic = new Dictionary&lt;string, int&gt;();&#xA;        &#xA;        &#xA;          &#xA;              foreach (var country in countries)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if(dic.TryGetValue(country, out var index) == false)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      dic[country] = index = dic.Count;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  nums.Add(index);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var bits = 32 - BitOperations.LeadingZeroCount((uint)dic.Count);&#xA;        &#xA;        &#xA;          &#xA;              var br = new BinaryWriter(output);&#xA;        &#xA;        &#xA;          &#xA;              br.Write(dic.Count);&#xA;        &#xA;        &#xA;          &#xA;              foreach(var country in dic.Keys)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  br.Write(country);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              br.Write(nums.Count);&#xA;        &#xA;        &#xA;          &#xA;              Pack(nums, output, bits);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          DictionaryCompression.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What is going on here?&#xA;&#xA;We first iterate over the set of countries, finding the unique names and giving an index for each one of them.&#xA;Along the way, we produce an integer array of the indexes of country names.&#xA;Then we compute the maximum number of bits that we have to use to store those indexes.&#xA;To the output, we write the number of unique country names, the names themselves and then the bit-packed set of indexes.&#xA;&#xA;Let&#x2019;s assume that we have 30 unique values in this list, but the list itself is 5 million items in size. What is the actual cost here?&#xA;We&#x2019;ll assume an average country name of 8 bytes, to make the math easy. That means that to store the list of countries would cost us 38MB, if we did that using the most obvious approach.&#xA;Using the code above, assuming 30 unique values, we&#x2019;ll have 5 million values with 5 bits each, leading to a total cost of about 3MB, instead of 38MB.&#xA;The nice thing about this approach is that once you have fast bit-packing routines, you can now start using them in all sorts of interesting ways.&#xA;The reason I talked about the topic before starting to discuss FastPFor is that it makes a lot more sense to understand how bit-packing can be applied separately from FastPFor, since that is just making interesting use of the capability.</p>
        </article>
        <article id="article-665">
            <a href="https://www.meziantou.net/using-rclone-to-backup-onedrive-or-google-drive.htm" target="_blank">
                <h2 class="title mb-6" id="article-665">Using rclone to backup OneDrive or Google Drive</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 12, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you have important files, you need to backup them before it&#x27;s too late. Cloud drives, such as OneDrive, Google Drive, or pCloud, are great for this. However, this is not the perfect solution. And you may want to have another copy of your data.rclone is a free tool that can synchronize a local di</p>
        </article>
        <article id="article-666">
            <a href="https://ayende.com/blog/199521-C/talk-scalable-architecture-from-the-ground-up" target="_blank">
                <h2 class="title mb-6" id="article-666">Talk</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 09, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20"></p>
        </article>
        <article id="article-667">
            <a href="https://ayende.com/blog/199491-B/integer-compression-using-simd-bit-packing-in-practice" target="_blank">
                <h2 class="title mb-6" id="article-667">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 08, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the last post, I talked about how the simdcomp library is actually just doing bit-packing. Given a set of numbers, it will put the first N bits in a packed format. That is all. On its own, that isn&#x2019;t very useful, we have to pair it with something else to make it do something more interesting.&#xA;Previously, I talked about delta compression, what if we put both of those together?&#xA;Given a sorted list of numbers, we&#x2019;ll compute the delta between the numbers, then we can figure out how many bits we need to store them, and we can pack that tightly.&#xA;Analyzing the sample posting list I&#x2019;m using, we get the following batches (of 128 numbers each)&#xA;&#xA;328 batches at 13 bits&#xA;11 batches at 22 bits&#xA;7 batches at 23 bits&#xA;3 batches as 27 bits&#xA;1 batch at 31 bits&#xA;1 batch at 28 bits&#xA;&#xA;Doing the math, we can fit all of those using 77Kb or so.&#xA;The idea is that for each batch, we can use simdpack() to write just the relevant bits. We&#x2019;ll need some extra metadata to keep track of the number of bits per batch, but that is just one byte per every 128 values. For that matter, we can bit-pack that as well .&#xA;Note that in this case, we are using the simd packing routines just for bit packing. The actual compression aspect comes not from the packing, but from computing the deltas and then figuring out how densely we can pack those values.&#xA;This approach is called Frame Of Reference (FOR), and it has some really nice advantages. By splitting the data into blocks, we can take advantage of the patterns in the data. Here are the first 16 deltas in the posting list:&#xA;&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA;&#xA;&#xA;Value&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA;&#xA;&#xA;Bits&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[0]&#xA;&#xA;&#xA;1871143144&#xA;&#xA;&#xA;31&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[1]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[2]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[3]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[4]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[5]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[6]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[7]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[8]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[9]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[10]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[11]&#xA;&#xA;&#xA;7984&#xA;&#xA;&#xA;13&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[12]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[13]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[14]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA;[15]&#xA;&#xA;&#xA;4&#xA;&#xA;&#xA;3&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;Let&#x2019;s assume that the batch size is 4 numbers, what would be the numbers here? Basically, we take the max number of bits for each batch of 4 numbers.&#xA;The first block will require us to use 31 bits, the second would be just 3 bits, but the third would require 13 bits and the last is 3 bits again.&#xA;The idea is that for each block, we have a separate frame of reference, the number of bits that are required for us to record &amp; retrieve the data.&#xA;Of course, if you&#x2019;ll look at the data itself, we are wasting quite a lot of space here needlessly. There are just two numbers (0, 11) that require more than 3 bits.&#xA;There is an algorithm called Patched Frame Of Reference (PFor) that handles this. Basically, when we compute a batch, we&#x2019;ll record it using 3 bits only in this case. What about the rest of the values? Those we&#x2019;ll store outside the batch, as an exception. On reading, we&#x2019;ll need to patch the data to make it whole.&#xA;That adds a bit of complexity, but it also means that you can compress the data a lot more densely.&#xA;In the next post, I&#x2019;m going to be talking about FastPFor, which combines simd bit packing, patched frame of references and some really clever tricks to get a very interesting integer compression algorithm.</p>
        </article>
        <article id="article-668">
            <a href="https://ayende.com/blog/199490-B/integer-compression-understanding-simd-compression-by-lemire" target="_blank">
                <h2 class="title mb-6" id="article-668">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 07, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I showed how you can use integer compression using variable-size integers. That is a really straightforward approach for integer compression, but it isn&#x2019;t ideal. To start with, it means that we take at least one byte for each number, but in many cases, especially if we are using delta encoding, we can pack things a lot more tightly. For reference, here are the first 15 records we have in the posting list I&#x2019;m using for testing, delta encoded:&#xA;&#xA;1871143144 4 4 4 4 4 4 4 4 4 4 7984 4 4 4&#xA;&#xA;See the range of 4, repeating. Each one of them can be represented by 3 bits, but we&#x2019;ll waste 32 &#x2013; 64 bits to hold it.&#xA;When you are searching for data on &#x201C;database stuff&#x201D;, the building blocks that are being used to build databases, you&#x2019;ll usually find Lemire there. In this case, I would like to talk about the SimdComp library. From the GitHub repository:&#xA;&#xA;A simple C library for compressing lists of integers using binary packing and SIMD instructions. This library can decode at least 4 billion of compressed integers per second on most desktop or laptop processors.&#xA;&#xA;Those are some really nice numbers, but I actually have a pet peeve with the name of the library. It isn&#x2019;t actually doing compression, what it does is bit packing, which is something quite different.&#xA;Bit packing just takes numbers that are 32 bits in length and stores them using fewer bits.&#xA0; For example, let&#x2019;s consider the following list: 1,2,3,4,5,6,7,8,9,10. If I would store that in 32 bits integers, that would take 40 bytes. But given that the maximum size is 10, I can use 4 bits integers, instead. Taking only 5 bytes.&#xA;The core of the library is this set of routines:&#xA;&#xA;simdpack()&#xA;simdpackwithoutmask()&#xA;simdunpack()&#xA;&#xA;All of them have roughly the same structure, something like this:&#xA;&#xA;&#xA;&#xA;This switch statement goes on for 32 bits. Each time selecting a different function. This code makes a lot of assumptions. You&#x2019;ll always give it exactly an input of 128 numbers and it will pack them and write them to output. The idea is to be as compact as you possibly can.&#xA;Reading this code is.. a challenge, because there is so much mental weight behind it, or so it seems. For example, take a look at how we pack a set of numbers into 2-bit integers:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static void __SIMD_fastpack2_32(const uint32_t *_in, __m128i *out) {&#xA;        &#xA;        &#xA;          &#xA;            const __m128i *in = (const __m128i *)(_in);&#xA;        &#xA;        &#xA;          &#xA;            __m128i OutReg;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            const __m128i mask = _mm_set1_epi32((1U &lt;&lt; 2) - 1);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            __m128i InReg = _mm_and_si128(_mm_loadu_si128(in), mask);&#xA;        &#xA;        &#xA;          &#xA;            OutReg = InReg;&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(&#x2B;&#x2B;in), mask);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(&#x2B;&#x2B;in), mask);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;            OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));&#xA;        &#xA;        &#xA;          &#xA;            InReg = _mm_and_si128(_mm_loadu_si128(&#x2B;&#x2B;in), mask);&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            // redacted&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          __SIMD_fastpack2_32.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The actual code goes on for quite a while (104 of dense SIMD code), so let&#x2019;s try to break it up a bit. If we&#x2019;ll translate this from SIMD to scalar, we&#x2019;ll have code like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          uint mask = (1u &lt;&lt; 2) -1;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var input = *in&#x2B;&#x2B; &amp; mask;&#xA;        &#xA;        &#xA;          &#xA;          var output = input;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          input = *in&#x2B;&#x2B; &amp; mask;&#xA;        &#xA;        &#xA;          &#xA;          output |=  input &lt;&lt; 2;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          input = *in&#x2B;&#x2B; &amp; mask;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          output |=  input &lt;&lt; 4;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          scalar.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;If you are used to manipulating bits, it&#x2019;s fairly straightforward. We start by setting the output to the first value, then the second value was shifted by 2 bits and added to the value, then the third value was shifted by 4 bits, etc.&#xA;With SIMD, the interesting part is that we aren&#x2019;t operating on a single value, but 4 at a time. That also means that we have a difference in how the data actually end up being packed.&#xA;Given a list of values from 1 .. 16, bit packing them will usually result in the data looking like this:&#xA;&#xA;In contrast, the SIMD bit packing model will store the data like so:&#xA;&#xA;This is a result of operating on 4 items at a time, but in practice, the actual placement of the bits does not matter much, just that we are able to store and retrieve them.&#xA;Note that for packing, we have two options, one that uses a mask and the other that does not. That will be important later. The only difference between those options is whether&#xA0;a mask is applied before we splice the bits into the output, nothing else.&#xA;The reason I said that this isn&#x2019;t compression is that this library is focused solely on packing the bits, it has no behavior / concept beyond that stage. In the next post, we&#x2019;ll start looking into how we can make use of this in more interesting ways.</p>
        </article>
        <article id="article-669">
            <a href="https://ayende.com/blog/199489-B/integer-compression-delta-encoding-variable-size-integers" target="_blank">
                <h2 class="title mb-6" id="article-669">Integer compression</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 06, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you are building a database, the need to work with a list of numbers is commonplace. For example, when building an index, we may want to store all the ids of documents of orders from Europe.&#xA;You can just store the raw values, of course, but that can be incredibly wasteful in terms of disk space, memory bandwidth and performance. Consider a database where millions of orders are from Europe. We&#x2019;ll need multiple megabytes just to store the document ids. We can utilize patterns in the numbers to reduce the total storage size. For example, if you are storing a list of sorted numbers, you can store the delta of the numbers, instead of the whole value. The delta tends to be much smaller, after all. Take a look at the following code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static void DeltaEncode(List&lt;long&gt; sortedList)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (sortedList.Count == 0)&#xA;        &#xA;        &#xA;          &#xA;                  return;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long prev = sortedList [0];&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 1; i &lt; sortedList.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  long current = sortedList [i];&#xA;        &#xA;        &#xA;          &#xA;                  sortedList [i] = current - prev;&#xA;        &#xA;        &#xA;          &#xA;                  prev = current;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          static void WriteListToStream(List&lt;long&gt; deltas, Stream outputStream)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              BinaryWriter writer = new BinaryWriter(outputStream);&#xA;        &#xA;        &#xA;          &#xA;              foreach (var num in deltas)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  writer.Write7BitEncodedInt64(num);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          delta_encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This will generate (in place) delta for the sorted list. We can then write it to a stream, using 7-bit integer (also called variable size integers) encoding. This way, smaller numbers take less space, which is the point of first doing delta encoding.&#xA;For testing purposes, I have a list of 44,956 items, which looks like this (full list is here):&#xA;&#xA;&#xA;&#xA;&#xA;1871143144&#xA;&#xA;&#xA;&#xA;&#xA;1871143148&#xA;&#xA;&#xA;&#xA;&#xA;1871143152&#xA;&#xA;&#xA;&#xA;&#xA;1871143156&#xA;&#xA;&#xA;&#xA;&#xA;1871143160&#xA;&#xA;&#xA;&#xA;&#xA;1871143164&#xA;&#xA;&#xA;&#xA;&#xA;1871143168&#xA;&#xA;&#xA;&#xA;&#xA;1871143172&#xA;&#xA;&#xA;&#xA;&#xA;1871143176&#xA;&#xA;&#xA;&#xA;&#xA;1871143180&#xA;&#xA;&#xA;&#xA;&#xA;Note that I&#x2019;m using int64, so if we would store the data as is, it would take ~351KB. Using delta encoding, we can pack that into just ~45Kb.&#xA;I care a lot more about the decoding of the values, so let&#x2019;s see how we read it back, shall we?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static List&lt;long&gt; ReadListFromStream(Stream inputStream)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var nums = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;              var reader = new BinaryReader(inputStream);&#xA;        &#xA;        &#xA;          &#xA;              while (reader.BaseStream.Position &lt; reader.BaseStream.Length)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  nums.Add(reader.Read7BitEncodedInt64());&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return nums;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          static void DeltaDecode(List&lt;long&gt; list)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 1; i &lt; list.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  list[i] = list[i - 1] &#x2B; list[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          delta_decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;With very little code, we can gain quite a jump in information density. That is quite good. For reference purposes, taking the same data and compressing it using GZip would cost us ~58KB, so significantly more than this simpler mechanism.&#xA;On the other hand, using GZip on the delta encoded list will put us under 8KB. This is because in this context, there is a great deal of repetition in the data, there are many runs that are exactly 4 values apart from one another, so we can get quite a good compression ratio out of this.&#xA;That does require that we&#x2019;ll have patterns in the data, which is by no means a guarantee. There is a whole field out there of research into integer compression, since it is such an important aspect of how database internals are working.&#xA;In this series, I&#x2019;m going to focus on detailing how we implemented FastPFor inside of RavenDB, what we learned along the way and what the final results were.</p>
        </article>
        <article id="article-670">
            <a href="https://andrewlock.net/understanding-samesite-cookies/" target="_blank">
                <h2 class="title mb-6" id="article-670">Understanding SameSite cookies</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 06, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I discuss SameSite cookies, what they are, why they&#x27;re useful, and the limitations when you use them.&#x2026;</p>
        </article>
        <div class="button flex justify-between">
            <a href="66.html"><span class="back arrow"></span></a>

            <a href="68.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>

<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;🚀&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="about.html"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="/pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>
