
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 97 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-961">
            <a href="https://ayende.com/blog/196066-C/implementing-a-file-pager-in-zig-reading-from-the-disk" target="_blank">
                <h2 class="title mb-6" id="article-961">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 11, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We have finally gotten to the point where we can ask the pager for a page of data (reminder, a page in this case is 8KB of data) and get it back. Here is what this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var page = try pager.getPage(&amp;tx.loadedChuncks, 2, 1, tx.timeout);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There are a few things to note here. There is a new concept here, the transaction. We don&#x2019;t want to have that concept at the pager level, so we just pass the relevant state to the pager to deal with. Basically, any transaction we&#x2019;ll have will need to have a bit of state for the pager to deal with it. The state we need at this point is minimal, just the list of chunks that are referenced by the pager. You can also see that we provide a timeout for the getPage() call. What is that about?&#xA;This leads to the second concern we need to consider. How are we expected to run this? If we call getPage() on a page (actually, a chunk containing this page) that isn&#x2019;t resident in memory, we&#x2019;ll need to go to the disk to read it. That can take a while, sometimes a long while. At a glance, that is one of those things that async/await was meant for. Since Zig supports async functions, that is certainly something that we can do, but it is something that I want to be cautious about. Having explicit blocking is far easier to understand and debug, at least for now. This is especially true if we&#x2019;ll want to consume the pager API from a non Zig target.&#xA;That leads to an interesting issue, however. If a call to getPage() can block, how can we avoid blocking the thread. In most cases, we would like to avoid blocking, after all. It would be simple to have tryGetPage() method, which will not block (but schedule the load of the page from disk), and then maybe register for a notification for that. If that sounds like async to you, that is because it is. The problem with this sort of approach is that you need to suspend execution somewhere in the middle of a transaction operation and continue when the data is loaded. Without async/await, you can&#x2019;t really do that. Well, I mean, you could try, but we have a lot of experience with trying to manage state via callbacks, that isn&#x2019;t really going to work for anything beyond the simplest systems (see: node.js without async/await).&#xA;There is one thing that we can do that would be both simple and effective, however: we can error if the page isn&#x2019;t in memory. That sounds like a pretty bad idea, no? How would that help us?&#xA;Well, the concept is simple. If a transaction attempts to access a page that isn&#x2019;t resident in memory, we&#x2019;ll do the following operations:&#xA;&#xA;Schedule the chunk the page resides on to load into memory.&#xA;Return an error from the pager&#xA;Rollback the transaction&#xA;Keep the loadedChunks for that transaction active and wait for the chunk to be loaded&#xA;Re-run the transaction again, now the chunk is in memory and we can proceed further&#xA;&#xA;Each time that we re-run the transaction, we make sure that the chunks it needs are in memory, eventually ensuring that all the required chunks are resident and we don&#x2019;t need to block.&#xA;At the same time, the code to work with the transactions is not going to care about blocking, etc. We need to do the usual error handling, but that is required anyway. There is a single location where we need to deal with callbacks from the pager, so there is a limited blast radius of complexity. For write transactions, for example, this is a very reasonable strategy. We assume that there is only a single thread writing at a given time. A transaction being blocked because it needs to read a page from the disk can stall other pending transactions. By having it abort and retry later, we can keep the line moving. For read operations, on the other hand, that is likely not something that you want to do. If I&#x2019;m already streaming results to the caller, I can&#x2019;t just repeat the transaction.&#xA;I&#x2019;m not making any decisions at this point, just considering the various options and implications that we have to deal with at this early level.&#xA;Now, let&#x2019;s look at how the getPage() is actually implemented, shall we?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn getPage(self: *Pager, loadedChunks: *ChunksSet, page: u64, count: u32, timeout: ?u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              var chunk = page / FileChunks.PagesInChunk;&#xA;        &#xA;        &#xA;          &#xA;              var end = (page &#x2B; count) / FileChunks.PagesInChunk;&#xA;        &#xA;        &#xA;          &#xA;              // we ensure that any range is always within a single file...&#xA;        &#xA;        &#xA;          &#xA;              // we ensure that any range is always within a single file...&#xA;        &#xA;        &#xA;          &#xA;              var fileNum = page / FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;              var file = self.files[fileNum] orelse return error.FileIsNotLoaded;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.loadChunksToTransaction(loadedChunks, file, chunk, end, timeout);&#xA;        &#xA;        &#xA;          &#xA;              if (loadedChunks.get(chunk) != null) {&#xA;        &#xA;        &#xA;          &#xA;                  // explicitly go beyond the scope of the chunk, because we know the proper memory layout&#xA;        &#xA;        &#xA;          &#xA;                  // and if the size exceed a single chunk, we already loaded the next one(s)&#xA;        &#xA;        &#xA;          &#xA;                  var ptr = file.chunks.ptr.ptr;&#xA;        &#xA;        &#xA;          &#xA;                  var pageInFile = page % FileChunks.PagesInFile;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (@ptrToInt(ptr &#x2B; ((pageInFile &#x2B; count) * FileChunks.PageSize)) &gt; file.chunks.ptrEnd) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.PageRequestIsOutOfBand;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var slice = ptr[(pageInFile * FileChunks.PageSize)..((pageInFile &#x2B; count) * FileChunks.PageSize)];&#xA;        &#xA;        &#xA;          &#xA;                  return slice;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return error.ChunkWasNotLoaded;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getPage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is a lot that is going on here, I know. We start by defining a set (a hash map using a 64 bits unsigned integer to a zero-sized value). The way this works with Zig is quite elegant, since we pay no memory cost for the values here.&#xA;The majority of the work is done in the loadChunksToTransaction() function, which we&#x2019;ll examine shortly, but you can see some interesting details already in getPage(). We assume that we have a page loaded, and any range of pages that we ask is always within a single page.&#xA;The call to load the chunks actually puts them in the loadedChuncks argument. We verify that we loaded the chunk properly and then we create a slice to return for the caller. Note that we may request more than a single page and it is valid to ask for a range that contains multiple chunks. We validate that the range we return is within the memory range for the current file, we ensured that the chunks for a specific file are consecutive in memory, so we can safely return this pointer across multiple chunks without needing to think about it.&#xA;There is another aspect of loadedChunks that we need to discuss. A transaction may use multiple pages from the same chunk, but we only need to load the chunk once. At the same time, we can avoid adding a reference to the chunk multiple times for each loaded page. When we close the transaction, we need to release the reference for these chunks, so we need to keep track of those. With that in mind, let&#x2019;s see how we actually load the chunks to memory.&#xA;As a reminder, we have two actors working together here. The FileChunks is used to store the chunks in memory and the PagerRing is used for parallel I/O.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn scheduleLoadingChunks(self: *Pager, loadedChunks: *ChunksSet, file: *PagerFile, start: u64, end: u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              while (start &lt;= end) : (start &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  if (loadedChunks.get(start) != null) {&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var chunkInFile = (start % FileChunks.ChunksInFile);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var maybeBuffer = file.chunks.tryGet(chunkInFile) catch |err| switch (err) {&#xA;        &#xA;        &#xA;          &#xA;                      error.ValueIsLoading =&gt; continue, // someone else is loading this, will get later&#xA;        &#xA;        &#xA;          &#xA;                      else =&gt; return err,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  if (maybeBuffer != null) {&#xA;        &#xA;        &#xA;          &#xA;                      // a buffer exists, and we own a ref to it now, record it...&#xA;        &#xA;        &#xA;          &#xA;                      try recordChunk(file, loadedChunks, start);&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      try self.reserveMemoryBudgetForChunk();&#xA;        &#xA;        &#xA;          &#xA;                      errdefer self.releaseChunkMemoryBudget();&#xA;        &#xA;        &#xA;          &#xA;                      // if null, someone else is loading...&#xA;        &#xA;        &#xA;          &#xA;                      maybeBuffer = file.chunks.markLoading(chunkInFile) catch |err| switch (err) {&#xA;        &#xA;        &#xA;          &#xA;                          error.ValueAlreadyExists =&gt; continue, // someone else is loading...&#xA;        &#xA;        &#xA;          &#xA;                          else =&gt; return err,&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (maybeBuffer) |buffer| {&#xA;        &#xA;        &#xA;          &#xA;                      // now need to load it...&#xA;        &#xA;        &#xA;          &#xA;                      var state = try self.allocator.create(AsyncLoadChunkState);&#xA;        &#xA;        &#xA;          &#xA;                      errdefer self.allocator.destroy(state);&#xA;        &#xA;        &#xA;          &#xA;                      state.* = .{ .chunk = chunkInFile, .file = file, .parent = self };&#xA;        &#xA;        &#xA;          &#xA;                      try self.ring.submit(.{&#xA;        &#xA;        &#xA;          &#xA;                          .tag = .Read,&#xA;        &#xA;        &#xA;          &#xA;                          .fd = file.fd,&#xA;        &#xA;        &#xA;          &#xA;                          .buffer = buffer,&#xA;        &#xA;        &#xA;          &#xA;                          .offset = chunkInFile * FileChunks.ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                          .context = @ptrToInt(state),&#xA;        &#xA;        &#xA;          &#xA;                          .result = .{ .bytes = 0, .err = null },&#xA;        &#xA;        &#xA;          &#xA;                          .callback = completeLoad,&#xA;        &#xA;        &#xA;          &#xA;                      });&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn loadChunksToTransaction(self: *Pager, loadedChunks: *ChunksSet, file: *PagerFile, start: u64, end: u64, timeout: ?u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              try self.scheduleLoadingChunks(loadedChunks, file, start, end);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              // now we actually load the chunks to the transaction&#xA;        &#xA;        &#xA;          &#xA;              var currentGlobalChunk = start;&#xA;        &#xA;        &#xA;          &#xA;              while (currentGlobalChunk &lt;= end) : (currentGlobalChunk &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  if (loadedChunks.get(currentGlobalChunk) != null) {&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var chunkInFile = (currentGlobalChunk % FileChunks.ChunksInFile);&#xA;        &#xA;        &#xA;          &#xA;                  // we&#x27;ll wait until we have the buffer&#xA;        &#xA;        &#xA;          &#xA;                  _ = try file.chunks.getBlocking(chunkInFile, timeout);&#xA;        &#xA;        &#xA;          &#xA;                  try recordChunk(file, loadedChunks, currentGlobalChunk);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          loadChunksToTransaction.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;That is a lot of code to throw at you, I know, let&#x2019;s dissect it in detail. In this method, we are working on chunks, not pages, and we assume that we may have multiple chunks, that is why we have the while loops. We start by checking if the chunk is already loaded in the transactions&#x2019; loadedChunks. If it isn&#x2019;t, we compute the position of the chunk in the file (the chunk number we get from the caller is the global one, after all) and try to get it from the FileChunks. This is where things get interesting.&#xA0; When we call tryGet() for the current chunk, we may get an error because of two possible scenarios:&#xA;&#xA;The value is currently being loaded from the disk (some other transaction asked for it, probably). We don&#x2019;t need to do anything further other than wait for it to show up.&#xA;Another transaction tried to load it, but got an error. At this point we just return the error. We don&#x2019;t try to do anything special here. In general, there may be a lot of errors to consider here. We may have temporary I/O issue, or run out of memory or something that is transient. Or we may have an actual problem at hand (bad sector on disk, corrupted data, etc). Regardless of what we are doing, we aren&#x2019;t going to try to do any error handling here. We&#x2019;ll just record the error and any future attempt to access that chunk will also error. The proper way to recover at this point is to restart the pager. This is assuming we have the other components of a database at play here. So we&#x2019;ll re-run the journal files, apply recovery, etc. In short, any I/O issues like that are critical errors and require a restart of the system to come back to a known state.&#xA;&#xA;If the tryGet() method returned without an error, there are still two options to consider. The call may have returned a value (so we called addRef() on the chunk internally), we can simply add that to the chunks we own and move on. If there isn&#x2019;t a value in memory, things start to get interesting. At this point we call markLoading(). We are basically racing to be the owners for loading this chunk. If we are successful in this race, we&#x2019;ll get the buffer back from the FileChunks and can schedule reading the relevant chunk from the disk. You&#x2019;ll note that we are setting the callback to completeLoad, we&#x2019;ll look into that shortly. If we aren&#x2019;t successful (we didn&#x2019;t get a buffer back), then some other thread was able to get the buffer and will schedule the read for us, so we are done.&#xA;After we either ensured that all the chunks are loaded or scheduled them to be loaded, we use getBlocking() to wait for all the relevant chunks to be available. Once that is done, we can safely return and getPage() will complete the process, as we saw earlier.&#xA;The only thing that we have to look at is the completeLoad function, which is about as basic as you can get:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn completeLoad(work: *PagerRing.Work) void {&#xA;        &#xA;        &#xA;          &#xA;              var state = @intToPtr(*AsyncLoadChunkState, work.context);&#xA;        &#xA;        &#xA;          &#xA;              defer state.parent.allocator.destroy(state);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var err: ?anyerror = null;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (work.result.err) |e| {&#xA;        &#xA;        &#xA;          &#xA;                  state.file.chunks.markLoadError(state.chunk, e) catch |e2| {&#xA;        &#xA;        &#xA;          &#xA;                      err = e2;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              } else {&#xA;        &#xA;        &#xA;          &#xA;                  _ = state.file.chunks.markLoaded(state.chunk) catch |e3| {&#xA;        &#xA;        &#xA;          &#xA;                      err = e3;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (err) |e| {&#xA;        &#xA;        &#xA;          &#xA;                  std.log.err(&quot;Ownership violation for chunk: {}, file: {}.&quot; &#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                      &quot; Got error: {} when handling state {} &quot;, .{&#xA;        &#xA;        &#xA;          &#xA;                      state.chunk,&#xA;        &#xA;        &#xA;          &#xA;                      state.file,&#xA;        &#xA;        &#xA;          &#xA;                      e,&#xA;        &#xA;        &#xA;          &#xA;                      work.result.err,&#xA;        &#xA;        &#xA;          &#xA;                  });&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          completeLoad.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Most of the function is about error handling. We register either the fact that we got an error reading from the disk or that we completed the load process and maybe log something. In general, there isn&#x2019;t really much that we need to do here. The act of calling markLoaded() will release any threads waiting on getBlocking(), after all. So the whole thing comes together quite nicely.&#xA;With this done, we are mostly done on the reading side of the pager and this post as well. In my next post, I want to discuss how we should handle eviction of data. So far, we are just reading into memory, never releasing. We need to take care of that as well, of course. Once that is done, we can move to the wonderful topic of handling writes and durability&#x2026;</p>
        </article>
        <article id="article-962">
            <a href="https://ardalis.com/2021-year-in-review/" target="_blank">
                <h2 class="title mb-6" id="article-962">2021 Year in Review</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 11, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Time for a recap of stats and important (and not so important) milestones from 2021, the SECOND year of the COVID-19 pandemic (yeah we&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-963">
            <a href="https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/" target="_blank">
                <h2 class="title mb-6" id="article-963">Finding a type declaration&#x27;s namespace and type hierarchy</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 11, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 5</p>
        </article>
        <article id="article-964">
            <a href="https://ayende.com/blog/196065-C/implementing-a-file-pager-in-zig-managing-the-list-of-files" target="_blank">
                <h2 class="title mb-6" id="article-964">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 10, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This is my 7th post in this series, and we are now starting to get into the really interesting bits. So far we worked with the individual components, each of them doing just one thing, which makes it hard to see how they are all put together. In this post, we are going to start plugging things together.&#xA;As a reminder, the whole point of this series of posts is to explore what we need to do in order to ask for a page (8KB, in our case) from the data file and work with it in memory.&#xA0; We have most of everything ready, let&#x2019;s put them back together. The first thing that we need to do is actually tie a file to the FileChunks structure that we previously created. This is as simple as this structure:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          const PagerFile = struct {&#xA;        &#xA;        &#xA;          &#xA;              chunks: *FileChunks,&#xA;        &#xA;        &#xA;          &#xA;              fd: std.os.fd_t,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn init(allocator: std.mem.Allocator, file: []const u8) !PagerFile {&#xA;        &#xA;        &#xA;          &#xA;                  var chunks = try FileChunks.init(allocator);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer chunks.deinit();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var fd = try std.os.open(&#xA;        &#xA;        &#xA;          &#xA;                      file,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.O.RDWR | std.os.O.CREAT | std.os.O.CLOEXEC | std.os.O.DIRECT | std.os.O.DSYNC,&#xA;        &#xA;        &#xA;          &#xA;                      std.os.S.IRUSR | std.os.S.IWUSR,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return PagerFile{&#xA;        &#xA;        &#xA;          &#xA;                      .chunks = chunks,&#xA;        &#xA;        &#xA;          &#xA;                      .fd = fd,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn deinit(self: *PagerFile) void {&#xA;        &#xA;        &#xA;          &#xA;                  self.chunks.deinit();&#xA;        &#xA;        &#xA;          &#xA;                  std.os.close(self.fd);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PagerFile.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We are simply initializing the FileChunks and opening the file, nothing else. Remember that a single pager is going to be responsible for multiple files. Furthermore, all the data structures that we are dealing with now are meant for concurrent use. That means that we should be prepared for this type of code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // on thread #1&#xA;        &#xA;        &#xA;          &#xA;          try pager.addFile(&quot;/data/orders/data.003&quot;);&#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;          // on thread #2&#xA;        &#xA;        &#xA;          &#xA;          try pager.getPage(&amp;tx.owned,2034, 32, 15 * std.time.us_in_s);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          concurrent.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;When we use a managed language, that is actually fairly simple to work with. In an unmanaged language, those two lines of code are tough. Why is that? Let&#x2019;s look at the raw data members for the Pager structure, shall we?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const Pager = struct {&#xA;        &#xA;        &#xA;          &#xA;              allocator: std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;              ring: *PagerRing,&#xA;        &#xA;        &#xA;          &#xA;              files: []PagerFile,&#xA;        &#xA;        &#xA;          &#xA;              filesCapacity: usize,&#xA;        &#xA;        &#xA;          &#xA;              pendingFree: PagerFileList,&#xA;        &#xA;        &#xA;          &#xA;              const PagerFileList = std.ArrayListUnmanaged([]PagerFile);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Pager.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Of particular interest to us is the files member. This is the list of files that are being managed by the pager. Each one of them has a maximum size of 8GB in size. The problem is that we may have one thread accessing the list at the same time that another thread wants to increase its size. How would that work?&#xA;The simplest option is that we&#x2019;ll reallocate the array, but that will move it. What would the first thread be doing in that scenario? The good thing from our point of view is that we don&#x2019;t need to worry about concurrent modifications. There is only a single thread that is allowed to modify the Pager&#x2019;s state at any given point in time.&#xA;Trying to find solutions for this problem leads into a rabid rabbit&#x2019;s hole. You go into hazard pointers, epoch GC and other fun stuff. Also, the call to getPage() is one of the most important ones in a database, anything that we can do to reduce its cost will be done. As such, we can&#x2019;t typically use any form of locking. A reader/writer lock can be a killer. Here is a good example for how that can happen.&#xA;I thought about how to resolve this, and I decided against a generic solution, instead, let&#x2019;s look at the actual behavior that we need. The files array is going to be accessed a lot, it has an entry per 8GB of disk space that we take. That means that it isn&#x2019;t going to be experiencing any rapid growth. It is also only going to grow. We also need to worry only when we grow the physical backing store for this array, if we overprovision and use less than we need, that is perfectly fine. Each element in the array is 8 bytes in size, so if we allocate a single memory page (4KB) we can store 512 file references in it. That represents 4 TB(!) of data, so we can probably just accept the additional cost and allocate it and not think about it.&#xA;Databases with &gt; 4TB of disk size do exist, and we don&#x2019;t want to have this artificial limit on us, do we? Instead, we can use another approach. We&#x2019;ll start by allocating the array with a minimum size of 8 elements (sufficient until you get to 64GB). But what happens when we reach that size?&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn addFile(self: *Pager, file: []const u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              // caller holds a write lock, we don&#x27;t care about readers, they can follow&#xA;        &#xA;        &#xA;          &#xA;              // either new or old pointers and are guarantee to only access the old range&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (self.files.len &#x2B; 1 &gt;= self.filesCapacity) {&#xA;        &#xA;        &#xA;          &#xA;                  var nextCapacity = self.filesCapacity * 2;&#xA;        &#xA;        &#xA;          &#xA;                  var newFiles = try self.allocator.alloc(PagerFile, nextCapacity);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer self.allocator.free(newFiles);&#xA;        &#xA;        &#xA;          &#xA;                  try self.pendingFree.append(self.allocator, newFiles);&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(PagerFile, newFiles, self.files);&#xA;        &#xA;        &#xA;          &#xA;                  self.files.ptr = newFiles.ptr;&#xA;        &#xA;        &#xA;          &#xA;                  self.filesCapacity = nextCapacity;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var cur = self.files.len;&#xA;        &#xA;        &#xA;          &#xA;              self.files.len &#x2B;= 1;&#xA;        &#xA;        &#xA;          &#xA;              self.files[cur] = try PagerFile.init(self.allocator, file);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          addFile.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What we do here is cheat. We don&#x2019;t need to free the memory immediately, when we reach the limit of the size of the array, we&#x2019;ll double its size, copy the data that we have and register it to be freed when we close the Pager. At that point, the caller already needs to ensure that there are no other users of the pager.&#xA;Because we copy the values from the old array, but keep it around, old readers may use the old or new arrays, but we don&#x2019;t actually care. The memory remains valid and accessible. In terms of wasted space, if our database went from a single file to being 128 TB in one run, we&#x2019;ll have an array with 16,384 elements (whose size is 128KB). Along the way, we had to double the size of the array a dozen times and we &#x201C;waste&#x201D; 128KB of unused buffers. This seems like a pretty reasonable cost to significantly reduce the level of complexity of concurrent access. Using this method, we can avoid any sort of synchronization on the read side. That is certainly a plus.&#xA;Here are the init() and deinit() calls for the Pager, to complete the picture:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: std.mem.Allocator, capacity: usize) !*Pager {&#xA;        &#xA;        &#xA;          &#xA;              var self = try allocator.create(Pager);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.destroy(self);&#xA;        &#xA;        &#xA;          &#xA;              self.allocator = allocator;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.filesCapacity = std.math.max(8, nextPowerOfTwo(capacity));&#xA;        &#xA;        &#xA;          &#xA;              var files = try allocator.alloc(PagerFile, self.filesCapacity);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(files);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.pendingFree = try PagerFileList.initCapacity(allocator, 1);&#xA;        &#xA;        &#xA;          &#xA;              errdefer self.pendingFree.deinit(allocator);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.ring = try PagerRing.init(allocator);&#xA;        &#xA;        &#xA;          &#xA;              errdefer self.ring.deinit();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.pendingFree.append(allocator, files);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              self.files = files;&#xA;        &#xA;        &#xA;          &#xA;              self.files.len = 0; // no values yet...&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn deinit(self: *Pager) void {&#xA;        &#xA;        &#xA;          &#xA;              for (self.files) |*file| {&#xA;        &#xA;        &#xA;          &#xA;                  file.deinit();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              while (self.pendingFree.popOrNull()) |toFree| {&#xA;        &#xA;        &#xA;          &#xA;                  self.allocator.free(toFree);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.pendingFree.deinit(self.allocator);&#xA;        &#xA;        &#xA;          &#xA;              self.ring.deinit();&#xA;        &#xA;        &#xA;          &#xA;              self.allocator.destroy(self);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Pager.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, we allocate a PagerRing for the pager, which will deal with the actual I/O. The actual disposal of the files array is managed using the pendingFree list. That is a small cost to pay, to reduce the cost of adding a new file. In the deinit() routine, note that there is a distinction between releasing the files themselves (where we close the FilesChunk, release the relevant memory, close the file handle, etc) and releasing the arrays that hold the files themselves.&#xA;I&#x2019;m quite pleased with how this turned out, zero cost for reads (important) and negligible memory cost for most scenarios).&#xA;In my next post, I&#x2019;ll get started with actually reading the data from disk and putting that in the pager. So far, that is a 7 post series, and we haven&#x2019;t completed the first part. That simple scenario is surprisingly tricky.</p>
        </article>
        <article id="article-965">
            <a href="https://www.meziantou.net/using-http-3-quic-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-965">Using HTTP/3 (QUIC) in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 10, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">#What&#x27;s HTTP/3?HTTP/3 is a new version of HTTP. HTTP/3 protocol is supported by most modern browsers and servers. This update should bring performance benefits mostly for mobile users or unreliable connections. The main idea is to replace TCP by a new protocol, QUIC, which removes some issues of TC</p>
        </article>
        <article id="article-966">
            <a href="https://ayende.com/blog/196033-A/teaching-learning-and-tearing-your-hair-out" target="_blank">
                <h2 class="title mb-6" id="article-966">Teaching, learning and tearing your hair out</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 06, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">One of my favorite activities is teaching. I love explaining how things work and passing on knowledge. Another good way to pass the time is to learn, which can be a source of great joy and incredible frustration.&#xA;Recently I had a conversation with a university student in the Computer Science track talking about databases. As you might imagine, that is a topic that is near and dear to my heart, so I had a lot of interest in hearing from the student what kind of databases they have been exposed to and what impression they had on them.&#xA;The student in question was familiar with MySQL from his courses and had run into PostgreSQL in some job interviews. He was very much in the PostgreSQL camp, that isn&#x2019;t an uncommon reaction, but the reason for that was interesting to me. In his course, they had to setup and configure MySQL from scratch. That was annoying and hard, especially since they used the command line to make queries to the database.&#xA;In the PostgreSQL case, however, he was given access to a web front end to the database and was assigned tasks to complete. They could get started right away doing the most important aspects of their task.&#xA;When I&#x2019;m teaching, part of the job is data dump (here are the things you need to know), part of the job is to answer questions, make sure that they understand the material, etc. A crucial part of teaching is getting the students to do things, making sure that the students are actually exercising the new knowledge. In such cases, I noted that I provide them with the baseline and they need to complete just the parts that are missing, the core pieces.&#xA;That is pretty much the same thing that the student ran into during their interview.&#xA;In retrospect, for teaching, I think that this approach is a serious issue.&#xA;One of the most important hurdles that I see for new developers is their ability to deal with problems. Whether&#xA0;it is actually reading the errors, composing some mental model for what is going on or just being able to dig deeper and understand what is happening. I&#x2019;m not talking about experience, mind. I&#x2019;m talking about the approach. If most of the tasks that they have dealt with so far were ones which were &#x201C;fill the missing pieces&#x201D;, they are likely never had the experience of dealing with everything else. And in many cases, the issues aren&#x2019;t in the areas that you are thinking, they can be somewhere else completely.&#xA;I remember many times where I had to do something, and I ran into a wall. That was incredibly frustrating, especially when the issue was somewhere completely orthogonal to what I&#x2019;m trying to do. A great example recently was having to figure out how to do cross compilation in GitHub action using GCC. That took a lot of time and all I wanted to do is to just call a single function from native code.&#xA;As frustrating as that is, I think that there is a huge amount of value in those kinds of &#x201C;side quests&#x201D;. That is especially true when someone is in the early stages of their career. Those are just the sort of hurdles that can teach you not only what is going on at your level but about the ecosystem in general and the layers beneath you.&#xA;A great example of lack of such knowledge is a candidate in an interview recently that was asked: &#x201C;Given a static HTML page and a domain name that was registered, what do you need to setup a website for that page in that domain?&#x201D; The candidate had no idea what was actually involved (nothing about DNS, routing, servers, etc). They were likely able to write an application using modern practices, but everything about pushing to production, what is a website, what is a domain name or IPs&#x2026; nope.&#xA;And that makes sense, they never had even run into something like that.&#xA;On the other hand, I remember building websites using FTP and Apache / IIS in the 90s. It wasn&#x2019;t fun, but I had very little abstraction to deal with and was exposed to the working of the engine.&#xA;And that sort of thing matters, because you will need to understand details such as DNS propagation times and its impact on what your system is doing, for example.</p>
        </article>
        <article id="article-967">
            <a href="https://ayende.com/blog/196001-A/implementing-a-file-pager-in-zig-reading-writing-from-the-disk" target="_blank">
                <h2 class="title mb-6" id="article-967">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 05, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After implementing the memory management in the previous post, I set out to handle the actual I/O primitives that we need. As a reminder, we are separating the concerns here. We managed memory and reference counting in the previous post and now I want to focus on how we can read and write from the disk in as efficient a manner as possible. Before we get to the guts of the code, I want to explain a bit about the environment that I have in mind. Most of the time, the pager is able to provide the requested page from memory directly. If it can&#x2019;t do that, it needs to consider the fact that there may be multiple threads that are trying to load that page.&#xA0; At the same time, while we are loading the page, we want to be free to do other things as well.&#xA;I decided to implement the I/O routine using async I/O. Here is the rough sketch of the API I have in mind:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const BackgroundRing = struct {&#xA;        &#xA;        &#xA;          &#xA;              const IoRingQueueSize = 32;&#xA;        &#xA;        &#xA;          &#xA;              const WorkReqStack = std.atomic.Stack(Work);&#xA;        &#xA;        &#xA;          &#xA;              pub const CallbackFn = fn (*Work) void;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub const Work = struct {&#xA;        &#xA;        &#xA;          &#xA;                  tag: enum { Read, Write },&#xA;        &#xA;        &#xA;          &#xA;                  fd: std.os.fd_t,&#xA;        &#xA;        &#xA;          &#xA;                  buffer: []u8,&#xA;        &#xA;        &#xA;          &#xA;                  offset: u64,&#xA;        &#xA;        &#xA;          &#xA;                  context: u64,&#xA;        &#xA;        &#xA;          &#xA;                  result: struct {&#xA;        &#xA;        &#xA;          &#xA;                      bytes: u64,&#xA;        &#xA;        &#xA;          &#xA;                      err: ?i32,&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;                  callback: CallbackFn,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              allocator: std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;              event_fd: i32,&#xA;        &#xA;        &#xA;          &#xA;              worker: std.Thread,&#xA;        &#xA;        &#xA;          &#xA;              background_error: ?anyerror,&#xA;        &#xA;        &#xA;          &#xA;              pending: WorkReqStack,&#xA;        &#xA;        &#xA;          &#xA;              running: bool,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn init(allocator: std.mem.Allocator) !*BackgroundRing {&#xA;        &#xA;        &#xA;          &#xA;                  var self = try allocator.create(FileRing);&#xA;        &#xA;        &#xA;          &#xA;                  errdefer allocator.destroy(self);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  self.allocator = allocator;&#xA;        &#xA;        &#xA;          &#xA;                  self.pending = WorkReqStack.init();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  self.event_fd = try std.os.eventfd(0, 0);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  self.running = true;&#xA;        &#xA;        &#xA;          &#xA;                  self.worker = try std.Thread.spawn(.{}, background_worker_wrapper, .{self});&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return self;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn deinit(self: *BackgroundRing) void {&#xA;        &#xA;        &#xA;          &#xA;                  self.running = false;&#xA;        &#xA;        &#xA;          &#xA;                  @fence(.Acquire);&#xA;        &#xA;        &#xA;          &#xA;                  self.wake_worker() catch {};&#xA;        &#xA;        &#xA;          &#xA;                  self.worker.join();&#xA;        &#xA;        &#xA;          &#xA;                  while (self.pending.pop()) |node| {&#xA;        &#xA;        &#xA;          &#xA;                      self.allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  std.os.close(self.event_fd);&#xA;        &#xA;        &#xA;          &#xA;                  self.allocator.destroy(self);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn submit(self: *BackgroundRing, work: Work) !void {&#xA;        &#xA;        &#xA;          &#xA;                  var ptr = try self.allocator.create(WorkReqStack.Node);&#xA;        &#xA;        &#xA;          &#xA;                  ptr.data = work;&#xA;        &#xA;        &#xA;          &#xA;                  self.pending.push(ptr);&#xA;        &#xA;        &#xA;          &#xA;                  try self.wake_worker();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              fn background_worker_wrapper(self: *BackgroundRing) void {&#xA;        &#xA;        &#xA;          &#xA;                  self.background_worker() catch |err| {&#xA;        &#xA;        &#xA;          &#xA;                      self.background_error = err;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              fn background_worker(self: *BackgroundRing) !void {&#xA;        &#xA;        &#xA;          &#xA;                  while (self.running) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.wait_for_work();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      while (self.pending.pop()) |node| {&#xA;        &#xA;        &#xA;          &#xA;                          const bytes = switch (node.data.tag) {&#xA;        &#xA;        &#xA;          &#xA;                              .Read =&gt; std.os.pread(node.data.fd, node.data.buffer, node.data.offset),&#xA;        &#xA;        &#xA;          &#xA;                              .Write =&gt; std.os.pwrite(node.data.fd, node.data.buffer, node.data.offset),&#xA;        &#xA;        &#xA;          &#xA;                          } catch |err| val: {&#xA;        &#xA;        &#xA;          &#xA;                              node.data.result.err = @errorToInt(err);&#xA;        &#xA;        &#xA;          &#xA;                              break :val 0;&#xA;        &#xA;        &#xA;          &#xA;                          };&#xA;        &#xA;        &#xA;          &#xA;                          node.data.result.bytes &#x2B;= bytes;&#xA;        &#xA;        &#xA;          &#xA;                          if (bytes != 0 and bytes &lt; node.data.buffer.len) {&#xA;        &#xA;        &#xA;          &#xA;                              node.data.offset &#x2B;= bytes;&#xA;        &#xA;        &#xA;          &#xA;                              node.data.buffer = node.data.buffer[bytes..];&#xA;        &#xA;        &#xA;          &#xA;                              self.pending.push(node); // retry...&#xA;        &#xA;        &#xA;          &#xA;                              continue;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          node.data.callback(&amp;node.data);&#xA;        &#xA;        &#xA;          &#xA;                          self.allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              fn wake_worker(self: *BackgroundRing) !void {&#xA;        &#xA;        &#xA;          &#xA;                  var w: u64 = 1;&#xA;        &#xA;        &#xA;          &#xA;                  _ = try std.os.write(self.event_fd, std.mem.asBytes(&amp;w));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              fn wait_for_work(self: *BackgroundRing) !void {&#xA;        &#xA;        &#xA;          &#xA;                  var val: u64 = undefined;&#xA;        &#xA;        &#xA;          &#xA;                  _ = try std.os.read(self.event_fd, std.mem.asBytes(&amp;val));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          BackgroundRing.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is simple, we use a struct to which we can submit work in an asynchronous manner. At some later point in time, the work will complete and our read or write will be done. At that point we&#x2019;ll be able to invoke the provided callback for the user. The code above is about as simple as you can manage, it spawns a dedicated thread to manage the I/O and then just issues those operations directly. To save myself some headache, I&#x2019;m using an eventfd as a synchronization mechanism, I don&#x2019;t strictly need this, but it will be useful down the road.&#xA;In terms of the API, I can now write the following code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var file = try std.fs.openFileAbsolute(filename, .{ .write = true, .read = true });&#xA;        &#xA;        &#xA;          &#xA;          defer file.close();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          try ring.submit(.{&#xA;        &#xA;        &#xA;          &#xA;              .tag = .Read,&#xA;        &#xA;        &#xA;          &#xA;              .buffer = &amp;buffer,&#xA;        &#xA;        &#xA;          &#xA;              .offset = 0,&#xA;        &#xA;        &#xA;          &#xA;              .fd = file.handle,&#xA;        &#xA;        &#xA;          &#xA;              .context = @ptrToInt(&amp;waiter),&#xA;        &#xA;        &#xA;          &#xA;              .callback = handle_completion,&#xA;        &#xA;        &#xA;          &#xA;              .result = .{ .bytes = 0, .err = null },&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          usage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The basic idea is that the BackgroundRing struct doesn&#x2019;t manage file descriptors or buffers. It is a strict way to manage I/O. The API is pretty piss poor as well, in terms of usability. No one will ever want to write generic I/O routines using this method, but we aren&#x2019;t trying to do generic I/O, we are trying to ensure usability in a very constrained manner, inside the pager.&#xA;About the only nice thing that we do in this implementation is handle partial reads and writes. If we were asked to read more than what we got, we&#x2019;ll repeat the operation until we get to the end of the file or succeed.&#xA;In terms of implementation, as well, this is a really bad idea. We look like we are doing async I/O, but we are actually just passing it all to a background thread that will do the work off a queue. That means that it will be very hard to make full use of the hardware capabilities. But I think that you can guess from the name that I&#x2019;m not going to leave things like that. I&#x2019;m going to use the new io_uring API in Linux to handle most of those concerns. That idea is that we&#x2019;ll allocate a command buffer in the kernel and allow the kernel to handle asynchronous execution of the I/O operations. We still retrain the same rough structure, in that we are going to have a dedicated background thread to manage the commands, however. Amusing enough, the io_uring API is meant to be used from a single thread, since otherwise you&#x2019;ll need to orchestrate writes to the ring buffer from multiple providers, which is much harder than a single consumer, single producer scenario.&#xA;The use of io_uring is also why we are using the eventfd model. We are registering that file descriptor in the io_uring so it will let us know when event completes. This also does double duty as the method that we can use to wake the background thread when we have more work for it to do. The most major change is inside the background worker, of course. Here is how this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn background_worker(self: *PagerRing) !void {&#xA;        &#xA;        &#xA;          &#xA;              var cqes = std.mem.zeroes([IoRingQueueSize]std.os.linux.io_uring_cqe);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              while (self.running) {&#xA;        &#xA;        &#xA;          &#xA;                  try self.wait_for_work();&#xA;        &#xA;        &#xA;          &#xA;                  var shouldWake: bool = false;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  while (self.pending.pop()) |node| {&#xA;        &#xA;        &#xA;          &#xA;                      const op = switch (node.data.tag) {&#xA;        &#xA;        &#xA;          &#xA;                          .Read =&gt; IO_Uring.read,&#xA;        &#xA;        &#xA;          &#xA;                          .Write =&gt; IO_Uring.write,&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                      _ = op(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.ring,&#xA;        &#xA;        &#xA;          &#xA;                          @ptrToInt(node),&#xA;        &#xA;        &#xA;          &#xA;                          node.data.fd,&#xA;        &#xA;        &#xA;          &#xA;                          node.data.buffer,&#xA;        &#xA;        &#xA;          &#xA;                          node.data.offset,&#xA;        &#xA;        &#xA;          &#xA;                      ) catch |e| switch (e) {&#xA;        &#xA;        &#xA;          &#xA;                          error.SubmissionQueueFull =&gt; {&#xA;        &#xA;        &#xA;          &#xA;                              self.pending.push(node);&#xA;        &#xA;        &#xA;          &#xA;                              shouldWake = true;&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                          },&#xA;        &#xA;        &#xA;          &#xA;                          else =&gt; {&#xA;        &#xA;        &#xA;          &#xA;                              self.allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                              return e;&#xA;        &#xA;        &#xA;          &#xA;                          },&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  _ = self.ring.submit() catch |err| switch (err) {&#xA;        &#xA;        &#xA;          &#xA;                      error.CompletionQueueOvercommitted =&gt; shouldWake = true,&#xA;        &#xA;        &#xA;          &#xA;                      error.SignalInterrupt =&gt; shouldWake = true,&#xA;        &#xA;        &#xA;          &#xA;                      else =&gt; return err,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  // now let&#x27;s process the completed values&#xA;        &#xA;        &#xA;          &#xA;                  const n = try self.ring.copy_cqes(cqes[0..], 0);&#xA;        &#xA;        &#xA;          &#xA;                  for (cqes[0..n]) |cqe| {&#xA;        &#xA;        &#xA;          &#xA;                      var node = @intToPtr(*WorkReqStack.Node, cqe.user_data);&#xA;        &#xA;        &#xA;          &#xA;                      if (cqe.res &gt; 0 and cqe.res &lt; node.data.buffer.len) {&#xA;        &#xA;        &#xA;          &#xA;                          // partial operation, need to resubmit&#xA;        &#xA;        &#xA;          &#xA;                          var bytes = @intCast(usize, cqe.res);&#xA;        &#xA;        &#xA;          &#xA;                          node.data.buffer = node.data.buffer[bytes..];&#xA;        &#xA;        &#xA;          &#xA;                          node.data.offset &#x2B;= bytes;&#xA;        &#xA;        &#xA;          &#xA;                          node.data.result.bytes &#x2B;= bytes;&#xA;        &#xA;        &#xA;          &#xA;                          self.pending.push(node);&#xA;        &#xA;        &#xA;          &#xA;                          shouldWake = true;&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      defer self.allocator.destroy(node);&#xA;        &#xA;        &#xA;          &#xA;                      if (cqe.res &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;                          node.data.result.err = -cqe.res;&#xA;        &#xA;        &#xA;          &#xA;                      } else {&#xA;        &#xA;        &#xA;          &#xA;                          node.data.result.bytes &#x2B;= @intCast(usize, cqe.res);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      node.data.callback(&amp;node.data);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (shouldWake) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.wake_worker();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Ring.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We create&#xA0; the ring in the init function (see full code listing below) and in the background thread we are simply waiting for an event using the eventfd. When a caller submits some work, we&#x2019;ll register that on the io_uring and wait for it to complete (also using the eventfd). You can see that I&#x2019;m handling some basic states (partial reads, full queues, etc). The code itself ends up being pretty small. Once we are done with the operation, we let the user know about the completion.&#xA;There are a few things here that are interesting to note. We are actually allowing interleaving of operations, so we may have many outstanding operations at any given point. We aren&#x2019;t trying to guarantee any kind of ordering between the operations, nor are we providing anything but the most bare bones interface for the caller. Even so, there is quite a bit of power in the manner in which we are working here. We need to complete a few more components first, and then we can bring it all together&#x2026;&#xA;Here is the full listing of the PagerRing code.&#xA0; In the next post, I want to focus on the actual overall pager, when we are managing multiple files and how we work with all of them together. In particular, we want to understand how we manage the memory budget across all of them.</p>
        </article>
        <article id="article-968">
            <a href="https://ardalis.com/what-are-abstractions-in-software-development/" target="_blank">
                <h2 class="title mb-6" id="article-968">What are Abstractions in Software Development</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 05, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Software developers deal with abstractions every day. But just what is an abstraction? There are differing definitions that can sometimes&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-969">
            <a href="https://ayende.com/blog/195969-A/implementing-a-file-pager-in-zig-rethinking-my-approach" target="_blank">
                <h2 class="title mb-6" id="article-969">Implementing a file pager in Zig</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 04, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After writing the post about handling chunk metadata, I started thinking about the overall approach. Both the method using compressed pointers and the baseline computation felt&#x2026; off to me. They were certainly workable, but it was too complex and felt fragile.&#xA;I don&#x2019;t like dealing with a high level of complexity, I would rather put a lot of effort into simplifying the solution. The overall approach may be complex, but the system should be nice to work with. Usually, we can get away with a great deal of simplification if we accept some constraints on what we want to do with the system. For now, I&#x2019;m going to assume the following constraints:&#xA;&#xA;We are using 64 bits OS (and can assume effectively unlimited address space).&#xA;We want to go with a file pager (instead of the memory mapped one) because I want to be able to control the I/O behavior better.&#xA;The files we use are limited to 8 GB in size (can use more than a single file, of course).&#xA;&#xA;The last one deserves some additional words. When thinking about a storage solution, accepting a maximum size is generally a bad idea (640KB, anyone?). However, if we decide that our storage solution is going to be composed of files of specific size, we can combine them to reach any size needed.&#xA;But why accept this limitation? Why say that a single file will not exceed 8 GB? It turns out that this has several advantages.&#xA;Let&#x2019;s assume that we have a dataset that is 100GB in size, using 8 GB files, that would be 13 files to a total of 104 GB of used disk space. Now we want to delete some of that data. What do we do with the actual used disk space? It is actually quite hard to release disk space back to the operating system if you have a single file. You might need to run compaction of the data, or use advanced API such as hole punching (see FALLOC_FL_PUNCH_HOLE). Advanced API is something that I would like to avoid, too easy to fall into some pitfall that no one else has run into. Working with sparse files (with holes in them) also typically requires you to utilize dedicated tools and can be awkward.&#xA0; If we split the data into separate files, we can retain most of the same benefits, and give ourselves a simpler environment for the user to work with.&#xA;With the 8GB limitation in place, I can choose to manage the paging using the following manner:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const FileChunks = struct {&#xA;        &#xA;        &#xA;          &#xA;              pub const MaxFileSize = 8 * 1024 * 1024 * 1024; // 8 GB&#xA;        &#xA;        &#xA;          &#xA;              pub const ChunkSize = 2 * 1024 * 1024; // 2 MB&#xA;        &#xA;        &#xA;          &#xA;              pub const MaxChunksInFile = MaxFileSize / ChunkSize; // 4096&#xA;        &#xA;        &#xA;          &#xA;              pub const PageSize = 8 * 1024; // 8 KB&#xA;        &#xA;        &#xA;          &#xA;              pub const PagesInChunk = ChunkSize / PageSize; // 256&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub const ChunkMetadata = packed union {&#xA;        &#xA;        &#xA;          &#xA;                  pub const Tag = enum(u2) {&#xA;        &#xA;        &#xA;          &#xA;                      Empty = 0b00,&#xA;        &#xA;        &#xA;          &#xA;                      Error = 0b01,&#xA;        &#xA;        &#xA;          &#xA;                      Loading = 0b10,&#xA;        &#xA;        &#xA;          &#xA;                      Value = 0b11,&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  raw: u64,&#xA;        &#xA;        &#xA;          &#xA;                  futex: packed struct {&#xA;        &#xA;        &#xA;          &#xA;                      value: u32, // tag &amp; version&#xA;        &#xA;        &#xA;          &#xA;                      references: u32, // ignored&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;                  v: packed struct {&#xA;        &#xA;        &#xA;          &#xA;                      version: u30,&#xA;        &#xA;        &#xA;          &#xA;                      tag: Tag,&#xA;        &#xA;        &#xA;          &#xA;                      // references == 0 - this is unused&#xA;        &#xA;        &#xA;          &#xA;                      // references == 1 - just the pager is holding this&#xA;        &#xA;        &#xA;          &#xA;                      // refereces  &gt;= 2 - external entity is holding this&#xA;        &#xA;        &#xA;          &#xA;                      references: u32,&#xA;        &#xA;        &#xA;          &#xA;                  },&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              comptime {&#xA;        &#xA;        &#xA;          &#xA;                  if (@sizeOf(ChunkMetadata) != @sizeOf(u64)) {&#xA;        &#xA;        &#xA;          &#xA;                      @compileError(&quot;ChunkMetadata should be exactly 64 bits in length&quot;);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              chunks: [MaxChunksInFile]ChunkMetadata,&#xA;        &#xA;        &#xA;          &#xA;              ptr: []align(mem.page_size) u8,&#xA;        &#xA;        &#xA;          &#xA;              allocator: mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FileChunks.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is pretty simple. Instead of trying to stitch together the memory for the file, we are going to just allocate a single 8GB range of virtual memory. This can be done using the following command:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var ptr = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;              null,&#xA;        &#xA;        &#xA;          &#xA;              MaxFileSize,&#xA;        &#xA;        &#xA;          &#xA;              os.PROT.NONE,&#xA;        &#xA;        &#xA;          &#xA;              os.MAP.ANONYMOUS | os.MAP.PRIVATE,&#xA;        &#xA;        &#xA;          &#xA;              -1,&#xA;        &#xA;        &#xA;          &#xA;              0,&#xA;        &#xA;        &#xA;          &#xA;          );&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          mmap.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This reserves (but does not use) 8GB of address space. We can now allocate ranges from that safely. This is important because if we have a request to two sequential chunks, they will reside in memory right next to one another. Note that we also don&#x2019;t need to handle any pointers, since we can rely on a stable base address for the whole file. The nice thing about this is that we aren&#x2019;t actually allocating memory, just reserving it.&#xA;Let&#x2019;s see how that will work? The chunks array is used to control references to the chunks in the file. The chunk metadata is a 64 bits value that has several responsibilities at the same time. It stores the tag of a chunk, which indicate its status (loaded, error, empty, etc) and the number of outstanding references to the chunk. That uses up 34 bits in the value, the rest of the bits are used as a version field, which is incremented on each change. That allows us to avoid the ABA problem. The actual data, of course, is managed using the ptr value.&#xA;Here is how we can get a chunk from this struct:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn tryGet(self: *FileChunks, chunk: u64) !?[]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.getTag()) {&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; return null,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return @intToError(@intCast(u16, copy.v.references)),&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; return error.ValueIsLoading,&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef();&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      var offset = chunk * ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                      return self.ptr[offset..(offset &#x2B; ChunkSize)];&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          tryGet.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What we are doing here is checking that the value is loaded to memory, and if it is, we increment the reference and then return it. This code runs in a loop, because we assume that multiple threads may run it in the same time. This handles just getting data that is already loaded. If the data isn&#x2019;t loaded, what will happen? We&#x2019;ll get a null back. Here is the blocking version of this method:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn getBlocking(self: *FileChunks, chunk: u64, timeout: ?u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var maybechunk = self.tryGet(chunk) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;                      if (e == error.ValueIsLoading) {&#xA;        &#xA;        &#xA;          &#xA;                          var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                          if (copy.getTag() == .Empty) {&#xA;        &#xA;        &#xA;          &#xA;                              try self.chunks[chunk].wait(copy, timeout);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      return e;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  if (maybechunk) |c| {&#xA;        &#xA;        &#xA;          &#xA;                      return c;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  return error.ValueIsNotLoading;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          getBlocking.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Just based on those two methods, you should be able to draw some conclusions. If the value isn&#x2019;t loaded, we&#x2019;ll always return null, but there is this Loading stage as well, in that case, we may want to wait for it. How is that going to work?&#xA;This works using two important functions: markLoading() and markLoaded(), the idea is that we&#x2019;ll first try to call tryGet() to load a chunk, if there is no value, we need to load it from disk. At that point, remember, there may be multiple threads accessing the relevant chunk. So all of them would be competing on the markLoading function, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn markLoading(self: *FileChunks, chunk: u64) !?[]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; return error.ValueAlreadyExists,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return error.ValueInErrorState,&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; return null, // already marked..&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  copy.setTag(.Loading);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      var offset = chunk * ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                      const c = self.ptr[offset..(offset &#x2B; ChunkSize)];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      _ = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;                          c.ptr,&#xA;        &#xA;        &#xA;          &#xA;                          ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                          os.PROT.READ | os.PROT.WRITE,&#xA;        &#xA;        &#xA;          &#xA;                          os.MAP.ANONYMOUS | os.MAP.PRIVATE | os.MAP.FIXED,&#xA;        &#xA;        &#xA;          &#xA;                          -1,&#xA;        &#xA;        &#xA;          &#xA;                          0,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      return c;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          markLoading.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The code itself is pretty simple, we are updating the tag of the chunk and try to update it optimistically. We are moving the state of the chunk from Empty to Loading in a thread safe manner. If we are successful in doing so, we know that we are the only thread that owns the loading portion of the chunk. Note that part of the markLoading process is to ask the OS to give us the memory for the chunk (in the range that we previously allocated).&#xA;At this point, we can load the data from disk somehow and then we&#x2019;ll call the markLoaded function, which completes the process:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn markLoaded(self: *FileChunks, chunk: u64) ![]align(mem.page_size) u8 {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[chunk];&#xA;        &#xA;        &#xA;          &#xA;                  var origin = copy;&#xA;        &#xA;        &#xA;          &#xA;                  switch (copy.v.tag) {&#xA;        &#xA;        &#xA;          &#xA;                      .Value =&gt; return error.ValueAlreadyExists,&#xA;        &#xA;        &#xA;          &#xA;                      .Error =&gt; return error.ValueInErrorState,&#xA;        &#xA;        &#xA;          &#xA;                      .Empty =&gt; return error.ValueIsNotLoading,&#xA;        &#xA;        &#xA;          &#xA;                      .Loading =&gt; {},&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  copy.setTag(.Value);&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef(); // ownership by the pager&#xA;        &#xA;        &#xA;          &#xA;                  try copy.addRef(); // ownership by the caller&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[chunk].tryUpdate(origin, copy)) {&#xA;        &#xA;        &#xA;          &#xA;                      return self.getLoadedChunk(chunk);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          markLoaded.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea is that we are splitting the responsibility for managing the chunks references from how we load the data to memory.&#xA;In other words, the expected usage of this struct is something like this:&#xA;&#xA;Call tryGet() a page in a given chunk.&#xA;If successful, do the work you wanted to do.&#xA;If not successful, compete to be the loader for this data by calling markLoading().&#xA;If you lost, call getBlocking() to wait for the winner to get the data.&#xA;Somehow, load the data from the disk and call markLoaded().&#xA;Proceed to make use of the data.&#xA;&#xA;Another important aspect that we have to deal with is when we want to discard the data. Basically, if we filled our memory budget and we need to load a value from the disk, what can we do then? The answer is that we need to evict the data somehow, before we can do that, we need to know what data is currently in use. That is why we have the calls to addRef() and release(). We use those (using atomic operations) to track the usage of the various chunks. When we need to evict data from memory, we&#x2019;ll need to have some sort of a policy to do so. I&#x2019;m deferring the actual policy to a later point in time, right now I want to discuss how do we know what we can evict and how that is going to work.&#xA;Here is the code to handle eviction, currently implementing a policy of simple scanning (not ideal by a long shot):&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn tryClaimOwnership(self: *FileChunks, index: u64) ?ChunkMetadata {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var copy = self.chunks[index];&#xA;        &#xA;        &#xA;          &#xA;                  if (copy.mayReclaim() == false)&#xA;        &#xA;        &#xA;          &#xA;                      return null;&#xA;        &#xA;        &#xA;          &#xA;                  var modified = copy.reset(.Loading); // means that we own it for the duration...&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[index].tryUpdate(copy, modified))&#xA;        &#xA;        &#xA;          &#xA;                      return modified;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn trySetToEmpty(self: *FileChunks, index: u64) !void {&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var modified = self.chunks[index];&#xA;        &#xA;        &#xA;          &#xA;                  if (modified.getTag() != .Loading) {&#xA;        &#xA;        &#xA;          &#xA;                      // someone else modified it while we where releasing the memory&#xA;        &#xA;        &#xA;          &#xA;                      return error.ValueIsNotLoading;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var released = modified.reset(.Empty);&#xA;        &#xA;        &#xA;          &#xA;                  if (self.chunks[index].tryUpdate(modified, released))&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn reclaim(self: *FileChunks) !u64 {&#xA;        &#xA;        &#xA;          &#xA;              var reclaimed: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              var index: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (index &lt; self.chunks.len) : (index &#x2B;= 1) {&#xA;        &#xA;        &#xA;          &#xA;                  var modified: ChunkMetadata = undefined;&#xA;        &#xA;        &#xA;          &#xA;                  if (self.tryClaimOwnership(index)) |m| {&#xA;        &#xA;        &#xA;          &#xA;                      // at this point, m is owned by us, and no one else can use it...&#xA;        &#xA;        &#xA;          &#xA;                      modified = m;&#xA;        &#xA;        &#xA;          &#xA;                  } else {&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  reclaimed &#x2B;= ChunkSize;&#xA;        &#xA;        &#xA;          &#xA;                  _ = try os.mmap(&#xA;        &#xA;        &#xA;          &#xA;                      self.getLoadedChunk(index).ptr,&#xA;        &#xA;        &#xA;          &#xA;                      ChunkSize,&#xA;        &#xA;        &#xA;          &#xA;                      os.PROT.NONE,&#xA;        &#xA;        &#xA;          &#xA;                      os.MAP.ANONYMOUS | os.MAP.PRIVATE | os.MAP.FIXED,&#xA;        &#xA;        &#xA;          &#xA;                      -1,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.trySetToEmpty(index);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return reclaimed;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          eviction.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In the reclaim method, we are scanning through the chunks. To be able to reclaim a chunk, the following conditions need to hold:&#xA;&#xA;The chunk holds a value.&#xA;There are no outstanding references to the chunk, only the pager is holding a reference to the chunk.&#xA;&#xA;Note that in order to do this safely, we have to assume that while we are trying to reclaim a chunk, another thread is trying to use it. This behavior complicates our lives a bit. We handle that by doing&#xA0; a racy update of the chunk, trying to move it to a loading state. The idea is that the Loading state is meant to be used as a busy signal. While the chunk is in Loading state, the rest of the system knows that it cannot use this and needs to wait. Note that this means that we have the following transitions:&#xA;&#xA;Most of the code that we have in the struct is there to handle concurrency from multiple threads dealing with the system at once, note. The actual behavior is fairly simple. We check if we can reclaim the chunk (no one is looking), we take a lock on by trying to move its state to Loading. Then we can discard the memory by calling mmap on the chunk&#x2019;s memory with PROT_NONE.&#xA;For fun, we are using 2MB chunks because that fits well into huge pages. On a properly setup system, we can significantly reduce the paging metadata overhead inside the kernel by allocating a single 2MB page for each chunk.&#xA;You can see the entire implementation here. In the next post, I want to look into handling the I/O portion of reading the data from the disk. After that we&#x2019;ll talk about how we can implement a proper eviction policy.</p>
        </article>
        <article id="article-970">
            <a href="https://andrewlock.net/creating-a-source-generator-part-4-customising-generated-code-with-marker-attributes/" target="_blank">
                <h2 class="title mb-6" id="article-970">Customising generated code with marker attributes</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: January 04, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Creating a source generator - Part 4</p>
        </article>
        <div class="button flex justify-between">
            <a href="96.html"><span class="back arrow"></span></a>

            <a href="98.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>