
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 97 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-961">
            <a href="https://www.meziantou.net/finding-duplicate-documents-in-mongodb.htm" target="_blank">
                <h2 class="title mb-6" id="article-961">Finding Duplicate Documents in MongoDB</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 18, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Recently I needed to create a new unique index on a MongoDB collection. However, there were some duplicate data&#x2026; so I got the following error:copyE11000 duplicate key error collection: db.collection index: index_name dup key: { key: &quot;duplicate value&quot; }The error message lists the first duplicated va</p>
        </article>
        <article id="article-962">
            <a href="https://ayende.com/blog/195009-C/when-you-want-to-store-index-and-search-mbs-of-text-inside-of-ravendb" target="_blank">
                <h2 class="title mb-6" id="article-962">When you want to store, index and search MBs of text inside of RavenDB</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 15, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">A scenario came up from a user that was quite interesting to explore. Let&#x2019;s us assume that we want to put the Gutenberg Project inside of RavenDB. An initial attempt for doing that would look like this: I&#x2019;m skipping a lot of the details, but the most important field here is the Content field. That contains the actual text of the book.On last count, however, the size of the book was around 708KB. When storing that as a single field inside of RavenDB, on the other hand, RavenDB will notice that this is a long field and compress it. Here is what this looks like:The 738.55 KB is the size of the actual JSON, the 674.11 KB is after quick compression cycle and the 312KB is the actual size that this takes on disk. RavenDB is actively trying to help us.But let&#x2019;s take the next step, we want to allow us to query, using full text search, on the content of the book. Here is what this will look like:Everything works, which is great. But what is going on behind the scenes?Even a single text field that is large (100s of KB or many MB) puts a unique strain on RavenDB. We need to manage that as a single unit, it significantly bloats the size of the parent document and make it more expensive to work with. This is interesting because usually, we don&#x2019;t actually work all that much with the field in question. In the case of the Pride and Prejudice book, the content is immutable and not really relevant for the day to day work with the document. We are better off moving this elsewhere. An attachment is a natural way to handle this. We can move the content of the book to an attachment. In this way, the text is retained, we can still work and process that, but it is sitting on the side, not making our life harder on each interaction with the document. Here is what this looks like, note that the size of the document is tiny. Operations on that size would be much faster than a multi MB document:Of course, there is a disadvantage here, how can we index the book&#x2019;s contents now? We still want that. RavenDB support that scenario explicitly, let&#x2019;s define an index to do just that:You can see that I&#x2019;m loading the content attachment and then accessing its content as string, using UTF8 as the encoding mechanism. I tell RavenDB to use full text search on this field, and I&#x2019;m off to the races.Of course, we could stop here, but why? We can do even better. When working with large text fields, an index such as the one above will force us to materialize the entire field as a single value. For very large values, that can put a lot of pressure in terms of memory usage.But RavenDB supports more than that. Instead of processing a very large string in one shot, we can do that in an incremental fashion, avoiding big value materialization and the memory pressure associated with that. Here is what you can write:That tells RavenDB that we should process the field in a streaming fashion. Here is why it matters:&#xA;&#xA;&#xA;Value Materialized&#xA;Streaming Value&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;When we are working on a document that has a &lt; 1 MB attachment, it probably doesn&#x2019;t matter all that much (although using 25% of the memory is nice), but it matters a lot more when you are working with larger texts.We can take this one step further still! Instead of storing the attachment text as is, we can compress it, like so:And then in the index, we&#x2019;ll decompress on the fly:Note that throughout all of that, the queries that you send are exactly the same, we are just taking 20% of the disk space and 25% of the memory that we used to.</p>
        </article>
        <article id="article-963">
            <a href="https://ayende.com/blog/194977-A/a-pki-less-secure-communication-channel-using-tls" target="_blank">
                <h2 class="title mb-6" id="article-963">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 12, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After spending so much time building my own protocol, I decided to circle back a bit and go back to TLS itself and see if I can get the same thing for it that I make on my own. As a reminder, here is what we achieved:Trust established between nodes in the system via a back channel, not Public Key Interface. For example, I can have:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [&#xA;        &#xA;        &#xA;          &#xA;            {&#xA;        &#xA;        &#xA;          &#xA;              &quot;Name&quot;: &quot;orders.app&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;PublicKey&quot;: &quot;3xPJBNRzybdD2XhxCkO9e9L7cVrjAocPc00MwB2eyv8=&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;Access&quot;: [&#xA;        &#xA;        &#xA;          &#xA;                &quot;Orders&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Leads&quot;&#xA;        &#xA;        &#xA;          &#xA;               ]&#xA;        &#xA;        &#xA;          &#xA;            },&#xA;        &#xA;        &#xA;          &#xA;            {&#xA;        &#xA;        &#xA;          &#xA;              &quot;Name&quot;: &quot;shipping.app&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;PublicKey&quot;: &quot;UYnz8EeyEv9m2zs3w3X9Xifw4fMalv8YfgE/q4fo1Yc=&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;Access&quot;: [&#xA;        &#xA;        &#xA;          &#xA;                &quot;Shipping&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Products&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Customers&quot;&#xA;        &#xA;        &#xA;          &#xA;              ]&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          ]&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          authorizations.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;On the client side, I can define something like this:Server=northwind.database.local:9222;Database=Orders;Server Key=6HvG2FFNFIifEjaAfryurGtr&#x2B;ucaNgHfSSfgQUi5MHM=;Client Secret Key=daZBu&#x2B;vbufb6qF&#x2B;RcfqpXaYwMoVajbzHic4L0ruIrcw=Can we achieve this using TLS? On first glance, that doesn&#x2019;t seem to be possible. After all, TLS requires certificates, but we don&#x2019;t have to give up just yet. One of the (new) options for certificates is Ed25519, which is a key pair scheme that uses 256 bits keys. That is also similar to what I have used in my previous posts, behind the covers. So the plan is to do the following:Generate key pairs using Ed25519 as before.Distribute the knowledge of the public keys as before.Generate a certificate using those keys.During TLS handshake, trust only the keys who we were explicitly told to trust, disabling any PKI checks.That sounds reasonable, right?&#xA0; Except that I failed. To be rather more exact, I couldn&#x2019;t generate a valid X509 certificate from Ed25519 key pair. Using .NET, you can use the CertificateRequest class to generate certificates, but it only supports RSA and ECDsa keys. Safe sizes for those types are probably:RSA &#x2013; 4096 bits (2048 bits might also be acceptable) &#x2013; key size on disk: 2,348 bytes.ECDsa &#x2013; 521 bits&#xA0; - key size on disk: 223 bytes.The difference between those and the 32 bytes key for Ed25519 is pretty big. It isn&#x2019;t much in the grand scheme of things, for sure, but it matters. The key issue (pun intended) is that this is large enough to make it awkward to use the value directly. Consider the connection string I listed above. The keys we use here are small enough that we can just write them inline (simplest and most oblivious thing to do). The keys for either of the more commonly used RSA and ECDsa are too big for that. Here is a ECDsa key, for example:MIHcAgEBBEIBuF5HGV5342&#x2B;1zk1/Xus4GjDx&#x2B;FR&#xA;rbOPrC0Q&#x2B;ou5r5hz/49w9rg4l6cvz0srmlS4/Ysg&#xA;H/6xa0PYKnpit02assuGgBwYFK4EEACOhgYkDgYY&#xA;ABABaxs8Ur5xcIHKMuIA7oedANhY/UpHc3KX&#x2B;SKc&#xA;K&#x2B;NIFue8WZ3YRvh1TufrUB27rzgBR6RZrEtv6yuj&#xA;2T2PtQa93ygF761r82woUKai7koACQZYzuJaGYbG&#xA;dL&#x2B;DQQApory0agJ140T3kbT4LJPRaUrkaZDZnpLA&#xA;oNdMkUIYTG2EYmsjkTg==&#xA;And here is an RSA key:MIIJKAIBAAKCAgEApkGWJc&#x2B;Ir0Pxpk6affFIrcrRZgI8hL6yjXJyFNORJUrgnQUw&#xA;i/6jAZc1UrAp690H5PLZxoq&#x2B;HdHVN0/fIY5asBnj0QCV6A9LRtd3OgPNWvJtgEKw&#xA;GCa0QFofKk/MTjPimUKiVHT&#x2B;XgZTnTclzBP3aSZdsROUpmHs2h4eS9cRNoEnrC1u&#xA;YUzaGK4OeQNLCNi1LyB6I33697&#x2B;dNLVPoMJgfDnoDBV12KtpB6/pLjigYgIMwFx/&#xA;Qyx9DhnREXYst/CLQs8S/dmF&#x2B;opvghhdhiUUOUwqGA/mIIbwtnhMQFKWCQXEk7km&#xA;5hNg/fyv/qwqvTkqQTZkJdj0/syPNhqnZ9RurFPkiOwPzde8I/QwOkEoOXVMboh4&#xA;Ji3Y6wwEkWSwY/9rzUK2799lzTmZlvUu2ZxNZfKxQ84vmPUCvP288KXOCU4FxIUX&#xA;lujBu7aXUORtQE9oZxBSxqCSqmCEb7jGwR3JOpFlUZymK7W0jbY4rmfZL8vcDYdG&#xA;r0msuXD&#x2B;ggVjYzpHI7EH5MtQXYJZ2aKan5ZpSL/Lb0HsjkDLrsvMi&#x2B;72FcwXH&#x2B;5P&#xA;Q1E30uxs5y9xOTSqff9T9x6KPAOwIpmrv4Bc3J0NgEgWiKxG9nM1&#x2B;f8FkKlCRino&#xA;rrF9ZrC&#x2B;/l/vc67xye&#x2B;Pr1tLvEFT5ARu/nR1JH/Lv/CsAU9y51wOPqD6dQUCAwEA&#xA;AQKCAgBJseTWWcnitqFU8J62mM94ieCL8Q3WYZlP7Zz38lfySeCKeZRtWa/zsozm&#xA;XEQY0t7&#x2B;807pHPLs0OhMHlFv1GQKj09Wg4XvWWgqvLOSucC7QZ6cLfNUoUNhCxGp&#xA;dbnAKGuXN9wwx7NBBljl5V4Ruf//UgxRw7YuklWk0ZjoUSrGGDX3siOtaZ17Nxwf&#xA;NAB8qWKWwzSgquUmEH&#x2B;kr4HeZorSRfC/&#x2B;ntEUaa6y5T28g7Vosb4NYgLxJqiN3te&#xA;3B0yY6O3N4bZkyQ6TEblSdua7LCsPUCjbdi6LlZg664RDQqIcVATkwzVC14A95Mj&#xA;tjkzqzU5ttxpkmP21cHdX6847QcpERgQ7NzAbjrU5UH8aBOsetaZo/1yDr5U13ah&#xA;YcAq9XX6tLeAA0rUsnXKAWBQswtWIU0jXBuRRSE7xDXv&#x2B;82SWEoPqZMSAv77p&#x2B;uc&#xA;AeogN&#x2B;zzZPPet/AOERKLcGC9WoC/HT7q/H3zFAsRPoKY6qMfLFntdosc0lmRxvHv&#xA;b9NXBzKdDuOiUXhdRMhL5Yld8ivvHuwRnPfcZycplSFrA9E5xo/S3RQj&#x2B;Re9L0yR&#xA;8tNzjl&#x2B;lcgtk8Q0CSJl6eW2Fjja5ZrvDD8qL97&#x2B;WFqHR7LTTqZ7TmiT7u1MXW1Il&#xA;wTuccWCQ85BzxpRbyzPXLdsxMgPCmjicX/23&#x2B;srOXAk2z42bOQKCAQEAzM1Mocnd&#xA;w0uoETHZH0VX29WaKVqUAecGtrj&#x2B;YNujzmjLy2FPW10njgBfZgkVQETjFxUS9LBZ&#xA;xv/p6fCio3NgXh3q7O/kWLxojuR8JB7n4vxoKGBwinwzi1DHp37gzjp/gGdr4mG9&#xA;8b7UeFJY8ZPz0EoXcPr3TL&#x2B;69vOoLieti/Ou9W7HbpDHXYLKclFkJ0d/0AtDNaM7&#xA;kCNvI7HgC5JvCCOdGatmbB09kniQjtvE4Wh4vOg/TtH1KoKGXbC8JnjHNRjJtgqU&#xA;1mhbq36Eru8iOVME9jyHAkSPqphqeayEUdeP3C1Bc2xmrlxCQALZrAfH37ZWcf44&#xA;UuOO5TMnf5HTLwKCAQEAz9F59/xlVDHaaFpHK6ZRTQQWh6AVBDKUG2KDqRFAGQik&#xA;6YqQwJFGSo1Z&#x2B;FjXzidGEHkqH6KyGtSxS6dTgqqfTC96P1rdrBab5vgdXpfSa/0S&#xA;Qke2sH3eZ1vWJe95AD7AuVfsN/6IXIBHP5fWjXthGuo6U3vkkNjdjJGNxjfuMuug&#xA;SbxjjVV6kZI6gwX2gfTQDKUT&#x2B;yRjEnqGAyCcFeZXwWGryF1IseOFaNB2ATVKSqn9&#xA;oXI7AaI3ZRX3SyfOfyo3TaZEXabS1tfEg4JwIGNpx8WvRxb/X7WZi46be8u0ya4L&#xA;BDJ6ZIOBf7lpvaI1Dr3dzCuPqjGQ3V/xPwGy5D8&#x2B;CwKCAQEAuFVUUw6pjn0LIabX&#xA;QQEd6hzgq7X&#x2B;H5Q8A7yQIMewMTk7rKvCTH6U&#x2B;oe1VdZ5DSazqvPp4tjThXyTol9X&#xA;U3ymUS/mYiotQf0asvpODgjPOAttCGJ9CPhvQEaN3WEioBwg5IaxoMnOt8bF4CJm&#xA;MdG0ElaNsMACVE8BzgJS7nACEURcxkVWNVsURkNRSgGd/oipLqzkamOoWby67MrN&#xA;2DyNuSqs3QzbnBXZdHsVya9fDm8EtSroyF3Lp95hZ/SJ9KqiylSsQTBW9IBrefjf&#xA;HcDY8fWaMrMZ5V2mXarfsvInCq7VqhwFnAkGhos9ifXGy8MZEG9CcUmakmiFFiCr&#xA;vXOYOwKCAQADL9Yr/F3dbapIwWGoBLPod3CVAdpwpwnoZZlZRV9zQtOslShlG5U1&#xA;XXeMvGgKzEVhyUnhFFCg4rQZUeaQ8Wbh9zRrtkwB8JLRduqUYcWjTE00YP8nM7bu&#xA;ZNUi3cpAO7Ye4X9I2Ilkyb7N9dkfcE3r6L2ePB8kLX8wQacn7AGmHEDoAJCSQUZQ&#xA;5yooijXehk&#x2B;OchWdW1B9nw1hDOX33AFqgMHun6eWusN3&#x2B;QJmQFf0TykJicPn4YHx&#xA;9eVF7MVY49/XO/5&#x2B;ZSmEi&#x2B;iCj8SCaqPboWdvsqWV5SYGotg1jMkn8phOpyuDURTy&#xA;TXiWpN8la7n0AJMCbCIpkugTLEZ/A41DAoIBAAr73RhOZWDi40D6g&#x2B;Z2KLHMtLdn&#xA;xHMEkT0bzRZYlr0WGQpP/GPKJummDHuv/fRq2qXhML7yh7JK8JFxYU94fW2Ya1tx&#xA;lYa5xtcboQpBLfDvvvI4T4H1FE4kXeOoO46AtZ6dFZyg3hgKlaJkR&#x2B;pFPLr5Aeak&#xA;w9&#x2B;6UCK8v72esoKzCMxQzt3L2euYRt4zTKL3NnrgS7i5w56h2UvP1rDo3P0RVoqc&#xA;knS1ToamVL2JaPnf/g&#x2B;gUUVZyya9pyu9RP8MIcd1cvnxZec8JaN89WWnsA2JJbPw&#xA;stYBnWMvLFabPtPXVcsLrWMEmLFI2yn&#x2B;fU4YTviwRSs/SrprXDdsqZO2xd8=Note that in both cases, we are looking at the private key only. As you can imagine, this isn&#x2019;t really something viable. We will need to store that separately, load it from a file, etc. I tried generating Ed25519 keys using the built-in .NET API as well as the Bouncy Castle one. Bouncy Castle is a well known cryptographic library that is very useful. It also supports Ed25519. I spent quite some time trying to get it to work. You can see the code here. Unfortunately, while I&#x2019;m able to generate a certificate, it doesn&#x2019;t appear to be valid. Here is what this looks like:Using RSA, however, did generate viable certificates, and didn&#x2019;t take a lot of code at all:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static X509Certificate2 GenerateCertificate(string keyFile, string nmae)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            var rsa = RSA.Create(4096);&#xA;        &#xA;        &#xA;          &#xA;            var key = File.ReadAllBytes(keyFile);&#xA;        &#xA;        &#xA;          &#xA;            rsa.ImportRSAPrivateKey(key, out _);&#xA;        &#xA;        &#xA;          &#xA;            var req = new CertificateRequest(&quot;cn=&quot; &#x2B; nmae, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);&#xA;        &#xA;        &#xA;          &#xA;            var serverCertificate = req.CreateSelfSigned(DateTime.Today.AddDays(-1), DateTime.Today.AddYears(3));&#xA;        &#xA;        &#xA;          &#xA;            // yuck: https://github.com/dotnet/runtime/issues/23749&#xA;        &#xA;        &#xA;          &#xA;            return new X509Certificate2(serverCertificate.Export(X509ContentType.Pkcs12, (string) null), (string)null);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          temp_cert.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We store the actual key in a file, and we generate a self signed certificate on the fly. Great. I did try to use the ECDsa option, which generates a much smaller key, but I run into sever issues there. I could generate the key, but I couldn&#x2019;t use the certificate, I run into a host of issues around permissions, somehow. You can try to figure out more details from this issue, what I took from that is that in order to use ECDsa on Windows, I would need to jump through hoops. And I don&#x2019;t know if Ed25519 will even work or how to make it.As an aside, I posted the code to generate the Ed25519 certificates, if you can show me how to make it work, it would be great.So we are left with using RSA, with the largest possible key. That isn&#x2019;t fun, but we can make it work. Let&#x2019;s take a look at the connection string again, what if we change it so it will look like this?Server=northwind.database.local:9222;Database=Orders;Server Key Hash=6HvG2FFNFIifEjaAfryurGtr&#x2B;ucaNgHfSSfgQUi5MHM=;Client Key=client.keyI marked the pieces that were changed. The key observation here is that I don&#x2019;t need to hold the actual public key here, I just need to recognize it. That I can do by simply storing the SHA256 signature of the public key, that ensures that I always have the same length, regardless of what key type I&#x2019;m using. For that matter, I think that this is something that I want to do regardless, because if I do manage to fix the other key types, I could still use the same approach. All values in SHA256 will hash to the same length, obviously.After all of that, what do we have?We generate a keypair and store, we let the other side know about the public key hash as the identifier. Then we dynamically generate a certificate with the stored key. Let&#x2019;s say that we do that once per startup. That certificate is going to be different each run, but we don&#x2019;t actually care, we can safely authenticate the other side using the (persistent) key pair by validating the public key hash. Here is what this will look like in code from the client perspective:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var clientCert = GenerateCertificate(&quot;client.key&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // the expected server public key hash&#xA;        &#xA;        &#xA;          &#xA;          var certCertPublicKeyHash = &quot;6HvG2FFNFIifEjaAfryurGtr&#x2B;ucaNgHfSSfgQUi5MHM=&quot;;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var tcpClient = new TcpClient();&#xA;        &#xA;        &#xA;          &#xA;          tcpClient.Connect(IPAddress.Loopback, 9222);&#xA;        &#xA;        &#xA;          &#xA;          var clientSsl = new SslStream(tcpClient.GetStream(), false, (sender, certificate, chain, errors) =&gt;&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var publicKeyHash = SHA256.HashData(certificate.GetPublicKey());&#xA;        &#xA;        &#xA;          &#xA;              return certCertPublicKeyHash == Convert.ToBase64String(publicKeyHash);&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;        &#xA;          &#xA;          clientSsl.AuthenticateAsClient(@&quot;foobar&quot;, new X509Certificate2Collection(clientCert), SslProtocols.Tls12, false);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var reader = new StreamReader(clientSsl);&#xA;        &#xA;        &#xA;          &#xA;          Console.WriteLine(reader.ReadLine());&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          client.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;And here is what the server is doing:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static async Task&lt;Stream&gt; HandleConnection(&#xA;        &#xA;        &#xA;          &#xA;              TcpClient client, &#xA;        &#xA;        &#xA;          &#xA;              X509Certificate2 serverCertificate,&#xA;        &#xA;        &#xA;          &#xA;              HashSet&lt;string&gt; allowedClientKeys)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var serverSsl = new SslStream(client.GetStream(), false, (_, _, _, _) =&gt; true); // allow all clients certificates&#xA;        &#xA;        &#xA;          &#xA;              await serverSsl.AuthenticateAsServerAsync(serverCertificate, clientCertificateRequired: true, SslProtocols.Tls12, false);&#xA;        &#xA;        &#xA;          &#xA;              var clientPublicKeyHash =&#xA;        &#xA;        &#xA;          &#xA;                  Convert.ToBase64String(SHA256.HashData(serverSsl.RemoteCertificate?.GetPublicKey() ??&#xA;        &#xA;        &#xA;          &#xA;                                                         Array.Empty&lt;byte&gt;()));&#xA;        &#xA;        &#xA;          &#xA;              await using var writer = new StreamWriter(serverSsl);&#xA;        &#xA;        &#xA;          &#xA;              if (allowedClientKeys.Contains(clientPublicKeyHash) == false)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // failed to authenticate, send a proper error message&#xA;        &#xA;        &#xA;          &#xA;                  await using var _ = serverSsl;&#xA;        &#xA;        &#xA;          &#xA;                  await writer.WriteLineAsync(&quot;ERROR Client is not authorized: &quot; &#x2B; clientPublicKeyHash);&#xA;        &#xA;        &#xA;          &#xA;                  await serverSsl.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;                  return null; // client failure&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              await writer.WriteLineAsync(&quot;OK&quot;);&#xA;        &#xA;        &#xA;          &#xA;              return serverSsl;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          server.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;As you can see, this is very similar to what I ended up with in my secured protocol, but it utilizes TLS and all the weight behind it to achieve the same goal. A really important aspect of this is that we can actually connect to the server using something like openssl s_client &#x2013;connect, which can be really nice for debugging purposes.However, the weight of TLS is also an issue. I failed to successfully create Ed25519 certificates, which was my original goal. I couldn&#x2019;t get it work using ECDsa certificates and had to use RSA ones with the biggest keys. It was obvious that a lot of those issues are because we are running on a particular operating system, which means that this protocol is subject to the whims of the environment still. I have also not done everything that is required to ensure that there will not be any remote calls as part of the TLS handshake in this case, that can actually be quite complex to ensure, to be honest. Given that these are self signed (and pretty bare boned) certificates, there shouldn&#x2019;t be any, but you know what they say about assumptions .The end goal is that we are now able to get roughly the same experience using TLS as the underlying communication mechanism, without dealing with certificates directly. We can use standard tooling to access the server, which is great. Note that this doesn&#x2019;t address something like browser access, which will not be trusted, obviously.&#xA0; For that, we have to go back to Let&#x2019;s Encrypt or some other trusted CA, and we are back in PKI land.</p>
        </article>
        <article id="article-964">
            <a href="https://ardalis.com/design-patterns-overview/" target="_blank">
                <h2 class="title mb-6" id="article-964">Design Patterns Overview</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 12, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Design patterns provide reusable approaches to common problems and allow for higher level discussions of software design. Learn the basics&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-965">
            <a href="https://andrewlock.net/exploring-dotnet-6-part-5-supporting-ef-core-tools-with-webapplicationbuilder/" target="_blank">
                <h2 class="title mb-6" id="article-965">Supporting EF Core migrations with WebApplicationBuilder</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 12, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Exploring .NET 6 - Part 5</p>
        </article>
        <article id="article-966">
            <a href="https://ayende.com/blog/194945-A/performance-architecture-talk" target="_blank">
                <h2 class="title mb-6" id="article-966">Performance architecture talk</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 11, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I spoke at the Donetos conference about how to design your system for high performance, using RavenDB&#x2019;s story as the backdrop. I think it went great.</p>
        </article>
        <article id="article-967">
            <a href="https://www.meziantou.net/downloading-a-ssl-certificate-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-967">Downloading a SSL/TLS certificate in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 11, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I recently needed to set up an alert when a certificate expires soon or when it uses an insecure signature algorithm. The first step is to get the certificate. In .NET you can use the SslStream class to do the hard job. Then, you can set up a recurring task using Azure Pipelines or GitHub Actions t</p>
        </article>
        <article id="article-968">
            <a href="https://ayende.com/blog/194913-A/a-pki-less-secure-communication-channel-error-handling-at-the-protocol-level" target="_blank">
                <h2 class="title mb-6" id="article-968">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 08, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">One of the things that I find myself paying a lot of attention to is the error handling portion of writing software. This is one of the cases where I&#x2019;m sounding puffy even to my own ears, but from over two decades of experience, I can tell you that getting error handling right is one of the most important things that you can do for&#xA0; your systems. I spend a lot of time on getting errors right. That doesn&#x2019;t just mean error handling, but error reporting and giving enough context that the other side can figure out what we need to do.In a secured protocol, that is a bit harder, because we need to safeguard ourselves from eavesdroppers, but I spent significant amounts of time thinking on how to do this properly. Here are the ground rules I set out for myself:The most common scenario is client failing to connect to the server.We need to properly report underlying issues (such as TCP errors) while also exposing any protocol level issues.There is an error during the handshake and errors during processing of application messages. Both scenarios should be handled.We already saw in the previous post that there is the concept of the data messages and alert messages (of which there can only be one). Let&#x2019;s look how that works for the handshake scenario. I&#x2019;m focusing on the server side here, because I&#x2019;m assuming that this one is more likely to be opaque. A client side issue can be much more easily troubleshooted. And the issue isn&#x2019;t error handling inside the code, it is distributed error handling. In other words, if the server has an issue, how it reports to the client?The other side, where the client wants to report an issue to the server, is of no interest to us. From our perspective, a client can cut off at any point (TCP connection broke, etc), so there is no meaning to trying to do that gracefully or give more data to the server. What would the server do with that? Here is the server portion of establishing a secured connection:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn serverConnection(allocator: *std.mem.Allocator, stream: std.net.Stream, server_keys: crypto.KeyPair) !AuthenticatedConnection {&#xA;        &#xA;        &#xA;          &#xA;              errdefer stream.close();&#xA;        &#xA;        &#xA;          &#xA;              var handshake = protocol.Server.initialize(server_keys);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var reader = stream.reader();&#xA;        &#xA;        &#xA;          &#xA;              var hello: protocol.HelloMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;hello));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try hello.route(&amp;handshake); // no routing supported here&#xA;        &#xA;        &#xA;          &#xA;              var challenge = try hello.challenge(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = stream.writer();&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;challenge));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var resp: protocol.ChallengeResponse = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;resp));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var session = try handshake.generateKey();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var rc: AuthenticatedConnection = undefined;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;rc.pub_key, &amp;handshake.client.long_term_public_key);&#xA;        &#xA;        &#xA;          &#xA;              rc.stream = try crypto.NetworkStream.init(allocator, stream, session);&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;              try resp.completeAuth(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          serverConnection.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I&#x2019;m using Zig to write this code and you can see any potential error in the process marked with a try keyword. Looking at the code, everything up to line 24 (the completeAuth() call) is mechanically sending and receiving data. Any error up to that point is something that is likely network related (so the connection is broken). You can see that the protocol call challenge() can fail as does the call to generateKey() &#x2013; in both cases, there isn&#x2019;t much that I can do about it. If the generateKey() call fails, there is no shared secret (for that matter, it doesn&#x2019;t look like that can fail, but we&#x2019;ll ignore that). As for the challenge() call, the only way that can fail is if the server has failed to encrypt its challenge properly. That is not something that the client can do much about. And anyway, there isn&#x2019;t a failing codepath there either.In other words, aside from network issues, which will break the connection (meaning we cannot send the error to the client anyway), we have to wait until we process the challenge from the client to have our first viable failure. In the code above, I&#x201D;m just calling try, which means that we&#x2019;ll fail the connection attempt, close the socket and basically just hang up on the client. That isn&#x2019;t nice to do at all. Here is what I replaced line 24 with:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          resp.completeAuth(&amp;handshake) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;              // we use the secure channel to send an error to the other side (will also abort the connection there)&#xA;        &#xA;        &#xA;          &#xA;              var msg = &quot;Failed to validate challenge response&quot;.*;&#xA;        &#xA;        &#xA;          &#xA;              rc.stream.send_alert(crypto.AlertTypes.BadChallengeResponse, &amp;msg) catch {&#xA;        &#xA;        &#xA;          &#xA;                  // there is nothing we can do here, ignoring the error&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              return e; // implicitly close the connection&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          serverConnection.err-handling.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;What is going on here is that by the time that I got the challenge response from the client, I have enough information to send derive the shared key. I can use that to send an alert to the other side, letting them know what the failure was. A client will complete the challenge, and if there is a handshake failure, we proceed to fail gracefully with meaning error.But there is another point to this protocol, an alert message doesn&#x2019;t have to show up only in the hand&#xA0; shake part. Consider a long running response that run into an error. Here is how you&#x2019;ll usually handle that in TCP / HTTP scenarios, assume that we are streaming data to the client and suddenly run into an issue:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            &quot;Databases&quot;: [&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                &quot;Name&quot;: &quot;Northwind&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Disabled&quot;: false,&#xA;        &#xA;        &#xA;          &#xA;                &quot;TotalSize&quot;: {&#xA;        &#xA;        &#xA;          &#xA;                  &quot;HumaneSize&quot;: &quot;327.81 MBytes&quot;,&#xA;        &#xA;        &#xA;          &#xA;                  &quot;SizeInBytes&quot;: 343736320&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              },&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                &quot;Name&quot;: &quot;Darksand&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Disabled&quot;: false,&#xA;        &#xA;        &#xA;          &#xA;                &quot;TotalSize&quot;: {&#xA;        &#xA;        &#xA;          &#xA;          Unhandled Exception: System.UnauthorizedAccessException: Access to the path &#x27;/data/darksand&#x27; is denied. ---&gt; System.IO.IOException: Permission denied&#xA;        &#xA;        &#xA;          &#xA;             --- End of inner exception stack trace ---&#xA;        &#xA;        &#xA;          &#xA;             at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)&#xA;        &#xA;        &#xA;          &#xA;             at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.Linux.LinuxLiveDataReader.OpenMemFile()&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.Linux.LinuxLiveDataReader.ReadMemory(UInt64 address, IntPtr buffer, Int32 bytesRequested, Int32&amp; bytesRead)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DacInterface.DacDataTargetWrapper.ReadVirtual(IntPtr self, UInt64 address, IntPtr buffer, Int32 bytesRequested, Int32&amp; bytesRead)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DacLibrary..ctor(DataTarget dataTarget, String dacDll)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DataTarget.ConstructRuntime(ClrInfo clrInfo, String dac)&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          response.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;How do you send an error midstream? Well, you don&#x2019;t. If you are lucky, you&#x2019;ll have the error output and have some way to get the full message and manually inspect it. That is a distressingly common issue, by the way, and a huge problem for proper error reporting with long running responses. With the alert model, we have effectively multiple channels in the same TCP stream that we can utilize to send a clear and independent error for the client. Much nicer overall, even if I say so myself.And it just occurred to me that this mimics quite nicely the same approach that Zig itself uses for error handling .</p>
        </article>
        <article id="article-969">
            <a href="https://ayende.com/blog/194882-A/a-pki-less-secure-communication-channel-implementing-the-record-stream" target="_blank">
                <h2 class="title mb-6" id="article-969">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 07, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We now have managed to do a proper handshake and both client and server has a shared key. The client has also verified that the server is who they thought it should be, the server knows who the client is and can lookup whatever authorization such a client is ought to get. The next step we have to take is actually starting sending data over the wire. I mentioned earlier that while conceptually, we are dealing with a stream of data, in practice, we have to send the data as independent records. That is done so we can properly verify that they weren&#x2019;t meddled with along the way (either via cosmic radiation or malicious intent).We&#x2019;ll start with the writing data, which is simple. We initiate the write side of the connection using CryptoWriter:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: *std.mem.Allocator, stream: TStream, secret_keys: sodium.SecretKeys) !CryptoWriter {&#xA;        &#xA;        &#xA;          &#xA;              var buf = try allocator.alloc(u8, RecordBufferSize * 2);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var self: CryptoWriter = .{&#xA;        &#xA;        &#xA;          &#xA;                  .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = buf,&#xA;        &#xA;        &#xA;          &#xA;                  .writer = stream.writer(),&#xA;        &#xA;        &#xA;          &#xA;                  .padder = null,&#xA;        &#xA;        &#xA;          &#xA;                  .stream = stream,&#xA;        &#xA;        &#xA;          &#xA;                  .state = undefined,&#xA;        &#xA;        &#xA;          &#xA;                  .alert_raised = false,&#xA;        &#xA;        &#xA;          &#xA;                  .buffered = 0,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_init_push(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;secret_keys.transmit[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnableToPushStreamHeader;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.writer.writeAll(self.buffer[0..c.crypto_secretstream_xchacha20poly1305_HEADERBYTES]);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We allocate a buffer that is 32KB in size (16KB x 2). The record size we selected is 16KB. Unlike TLS, this is an inclusive size, so the entire thing must fit in 16KB. We need to allocate 32KB because the API we use does not support in place encryption. You&#x2019;ll note that we reserved some space in the header (5 bytes, to be exact) for our own needs. You&#x2019;ll note that we initialize the stream and send the stream header to the other side in here, that is the only reference for cryptography in the initialization. The actual writing isn&#x2019;t really that interesting, we are pushing all the data to the buffer, until we run out of space, then we call flush(). I&#x2019;ve written this code in plenty of languages, and it is pretty straightforward, if tedious.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn write(self: *CryptoWriter, buffer: []const u8) !usize {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_raised) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AlertAlreadyRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var buf = buffer;&#xA;        &#xA;        &#xA;          &#xA;              var total_size: usize = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var size = std.math.min(buf.len, RecordBufferSize - self.buffered);&#xA;        &#xA;        &#xA;          &#xA;                  total_size &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, self.buffer[self.buffered..RecordBufferSize], buf[0..size]);&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;                  buf = buf[size..];&#xA;        &#xA;        &#xA;          &#xA;                  if (self.buffered == RecordBufferSize) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.flush(RecordTypes.Data);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (buf.len == 0)&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return total_size;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.write.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There isn&#x2019;t anything happening here, until we call to flush(RecordTypes.Data) &#x2013; that is an indication to the other side that this is application data, rather than some protocol level message. The flush() method is where things gets really interesting.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn flush(self: *CryptoWriter, rec_type: RecordTypes) !void {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_raised) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AlertAlreadyRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.buffered &gt; MaxPlainTextSize) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.PlainTextRecordSizeToLarge; // should never happen&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, self.buffer[2..4], @intCast(u16, self.buffered - @sizeOf(u16)), .Little);&#xA;        &#xA;        &#xA;          &#xA;              self.buffer[4] = @enumToInt(rec_type);&#xA;        &#xA;        &#xA;          &#xA;              if (self.padder) |padder| {&#xA;        &#xA;        &#xA;          &#xA;                  var pad_len = padder(self, self.buffered);&#xA;        &#xA;        &#xA;          &#xA;                  if (pad_len &#x2B; self.buffered &gt; MaxPlainTextSize)&#xA;        &#xA;        &#xA;          &#xA;                      return error.InvalidPaddingLengthProvided;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.set(u8, self.buffer[self.buffered..(self.buffered &#x2B; pad_len)], 0);&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered &#x2B;= pad_len;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var len: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              var encrypted = self.buffer[RecordBufferSize..];&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_push(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;encrypted[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;len,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered - @sizeOf(u16),&#xA;        &#xA;        &#xA;          &#xA;                  null,&#xA;        &#xA;        &#xA;          &#xA;                  0,&#xA;        &#xA;        &#xA;          &#xA;                  0,&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnableToPushEncryptedRecord;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (len &gt; RecordBufferSize - @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.EncryptedRecordSizeTooBig; // should never happen&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, encrypted[0..2], @intCast(u16, len &#x2B; @sizeOf(u16)), .Little);&#xA;        &#xA;        &#xA;          &#xA;              try self.writer.writeAll(encrypted[0 .. len &#x2B; @sizeOf(u16)]);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter,flush.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is a lot of code here, I know. Let&#x2019;s see if I can take it in all, there are some preconditions that should be fairly obvious, then we write the size of the plain text value as well as the record type to the header (that part of the header will be encrypted, mind). The next step is interesting, we invoke a callback to get an answer about how much padding we should use. There is a lot of information about padding. In general, just looking at the size of the data can tell you about what is going on, even if there is nothing else you can figure out. If you know that the &#x201C;Attack At Dawn&#x201D;&#xA0; is 14 chars long, and with the encryption overhead that turns to a 37 bytes message, that along can tell you much. Assume that you can&#x2019;t figure out the contents, but can sniff the sizes. That can be a problem. There are certain attacks that rely on leaking the size of messages to work, the BREACH attack, for example, relies on being able to send text that would collide with secret pieces of the message. Analyzing the size of the data that is sent will tell us when we managed to find a match (because the size will be reduced). To solve that, you can define a padding policy. For example, all messages are always exactly 16KB in size, and you&#x2019;ll send an empty message every second if there is no organic traffic. Alternatively, you may select to randomize the message size (to further confuse things). At any rate, this is a pretty complex topic,and not something that I wanted to get too much into. Being able to let the user decide gives me both worlds. This is a match to SSL_CTX_set_record_padding_callback() on OpenSSL.The rest is just calling to libsodium to do the actual encryption, setting the encrypted envelope size and sending it to the other side. Note that we use the other half of the buffer here to store the encrypted portion of the data. In addition to sending application data, we can send alerts to the other side. That is an protocol level error message. I&#x2019;ll actually have a separate post to talk about error handling, but for now, let&#x2019;s see how sending an alert looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn send_alert(self: *CryptoWriter, alert_type: AlertTypes, msg: []u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              defer {&#xA;        &#xA;        &#xA;          &#xA;                  self.alert_raised = true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (msg.len &#x2B; @sizeOf(AlertTypes) &#x2B; @sizeOf(u16) &gt; MaxPlainTextSize) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.PlainTextRecordSizeToLarge;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, self.buffer[(HeaderSize &#x2B; @sizeOf(AlertTypes))..], msg);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, self.buffer[HeaderSize .. HeaderSize &#x2B; @sizeOf(u16)], @enumToInt(alert_type), .Little);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize &#x2B; @sizeOf(AlertTypes) &#x2B; msg.len; // we discard everything else&#xA;        &#xA;        &#xA;          &#xA;              try self.flush(RecordTypes.Alert);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.alert.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Basically, we overwrite whatever there is on the buffer, and we flush it immediately to the other side. We also set the alert_raised flag, which will prevent any further usage of the stream. Once an error was sent, we are done. We aren&#x2019;t closing the stream because that is the job for the calling code, which will get an error and close us during normal cleanup procedures.The reading process is a bit more involved, on the other hand. We start by mirroring the write, pulling the header from the network and initializing the stream:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: *std.mem.Allocator, source: TStream.Reader, secret_keys: sodium.SecretKeys) !CryptoReader {&#xA;        &#xA;        &#xA;          &#xA;              var buf = try allocator.alloc(u8, RecordBufferSize * 2);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;              var self: CryptoReader = .{&#xA;        &#xA;        &#xA;          &#xA;                  .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  .reader = source,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = buf,&#xA;        &#xA;        &#xA;          &#xA;                  .incoming = &amp;[0]u8{},&#xA;        &#xA;        &#xA;          &#xA;                  .incoming_plain_text = &amp;[0]u8{},&#xA;        &#xA;        &#xA;          &#xA;                  .state = undefined,&#xA;        &#xA;        &#xA;          &#xA;                  .alert_code = null,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.reader.readNoEof(self.buffer[0..c.crypto_secretstream_xchacha20poly1305_HEADERBYTES]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_init_pull(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;secret_keys.recieve[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.FailedToInitCryptoStream;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The real fun starts when we need to actually read things, let&#x2019;s take a look at the code and then I&#x2019;ll explain it in details:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn read(self: *CryptoReader, buffer: []u8) !usize {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_code) |_| {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AnAlertWasRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.incoming_plain_text.len &gt; 0) { // read from buffer&#xA;        &#xA;        &#xA;          &#xA;                  return self.read_buffer(buffer);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  while (self.incoming.len &lt; @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.read_from_network();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var env_len = std.mem.readInt(u16, self.incoming[0..2], .Little);&#xA;        &#xA;        &#xA;          &#xA;                  if (env_len == 0 or env_len &gt; RecordBufferSize) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.InvalidCryptoEnvelopeSize;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  while (env_len &gt; self.incoming.len) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.read_from_network(); // read enough bytes from network&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming_plain_text = self.buffer[RecordBufferSize..];&#xA;        &#xA;        &#xA;          &#xA;                  var len: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;                  if (c.crypto_secretstream_xchacha20poly1305_pull(&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.incoming_plain_text[0],&#xA;        &#xA;        &#xA;          &#xA;                      &amp;len,&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.incoming[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                      env_len - @sizeOf(u16),&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.FailedToDecryptRecord;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, self.incoming, self.incoming[env_len..]);&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming = self.incoming[env_len..];&#xA;        &#xA;        &#xA;          &#xA;                  if (len &lt; @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.DecryptedRecordIsTooSmall;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var plain_txt_len = std.mem.readInt(u16, self.incoming_plain_text[0..2], .Little);&#xA;        &#xA;        &#xA;          &#xA;                  if (plain_txt_len == 0) {&#xA;        &#xA;        &#xA;          &#xA;                      continue; // allowed to have empty record&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var record_type = @intToEnum(RecordTypes, self.incoming_plain_text[@sizeOf(u16)]);&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming_plain_text = self.incoming_plain_text[@sizeOf(u16) &#x2B; @sizeOf(u8) .. plain_txt_len];&#xA;        &#xA;        &#xA;          &#xA;                  if (record_type == .Alert) {&#xA;        &#xA;        &#xA;          &#xA;                      self.alert_code = @intToEnum(AlertTypes, std.mem.readInt(u16, self.incoming_plain_text[0..@sizeOf(u16)], .Little));&#xA;        &#xA;        &#xA;          &#xA;                      self.incoming_plain_text = self.incoming_plain_text[@sizeOf(u16)..];&#xA;        &#xA;        &#xA;          &#xA;                      return error.AnAlertWasRaised;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return self.read_buffer(buffer);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.read.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We first check if an alert was raised, if it was, we immediately abort, since the stream is now dead. If there are any plain text bytes, we can return them directly from the buffer. We&#x2019;ll look into that as well as how we read from the network shortly. For now, let&#x2019;s focus on what we are doing here.We read enough from the network to know what is the envelope length that we have to read. That value, if you&#x2019;ll remember, is the first value that we send for a record and is not encrypted (there isn&#x2019;t much point, you can look at the packet information to get that if you wanted to). We then make sure that we read the entire record to the buffer. We decrypt the data from the incoming buffer to the plain_text buffer (that is what the read_buffer()&#xA0; function will use to actually return results).The rest of the code is figuring out what we actually got. We check what is the actual size of the data we received. We may have received a zero length value, so we have to handle this.We check whatever we got a data record or an alert. If the later, we mark it as such and return an error. If this is just the data, we setup the plain text buffer properly and go to the read_buffer() call to return the values.&#xA0; That is a lot of code, but not a lot of functionality. Simple code is best, and this match that scenario. Let&#x2019;s see how we handle the actual buffer and network reads:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn read_buffer(self: *CryptoReader, buffer: []u8) usize {&#xA;        &#xA;        &#xA;          &#xA;              var size = std.math.min(self.incoming_plain_text.len, buffer.len);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, buffer, self.incoming_plain_text[0..size]);&#xA;        &#xA;        &#xA;          &#xA;              self.incoming_plain_text = self.incoming_plain_text[size..];&#xA;        &#xA;        &#xA;          &#xA;              return size;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn read_from_network(self: *CryptoReader) !void {&#xA;        &#xA;        &#xA;          &#xA;              var existing = self.incoming.len; // we may have data already in buffer, but need more...&#xA;        &#xA;        &#xA;          &#xA;              var len = try self.reader.read(self.buffer[existing..(RecordBufferSize - existing)]);&#xA;        &#xA;        &#xA;          &#xA;              if (len == 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnexpectedEndOfStream;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.incoming = self.buffer[0..(existing &#x2B; len)];&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.buffer-net.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Not much here, just need to make sure that we handle partial reads as well as reading multiple records in one shot. We saw that when we get an alert, we return an error. But the question is, how do we get the actual alert? The answer is that we store the message in the plain text buffer and record the alert itself. All future calls will fail with an error. You can then call to the alert()&#xA0; function to get the actual details:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn alert(self: *CryptoReader) !Alert {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_code) |code| {&#xA;        &#xA;        &#xA;          &#xA;                  var rc = Alert{ .alert = code, .msg = self.incoming_plain_text };&#xA;        &#xA;        &#xA;          &#xA;                  return rc;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return error.NoAlertRecieved;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.alert.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This gives us a nice API to use when there are issues with the stream. I think that matches well with the way Zig handles errors, but I can&#x2019;t tell whatever this is idiomatic Zig.That is long enough for now, you can go and read the actual code, of course. And I will welcome any comments. In the next (and likely last) post in the series, I&#x201D;m going to go over error handling at the protocol level.</p>
        </article>
        <article id="article-970">
            <a href="https://ayende.com/blog/194881-A/a-pki-less-secure-communication-channel-coding-the-handshake" target="_blank">
                <h2 class="title mb-6" id="article-970">A PKI-less secure communication channel</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: October 06, 2021
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After figuring out the design, let&#x2019;s see what it would take to actually write a secured communication channel, sans PKI, in code. I&#x2019;m going to use Zig as the language of choice here. It is as low level as C, but so much nicer to work with. To actually implement the cryptographic details, I&#x2019;m going to lean on libsodium to do all the heavy lifting. It took multiple iterations of the code to get to this point, but I&#x2019;m pretty happy with how it turned out. I&#x2019;ll start from the client code, which connects to a remote server and establish a secured TCP channel, here is what this looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn clientFn(&#xA;        &#xA;        &#xA;          &#xA;              host: []const u8,&#xA;        &#xA;        &#xA;          &#xA;              port: u16,&#xA;        &#xA;        &#xA;          &#xA;              server_pub_key: [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;              client_kp: crypto.KeyPair,&#xA;        &#xA;        &#xA;          &#xA;          ) !void {&#xA;        &#xA;        &#xA;          &#xA;              var server_key = protocol.Client.ExpectedPublicKey{&#xA;        &#xA;        &#xA;          &#xA;                  .end_public_key = server_pub_key,&#xA;        &#xA;        &#xA;          &#xA;                  .middlebox_public_key = server_pub_key,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              var con = try crypto.clientConnection(&#xA;        &#xA;        &#xA;          &#xA;                  std.heap.page_allocator,&#xA;        &#xA;        &#xA;          &#xA;                  host,&#xA;        &#xA;        &#xA;          &#xA;                  port,&#xA;        &#xA;        &#xA;          &#xA;                  client_kp,&#xA;        &#xA;        &#xA;          &#xA;                  server_key,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              defer con.stream.deinit();&#xA;        &#xA;        &#xA;          &#xA;              var encrypted_stream = con.stream;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var buf: [1024]u8 = undefined;&#xA;        &#xA;        &#xA;          &#xA;              // read normal message&#xA;        &#xA;        &#xA;          &#xA;              var len = try encrypted_stream.reader().read(&amp;buf);&#xA;        &#xA;        &#xA;          &#xA;              std.log.debug(&quot;{s}&quot;, .{buf[0..len]});&#xA;        &#xA;        &#xA;          &#xA;              // handle errors from the other side&#xA;        &#xA;        &#xA;          &#xA;              _ = encrypted_stream.reader().read(&amp;buf) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;                  std.log.debug(&quot;err {s}&quot;, .{@errorName(e)});&#xA;        &#xA;        &#xA;          &#xA;                  var a = try encrypted_stream.alert();&#xA;        &#xA;        &#xA;          &#xA;                  std.log.debug(&quot;{s} {s} {s}&quot;, .{ @errorName(e), @tagName(a.alert), a.msg });&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          client.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The function connects to a server, expecting it to use a particular public key, and will authenticate using a provided key pair. The bulk of the work is done in the crypto.clientConnection() call, where we are following the handshake I outlined here. The result of the call is an AuthenticatedConnection structure, containing both the encrypted stream as well as the public key of the other side. Note that from the client side, if the server doesn&#x2019;t authenticate using the expected key, the call will fail with an error, so for clients, it is usually not important to check the public key, that is already something that we checked.The actual stream we return expose a reader and writer instances that you can use to talk to the other side. Note that we are using buffered data, so writing to the stream will not do anything until the buffer is full (about 16KB) or flush() is called.The other side is the server, of course, which looks like this:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var client : std.net.Connection = try server.accept();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var con = try crypto.serverConnection(std.heap.page_allocator, client.stream, server_kp);&#xA;        &#xA;        &#xA;          &#xA;          std.log.debug(&quot;Connected, I&#x27;m {s} - other side {s}&quot;, .{&#xA;        &#xA;        &#xA;          &#xA;              crypto.KeyPair.keyBase64(server_kp.public),&#xA;        &#xA;        &#xA;          &#xA;              crypto.KeyPair.keyBase64(con.pub_key),&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;        &#xA;          &#xA;          var encrypted_stream = con.stream;&#xA;        &#xA;        &#xA;          &#xA;          defer encrypted_stream.deinit();&#xA;        &#xA;        &#xA;          &#xA;          var w = encrypted_stream.writer();&#xA;        &#xA;        &#xA;          &#xA;          try w.writeAll(&quot;hi there&quot;);&#xA;        &#xA;        &#xA;          &#xA;          try encrypted_stream.flush();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var msg = &quot;Opps, msg&quot;.*;&#xA;        &#xA;        &#xA;          &#xA;          try encrypted_stream.send_alert(crypto.AlertTypes.Badness, &amp;msg);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          server.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;On the server side, we have the crypto.serverConnection() call, it accepts a new connection from a listening socket and starts the handshake process. Note that this code, unlike the client, does not verify that the other side is known to us. Instead, we return that to the caller which can then check the public key of the client. This is intentional, because at this point, we have a secure channel, but not yet authentication. The server can then safely tell the other side that they authorize them (or not) using the channel with not one being able to peek what is going on there.Let&#x2019;s dig a bit deeper into the implementation. We&#x2019;ll start from the client code, which is simpler:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn clientConnection(&#xA;        &#xA;        &#xA;          &#xA;              allocator: *std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;              host: []const u8,&#xA;        &#xA;        &#xA;          &#xA;              port: u16,&#xA;        &#xA;        &#xA;          &#xA;              client_keys: crypto.KeyPair,&#xA;        &#xA;        &#xA;          &#xA;              expected_server_key: ?protocol.Client.ExpectedPublicKey,&#xA;        &#xA;        &#xA;          &#xA;          ) !AuthenticatedConnection {&#xA;        &#xA;        &#xA;          &#xA;              var con = try std.net.tcpConnectToHost(allocator, host, port);&#xA;        &#xA;        &#xA;          &#xA;              errdefer con.close();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var handshake = protocol.Client.init(client_keys, expected_server_key);&#xA;        &#xA;        &#xA;          &#xA;              var hello = try handshake.hello();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = con.writer();&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;hello));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var reader = con.reader();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var msg: protocol.ChallengeMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;msg));&#xA;        &#xA;        &#xA;          &#xA;              var response = try msg.respond(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;response));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var session = try handshake.generateKey();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var rc: AuthenticatedConnection = undefined;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;rc.pub_key, &amp;handshake.server.long_term_public_key);&#xA;        &#xA;        &#xA;          &#xA;              rc.stream = try crypto.NetworkStream.init(allocator, con, session);&#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          clientConnection.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The handshake protocol itself is handled by the protocol.Client. The way I have coded it, we are reading known lengths from the network into in memory structure and using them directly. I can do that because the structures are basically just bunch of packed []u8 (char arrays), so the in memory and network representation are one and the same. That makes things simpler. You can see that I&#x2019;m calling readNoEof on the structures as bytes. That ensure that I get the whole message from the network and then the actual operations that I need to make are handled. Here is the sequence of operations:After sending the hello, the server will respond with a challenge, the client replies and both sides now know that they other side is who they say they are.Let&#x2019;s dig a bit deeper, shall we, and see how we have the hello message:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn hello(self: *Client) !HelloMessage {&#xA;        &#xA;        &#xA;          &#xA;              var req: HelloMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              req.version = Client.ExpectedVersion;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;req.client_session_public_key, &amp;self.session.public);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(&#xA;        &#xA;        &#xA;          &#xA;                  u8,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;req.expected_server_public_key.data,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.server.expected_server_key.end_public_key,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              try req.expected_server_public_key.encrypt(&#xA;        &#xA;        &#xA;          &#xA;                  self.server.expected_server_key.middlebox_public_key,&#xA;        &#xA;        &#xA;          &#xA;                  self.session.secret,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              return req;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn EncryptedBoxBuffer(size: usize) type {&#xA;        &#xA;        &#xA;          &#xA;              return packed struct {&#xA;        &#xA;        &#xA;          &#xA;                  const Self = @This();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  data: [size]u8,&#xA;        &#xA;        &#xA;          &#xA;                  mac: [mac_len]u8,&#xA;        &#xA;        &#xA;          &#xA;                  nonce: [nonce_len]u8,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn encrypt(&#xA;        &#xA;        &#xA;          &#xA;                      self: *Self,&#xA;        &#xA;        &#xA;          &#xA;                      public_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                      secret_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                  ) !void {&#xA;        &#xA;        &#xA;          &#xA;                      c.randombytes_buf(&amp;self.nonce, self.nonce.len);&#xA;        &#xA;        &#xA;          &#xA;                      var rc = c.crypto_box_detached(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.mac,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          size,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.nonce,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;public_key,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;secret_key,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.EncryptionFailure;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  pub fn decrypt(&#xA;        &#xA;        &#xA;          &#xA;                      self: *Self,&#xA;        &#xA;        &#xA;          &#xA;                      public_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                      secret_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                  ) !void {&#xA;        &#xA;        &#xA;          &#xA;                      var rc = c.crypto_box_open_detached(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.mac,&#xA;        &#xA;        &#xA;          &#xA;                          size,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.nonce,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;public_key,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;secret_key,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.DecryptionFailure;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          hello.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There isn&#x2019;t much here, we set the version field to a known value, we copy our own session public key (which was just generated and tells no one nothing about us) and then we copy the expected server public key, but we aren&#x2019;t sending that over the wire in the clear. Instead, we encrypt that. We encrypt it with the client session public key (which we just send over) as well as the expected middlebox key (remember, those might be different). The idea is that the server on the other end may decide to route the request, but at the same time, we want to ensure that we are never revealing any information to 3rd parties. The actual encryption is handled via the EncryptedBoxBuffer structure, you can see that I&#x2019;m using Zig&#x2019;s comptime support to generate a structure with a compile time variant size. That make is trivial to do certain things without really needing to think about the details. It used to be more complex, and be able to support arbitrary embedded structures, but I simplified it to a single buffer. For that matter, for most of the code here, the size I&#x2019;m using is fixed (32 bytes / 256 bits). The key here is that all the details of nonce generation, MAC validation, etc are hidden and handled. I also don&#x2019;t really need to think about the space for that, since this directly part of the structure.It gets more interesting when we look at how the client respond to the challenge from the server:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const ChallengeMessage = packed struct {&#xA;        &#xA;        &#xA;          &#xA;              server_session_public_key: [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;              server_long_term_public_key: crypto.EncryptedBoxKey,&#xA;        &#xA;        &#xA;          &#xA;              long_term_key_proof: crypto.EncryptedBoxKey,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn respond(self: *ChallengeMessage, state: *Client) !ChallengeResponse {&#xA;        &#xA;        &#xA;          &#xA;                  var resp = std.mem.zeroes(ChallengeResponse);&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;state.server.session_public_key, &amp;self.server_session_public_key);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.server_long_term_public_key.decrypt(self.server_session_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;state.server.long_term_public_key, &amp;self.server_long_term_public_key.data);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (state.server.validate_server_key) {&#xA;        &#xA;        &#xA;          &#xA;                      if (!std.crypto.utils.timingSafeEql(&#xA;        &#xA;        &#xA;          &#xA;                          [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;                          state.server.expected_server_key.end_public_key,&#xA;        &#xA;        &#xA;          &#xA;                          state.server.long_term_public_key,&#xA;        &#xA;        &#xA;          &#xA;                      )) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.ExpectedServerPublicKeyMismatch;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.long_term_key_proof.decrypt(state.server.long_term_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (!std.crypto.utils.timingSafeEql([crypto.KeyLength]u8, self.long_term_key_proof.data, state.session.public)) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.LongTermProofValueAndSessionPublicKeyMismatch;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;resp.client_long_term_key.data, &amp;state.long_term.public);&#xA;        &#xA;        &#xA;          &#xA;                  try resp.client_long_term_key.encrypt(state.server.session_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;resp.challenge_answer.data, &amp;state.server.session_public_key);&#xA;        &#xA;        &#xA;          &#xA;                  try resp.challenge_answer.encrypt(state.server.session_public_key, state.long_term.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return resp;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ChallengeMessage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We copy the server&#x2019;s session public key to our own state, then we decrypt the server&#x2019;s long term public key using the public key that we were sent alongside the client&#x2019;s own secret key. Without both of them, we cannot decrypt the information that was sealed using the server&#x2019;s secret key and the client&#x2019;s public key. Remember that we have a very important distinction here:Session key pair &#x2013; generated per connection, transient, meaningless. If you know what the session public key is, you don&#x2019;t get much.Long term key pair &#x2013; used for authentication of the other side. If you know what the long term public key, you may figure out who the client or server are.Because of that, we never send the long term public keys in the clear. However, just getting the public key isn&#x2019;t enough, we need to ensure that the other side actually holds the full keypair, not just saying that it does.We handle that part asking that the server will encrypt the client&#x2019;s public session key using its long term secret key. Because the public session key is something that the client controls, the fact that the server can produce a value that decrypt to that using the stated public key ensures that it holds the secret portion as well. To answer the challenge, we do much the same thing in reverse. In other words, we are encrypting the server&#x2019;s public session key with our own long term key and sending that to the server. The final step is actually generating the symmetric keys for the channel, which is done using:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn generate_client(client: KeyPair, server_public_key: [KeyLen]u8) !SecretKeys {&#xA;        &#xA;        &#xA;          &#xA;              var rc: SecretKeys = undefined;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_kx_client_session_keys(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;rc.recieve[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;rc.transmit[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;client.public[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;client.secret[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;server_public_key[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.FailedToGenerateKey;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          gen_keys.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We are using the client&#x2019;s session key pair as well as the server&#x2019;s public key to generate a shared secret. Actually, a pair of secrets, one for sending and one for receiving. On the other side, you do pretty much the same in reverse. You can see the full source code here. This is only a partial work, of course, we still need to deal with the issue of actually sending data after the handshake, I&#x2019;ll deal with that in my next post.</p>
        </article>
        <div class="button flex justify-between">
            <a href="96.html"><span class="back arrow"></span></a>

            <a href="98.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>