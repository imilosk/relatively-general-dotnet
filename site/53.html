
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Home â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">
<script>
    const lightModePref = window.matchMedia("(prefers-color-scheme: light)");

    function getUserPref() {
        const storedTheme = typeof localStorage !== "undefined" && localStorage.getItem("theme");
        return storedTheme || (lightModePref.matches ? "light" : "dark");
    }

    function setTheme(newTheme) {
        if (newTheme !== "light" && newTheme !== "dark") {
            return console.warn(
                `Invalid theme value '${newTheme}' received. Expected 'light' or 'dark'.`,
            );
        }

        const root = document.documentElement;

        // root already set to newTheme, exit early
        if (newTheme === root.getAttribute("data-theme")) {
            return;
        }

        root.setAttribute("data-theme", newTheme);

        const colorThemeMetaTag = document.querySelector("meta[name='theme-color']");
        const bgColour = getComputedStyle(document.body).getPropertyValue("--theme-bg");
        colorThemeMetaTag.setAttribute("content", `hsl(${bgColour})`);
        if (typeof localStorage !== "undefined") {
            localStorage.setItem("theme", newTheme);
        }
    }

    // initial setup
    setTheme(getUserPref());

    document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("theme-toggle").addEventListener("click", () => {
            const theme = localStorage.getItem("theme");

            if (theme === "dark") {
                setTheme("light");
            } else {
                setTheme("dark");
            }
        });

        document.getElementById("toggle-navigation-menu").addEventListener("click", (e) => {
            const button = e.target;
            const ariaExpanded = button.getAttribute("aria-expanded");
            const header = document.getElementById("main-header");

            if (ariaExpanded === "true") {
                button.setAttribute("aria-expanded", "false");
                header.classList.remove("menu-open");
            } else {
                button.setAttribute("aria-expanded", "true");
                header.classList.add("menu-open");
            }
        });
    });
</script>

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <theme-toggle class="ms-auto">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main">
    <section aria-label="Blog post list">
        <a href="https://ayende.com/blog/194913-A/a-pki-less-secure-communication-channel-error-handling-at-the-protocol-level" target="_blank"><h1 class="title mb-6">A PKI-less secure communication channel</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: October 08, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">One of the things that I find myself paying a lot of attention to is the error handling portion of writing software. This is one of the cases where I&#x2019;m sounding puffy even to my own ears, but from over two decades of experience, I can tell you that getting error handling right is one of the most important things that you can do for&#xA0; your systems. I spend a lot of time on getting errors right. That doesn&#x2019;t just mean error handling, but error reporting and giving enough context that the other side can figure out what we need to do.In a secured protocol, that is a bit harder, because we need to safeguard ourselves from eavesdroppers, but I spent significant amounts of time thinking on how to do this properly. Here are the ground rules I set out for myself:The most common scenario is client failing to connect to the server.We need to properly report underlying issues (such as TCP errors) while also exposing any protocol level issues.There is an error during the handshake and errors during processing of application messages. Both scenarios should be handled.We already saw in the previous post that there is the concept of the data messages and alert messages (of which there can only be one). Let&#x2019;s look how that works for the handshake scenario. I&#x2019;m focusing on the server side here, because I&#x2019;m assuming that this one is more likely to be opaque. A client side issue can be much more easily troubleshooted. And the issue isn&#x2019;t error handling inside the code, it is distributed error handling. In other words, if the server has an issue, how it reports to the client?The other side, where the client wants to report an issue to the server, is of no interest to us. From our perspective, a client can cut off at any point (TCP connection broke, etc), so there is no meaning to trying to do that gracefully or give more data to the server. What would the server do with that? Here is the server portion of establishing a secured connection:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn serverConnection(allocator: *std.mem.Allocator, stream: std.net.Stream, server_keys: crypto.KeyPair) !AuthenticatedConnection {&#xA;        &#xA;        &#xA;          &#xA;              errdefer stream.close();&#xA;        &#xA;        &#xA;          &#xA;              var handshake = protocol.Server.initialize(server_keys);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var reader = stream.reader();&#xA;        &#xA;        &#xA;          &#xA;              var hello: protocol.HelloMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;hello));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try hello.route(&amp;handshake); // no routing supported here&#xA;        &#xA;        &#xA;          &#xA;              var challenge = try hello.challenge(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = stream.writer();&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;challenge));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var resp: protocol.ChallengeResponse = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;resp));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var session = try handshake.generateKey();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var rc: AuthenticatedConnection = undefined;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;rc.pub_key, &amp;handshake.client.long_term_public_key);&#xA;        &#xA;        &#xA;          &#xA;              rc.stream = try crypto.NetworkStream.init(allocator, stream, session);&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;              try resp.completeAuth(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          serverConnection.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I&#x2019;m using Zig to write this code and you can see any potential error in the process marked with a try keyword. Looking at the code, everything up to line 24 (the completeAuth() call) is mechanically sending and receiving data. Any error up to that point is something that is likely network related (so the connection is broken). You can see that the protocol call challenge() can fail as does the call to generateKey() &#x2013; in both cases, there isn&#x2019;t much that I can do about it. If the generateKey() call fails, there is no shared secret (for that matter, it doesn&#x2019;t look like that can fail, but we&#x2019;ll ignore that). As for the challenge() call, the only way that can fail is if the server has failed to encrypt its challenge properly. That is not something that the client can do much about. And anyway, there isn&#x2019;t a failing codepath there either.In other words, aside from network issues, which will break the connection (meaning we cannot send the error to the client anyway), we have to wait until we process the challenge from the client to have our first viable failure. In the code above, I&#x201D;m just calling try, which means that we&#x2019;ll fail the connection attempt, close the socket and basically just hang up on the client. That isn&#x2019;t nice to do at all. Here is what I replaced line 24 with:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          resp.completeAuth(&amp;handshake) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;              // we use the secure channel to send an error to the other side (will also abort the connection there)&#xA;        &#xA;        &#xA;          &#xA;              var msg = &quot;Failed to validate challenge response&quot;.*;&#xA;        &#xA;        &#xA;          &#xA;              rc.stream.send_alert(crypto.AlertTypes.BadChallengeResponse, &amp;msg) catch {&#xA;        &#xA;        &#xA;          &#xA;                  // there is nothing we can do here, ignoring the error&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              return e; // implicitly close the connection&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          serverConnection.err-handling.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;What is going on here is that by the time that I got the challenge response from the client, I have enough information to send derive the shared key. I can use that to send an alert to the other side, letting them know what the failure was. A client will complete the challenge, and if there is a handshake failure, we proceed to fail gracefully with meaning error.But there is another point to this protocol, an alert message doesn&#x2019;t have to show up only in the hand&#xA0; shake part. Consider a long running response that run into an error. Here is how you&#x2019;ll usually handle that in TCP / HTTP scenarios, assume that we are streaming data to the client and suddenly run into an issue:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            &quot;Databases&quot;: [&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                &quot;Name&quot;: &quot;Northwind&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Disabled&quot;: false,&#xA;        &#xA;        &#xA;          &#xA;                &quot;TotalSize&quot;: {&#xA;        &#xA;        &#xA;          &#xA;                  &quot;HumaneSize&quot;: &quot;327.81 MBytes&quot;,&#xA;        &#xA;        &#xA;          &#xA;                  &quot;SizeInBytes&quot;: 343736320&#xA;        &#xA;        &#xA;          &#xA;                }&#xA;        &#xA;        &#xA;          &#xA;              },&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                &quot;Name&quot;: &quot;Darksand&quot;,&#xA;        &#xA;        &#xA;          &#xA;                &quot;Disabled&quot;: false,&#xA;        &#xA;        &#xA;          &#xA;                &quot;TotalSize&quot;: {&#xA;        &#xA;        &#xA;          &#xA;          Unhandled Exception: System.UnauthorizedAccessException: Access to the path &#x27;/data/darksand&#x27; is denied. ---&gt; System.IO.IOException: Permission denied&#xA;        &#xA;        &#xA;          &#xA;             --- End of inner exception stack trace ---&#xA;        &#xA;        &#xA;          &#xA;             at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)&#xA;        &#xA;        &#xA;          &#xA;             at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.Linux.LinuxLiveDataReader.OpenMemFile()&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.Linux.LinuxLiveDataReader.ReadMemory(UInt64 address, IntPtr buffer, Int32 bytesRequested, Int32&amp; bytesRead)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DacInterface.DacDataTargetWrapper.ReadVirtual(IntPtr self, UInt64 address, IntPtr buffer, Int32 bytesRequested, Int32&amp; bytesRead)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DacLibrary..ctor(DataTarget dataTarget, String dacDll)&#xA;        &#xA;        &#xA;          &#xA;             at Microsoft.Diagnostics.Runtime.DataTarget.ConstructRuntime(ClrInfo clrInfo, String dac)&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          response.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;How do you send an error midstream? Well, you don&#x2019;t. If you are lucky, you&#x2019;ll have the error output and have some way to get the full message and manually inspect it. That is a distressingly common issue, by the way, and a huge problem for proper error reporting with long running responses. With the alert model, we have effectively multiple channels in the same TCP stream that we can utilize to send a clear and independent error for the client. Much nicer overall, even if I say so myself.And it just occurred to me that this mimics quite nicely the same approach that Zig itself uses for error handling .</p>
        <a href="https://ayende.com/blog/194882-A/a-pki-less-secure-communication-channel-implementing-the-record-stream" target="_blank"><h1 class="title mb-6">A PKI-less secure communication channel</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: October 07, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">We now have managed to do a proper handshake and both client and server has a shared key. The client has also verified that the server is who they thought it should be, the server knows who the client is and can lookup whatever authorization such a client is ought to get. The next step we have to take is actually starting sending data over the wire. I mentioned earlier that while conceptually, we are dealing with a stream of data, in practice, we have to send the data as independent records. That is done so we can properly verify that they weren&#x2019;t meddled with along the way (either via cosmic radiation or malicious intent).We&#x2019;ll start with the writing data, which is simple. We initiate the write side of the connection using CryptoWriter:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: *std.mem.Allocator, stream: TStream, secret_keys: sodium.SecretKeys) !CryptoWriter {&#xA;        &#xA;        &#xA;          &#xA;              var buf = try allocator.alloc(u8, RecordBufferSize * 2);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var self: CryptoWriter = .{&#xA;        &#xA;        &#xA;          &#xA;                  .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = buf,&#xA;        &#xA;        &#xA;          &#xA;                  .writer = stream.writer(),&#xA;        &#xA;        &#xA;          &#xA;                  .padder = null,&#xA;        &#xA;        &#xA;          &#xA;                  .stream = stream,&#xA;        &#xA;        &#xA;          &#xA;                  .state = undefined,&#xA;        &#xA;        &#xA;          &#xA;                  .alert_raised = false,&#xA;        &#xA;        &#xA;          &#xA;                  .buffered = 0,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_init_push(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;secret_keys.transmit[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnableToPushStreamHeader;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.writer.writeAll(self.buffer[0..c.crypto_secretstream_xchacha20poly1305_HEADERBYTES]);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We allocate a buffer that is 32KB in size (16KB x 2). The record size we selected is 16KB. Unlike TLS, this is an inclusive size, so the entire thing must fit in 16KB. We need to allocate 32KB because the API we use does not support in place encryption. You&#x2019;ll note that we reserved some space in the header (5 bytes, to be exact) for our own needs. You&#x2019;ll note that we initialize the stream and send the stream header to the other side in here, that is the only reference for cryptography in the initialization. The actual writing isn&#x2019;t really that interesting, we are pushing all the data to the buffer, until we run out of space, then we call flush(). I&#x2019;ve written this code in plenty of languages, and it is pretty straightforward, if tedious.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn write(self: *CryptoWriter, buffer: []const u8) !usize {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_raised) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AlertAlreadyRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var buf = buffer;&#xA;        &#xA;        &#xA;          &#xA;              var total_size: usize = 0;&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  var size = std.math.min(buf.len, RecordBufferSize - self.buffered);&#xA;        &#xA;        &#xA;          &#xA;                  total_size &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, self.buffer[self.buffered..RecordBufferSize], buf[0..size]);&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered &#x2B;= size;&#xA;        &#xA;        &#xA;          &#xA;                  buf = buf[size..];&#xA;        &#xA;        &#xA;          &#xA;                  if (self.buffered == RecordBufferSize) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.flush(RecordTypes.Data);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (buf.len == 0)&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return total_size;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.write.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There isn&#x2019;t anything happening here, until we call to flush(RecordTypes.Data) &#x2013; that is an indication to the other side that this is application data, rather than some protocol level message. The flush() method is where things gets really interesting.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn flush(self: *CryptoWriter, rec_type: RecordTypes) !void {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_raised) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AlertAlreadyRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.buffered &gt; MaxPlainTextSize) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.PlainTextRecordSizeToLarge; // should never happen&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, self.buffer[2..4], @intCast(u16, self.buffered - @sizeOf(u16)), .Little);&#xA;        &#xA;        &#xA;          &#xA;              self.buffer[4] = @enumToInt(rec_type);&#xA;        &#xA;        &#xA;          &#xA;              if (self.padder) |padder| {&#xA;        &#xA;        &#xA;          &#xA;                  var pad_len = padder(self, self.buffered);&#xA;        &#xA;        &#xA;          &#xA;                  if (pad_len &#x2B; self.buffered &gt; MaxPlainTextSize)&#xA;        &#xA;        &#xA;          &#xA;                      return error.InvalidPaddingLengthProvided;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.set(u8, self.buffer[self.buffered..(self.buffered &#x2B; pad_len)], 0);&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered &#x2B;= pad_len;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var len: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;              var encrypted = self.buffer[RecordBufferSize..];&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_push(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;encrypted[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;len,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                  self.buffered - @sizeOf(u16),&#xA;        &#xA;        &#xA;          &#xA;                  null,&#xA;        &#xA;        &#xA;          &#xA;                  0,&#xA;        &#xA;        &#xA;          &#xA;                  0,&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnableToPushEncryptedRecord;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (len &gt; RecordBufferSize - @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.EncryptedRecordSizeTooBig; // should never happen&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, encrypted[0..2], @intCast(u16, len &#x2B; @sizeOf(u16)), .Little);&#xA;        &#xA;        &#xA;          &#xA;              try self.writer.writeAll(encrypted[0 .. len &#x2B; @sizeOf(u16)]);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter,flush.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is a lot of code here, I know. Let&#x2019;s see if I can take it in all, there are some preconditions that should be fairly obvious, then we write the size of the plain text value as well as the record type to the header (that part of the header will be encrypted, mind). The next step is interesting, we invoke a callback to get an answer about how much padding we should use. There is a lot of information about padding. In general, just looking at the size of the data can tell you about what is going on, even if there is nothing else you can figure out. If you know that the &#x201C;Attack At Dawn&#x201D;&#xA0; is 14 chars long, and with the encryption overhead that turns to a 37 bytes message, that along can tell you much. Assume that you can&#x2019;t figure out the contents, but can sniff the sizes. That can be a problem. There are certain attacks that rely on leaking the size of messages to work, the BREACH attack, for example, relies on being able to send text that would collide with secret pieces of the message. Analyzing the size of the data that is sent will tell us when we managed to find a match (because the size will be reduced). To solve that, you can define a padding policy. For example, all messages are always exactly 16KB in size, and you&#x2019;ll send an empty message every second if there is no organic traffic. Alternatively, you may select to randomize the message size (to further confuse things). At any rate, this is a pretty complex topic,and not something that I wanted to get too much into. Being able to let the user decide gives me both worlds. This is a match to SSL_CTX_set_record_padding_callback() on OpenSSL.The rest is just calling to libsodium to do the actual encryption, setting the encrypted envelope size and sending it to the other side. Note that we use the other half of the buffer here to store the encrypted portion of the data. In addition to sending application data, we can send alerts to the other side. That is an protocol level error message. I&#x2019;ll actually have a separate post to talk about error handling, but for now, let&#x2019;s see how sending an alert looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn send_alert(self: *CryptoWriter, alert_type: AlertTypes, msg: []u8) !void {&#xA;        &#xA;        &#xA;          &#xA;              defer {&#xA;        &#xA;        &#xA;          &#xA;                  self.alert_raised = true;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (msg.len &#x2B; @sizeOf(AlertTypes) &#x2B; @sizeOf(u16) &gt; MaxPlainTextSize) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.PlainTextRecordSizeToLarge;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, self.buffer[(HeaderSize &#x2B; @sizeOf(AlertTypes))..], msg);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.writeInt(u16, self.buffer[HeaderSize .. HeaderSize &#x2B; @sizeOf(u16)], @enumToInt(alert_type), .Little);&#xA;        &#xA;        &#xA;          &#xA;              self.buffered = HeaderSize &#x2B; @sizeOf(AlertTypes) &#x2B; msg.len; // we discard everything else&#xA;        &#xA;        &#xA;          &#xA;              try self.flush(RecordTypes.Alert);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoWriter.alert.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Basically, we overwrite whatever there is on the buffer, and we flush it immediately to the other side. We also set the alert_raised flag, which will prevent any further usage of the stream. Once an error was sent, we are done. We aren&#x2019;t closing the stream because that is the job for the calling code, which will get an error and close us during normal cleanup procedures.The reading process is a bit more involved, on the other hand. We start by mirroring the write, pulling the header from the network and initializing the stream:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn init(allocator: *std.mem.Allocator, source: TStream.Reader, secret_keys: sodium.SecretKeys) !CryptoReader {&#xA;        &#xA;        &#xA;          &#xA;              var buf = try allocator.alloc(u8, RecordBufferSize * 2);&#xA;        &#xA;        &#xA;          &#xA;              errdefer allocator.free(buf);&#xA;        &#xA;        &#xA;          &#xA;              var self: CryptoReader = .{&#xA;        &#xA;        &#xA;          &#xA;                  .allocator = allocator,&#xA;        &#xA;        &#xA;          &#xA;                  .reader = source,&#xA;        &#xA;        &#xA;          &#xA;                  .buffer = buf,&#xA;        &#xA;        &#xA;          &#xA;                  .incoming = &amp;[0]u8{},&#xA;        &#xA;        &#xA;          &#xA;                  .incoming_plain_text = &amp;[0]u8{},&#xA;        &#xA;        &#xA;          &#xA;                  .state = undefined,&#xA;        &#xA;        &#xA;          &#xA;                  .alert_code = null,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try self.reader.readNoEof(self.buffer[0..c.crypto_secretstream_xchacha20poly1305_HEADERBYTES]);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_secretstream_xchacha20poly1305_init_pull(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.buffer[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;secret_keys.recieve[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.FailedToInitCryptoStream;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return self;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.init.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The real fun starts when we need to actually read things, let&#x2019;s take a look at the code and then I&#x2019;ll explain it in details:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn read(self: *CryptoReader, buffer: []u8) !usize {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_code) |_| {&#xA;        &#xA;        &#xA;          &#xA;                  return error.AnAlertWasRaised;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              if (self.incoming_plain_text.len &gt; 0) { // read from buffer&#xA;        &#xA;        &#xA;          &#xA;                  return self.read_buffer(buffer);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              while (true) {&#xA;        &#xA;        &#xA;          &#xA;                  while (self.incoming.len &lt; @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.read_from_network();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var env_len = std.mem.readInt(u16, self.incoming[0..2], .Little);&#xA;        &#xA;        &#xA;          &#xA;                  if (env_len == 0 or env_len &gt; RecordBufferSize) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.InvalidCryptoEnvelopeSize;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  while (env_len &gt; self.incoming.len) {&#xA;        &#xA;        &#xA;          &#xA;                      try self.read_from_network(); // read enough bytes from network&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming_plain_text = self.buffer[RecordBufferSize..];&#xA;        &#xA;        &#xA;          &#xA;                  var len: u64 = 0;&#xA;        &#xA;        &#xA;          &#xA;                  if (c.crypto_secretstream_xchacha20poly1305_pull(&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.state,&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.incoming_plain_text[0],&#xA;        &#xA;        &#xA;          &#xA;                      &amp;len,&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      &amp;self.incoming[@sizeOf(u16)],&#xA;        &#xA;        &#xA;          &#xA;                      env_len - @sizeOf(u16),&#xA;        &#xA;        &#xA;          &#xA;                      null,&#xA;        &#xA;        &#xA;          &#xA;                      0,&#xA;        &#xA;        &#xA;          &#xA;                  ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.FailedToDecryptRecord;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, self.incoming, self.incoming[env_len..]);&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming = self.incoming[env_len..];&#xA;        &#xA;        &#xA;          &#xA;                  if (len &lt; @sizeOf(u16)) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.DecryptedRecordIsTooSmall;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var plain_txt_len = std.mem.readInt(u16, self.incoming_plain_text[0..2], .Little);&#xA;        &#xA;        &#xA;          &#xA;                  if (plain_txt_len == 0) {&#xA;        &#xA;        &#xA;          &#xA;                      continue; // allowed to have empty record&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  var record_type = @intToEnum(RecordTypes, self.incoming_plain_text[@sizeOf(u16)]);&#xA;        &#xA;        &#xA;          &#xA;                  self.incoming_plain_text = self.incoming_plain_text[@sizeOf(u16) &#x2B; @sizeOf(u8) .. plain_txt_len];&#xA;        &#xA;        &#xA;          &#xA;                  if (record_type == .Alert) {&#xA;        &#xA;        &#xA;          &#xA;                      self.alert_code = @intToEnum(AlertTypes, std.mem.readInt(u16, self.incoming_plain_text[0..@sizeOf(u16)], .Little));&#xA;        &#xA;        &#xA;          &#xA;                      self.incoming_plain_text = self.incoming_plain_text[@sizeOf(u16)..];&#xA;        &#xA;        &#xA;          &#xA;                      return error.AnAlertWasRaised;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  break;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return self.read_buffer(buffer);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.read.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We first check if an alert was raised, if it was, we immediately abort, since the stream is now dead. If there are any plain text bytes, we can return them directly from the buffer. We&#x2019;ll look into that as well as how we read from the network shortly. For now, let&#x2019;s focus on what we are doing here.We read enough from the network to know what is the envelope length that we have to read. That value, if you&#x2019;ll remember, is the first value that we send for a record and is not encrypted (there isn&#x2019;t much point, you can look at the packet information to get that if you wanted to). We then make sure that we read the entire record to the buffer. We decrypt the data from the incoming buffer to the plain_text buffer (that is what the read_buffer()&#xA0; function will use to actually return results).The rest of the code is figuring out what we actually got. We check what is the actual size of the data we received. We may have received a zero length value, so we have to handle this.We check whatever we got a data record or an alert. If the later, we mark it as such and return an error. If this is just the data, we setup the plain text buffer properly and go to the read_buffer() call to return the values.&#xA0; That is a lot of code, but not a lot of functionality. Simple code is best, and this match that scenario. Let&#x2019;s see how we handle the actual buffer and network reads:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn read_buffer(self: *CryptoReader, buffer: []u8) usize {&#xA;        &#xA;        &#xA;          &#xA;              var size = std.math.min(self.incoming_plain_text.len, buffer.len);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, buffer, self.incoming_plain_text[0..size]);&#xA;        &#xA;        &#xA;          &#xA;              self.incoming_plain_text = self.incoming_plain_text[size..];&#xA;        &#xA;        &#xA;          &#xA;              return size;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          fn read_from_network(self: *CryptoReader) !void {&#xA;        &#xA;        &#xA;          &#xA;              var existing = self.incoming.len; // we may have data already in buffer, but need more...&#xA;        &#xA;        &#xA;          &#xA;              var len = try self.reader.read(self.buffer[existing..(RecordBufferSize - existing)]);&#xA;        &#xA;        &#xA;          &#xA;              if (len == 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.UnexpectedEndOfStream;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              self.incoming = self.buffer[0..(existing &#x2B; len)];&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.buffer-net.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Not much here, just need to make sure that we handle partial reads as well as reading multiple records in one shot. We saw that when we get an alert, we return an error. But the question is, how do we get the actual alert? The answer is that we store the message in the plain text buffer and record the alert itself. All future calls will fail with an error. You can then call to the alert()&#xA0; function to get the actual details:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn alert(self: *CryptoReader) !Alert {&#xA;        &#xA;        &#xA;          &#xA;              if (self.alert_code) |code| {&#xA;        &#xA;        &#xA;          &#xA;                  var rc = Alert{ .alert = code, .msg = self.incoming_plain_text };&#xA;        &#xA;        &#xA;          &#xA;                  return rc;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return error.NoAlertRecieved;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CryptoReader.alert.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This gives us a nice API to use when there are issues with the stream. I think that matches well with the way Zig handles errors, but I can&#x2019;t tell whatever this is idiomatic Zig.That is long enough for now, you can go and read the actual code, of course. And I will welcome any comments. In the next (and likely last) post in the series, I&#x201D;m going to go over error handling at the protocol level.</p>
        <a href="https://ayende.com/blog/194881-A/a-pki-less-secure-communication-channel-coding-the-handshake" target="_blank"><h1 class="title mb-6">A PKI-less secure communication channel</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: October 06, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After figuring out the design, let&#x2019;s see what it would take to actually write a secured communication channel, sans PKI, in code. I&#x2019;m going to use Zig as the language of choice here. It is as low level as C, but so much nicer to work with. To actually implement the cryptographic details, I&#x2019;m going to lean on libsodium to do all the heavy lifting. It took multiple iterations of the code to get to this point, but I&#x2019;m pretty happy with how it turned out. I&#x2019;ll start from the client code, which connects to a remote server and establish a secured TCP channel, here is what this looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          fn clientFn(&#xA;        &#xA;        &#xA;          &#xA;              host: []const u8,&#xA;        &#xA;        &#xA;          &#xA;              port: u16,&#xA;        &#xA;        &#xA;          &#xA;              server_pub_key: [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;              client_kp: crypto.KeyPair,&#xA;        &#xA;        &#xA;          &#xA;          ) !void {&#xA;        &#xA;        &#xA;          &#xA;              var server_key = protocol.Client.ExpectedPublicKey{&#xA;        &#xA;        &#xA;          &#xA;                  .end_public_key = server_pub_key,&#xA;        &#xA;        &#xA;          &#xA;                  .middlebox_public_key = server_pub_key,&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              var con = try crypto.clientConnection(&#xA;        &#xA;        &#xA;          &#xA;                  std.heap.page_allocator,&#xA;        &#xA;        &#xA;          &#xA;                  host,&#xA;        &#xA;        &#xA;          &#xA;                  port,&#xA;        &#xA;        &#xA;          &#xA;                  client_kp,&#xA;        &#xA;        &#xA;          &#xA;                  server_key,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              defer con.stream.deinit();&#xA;        &#xA;        &#xA;          &#xA;              var encrypted_stream = con.stream;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var buf: [1024]u8 = undefined;&#xA;        &#xA;        &#xA;          &#xA;              // read normal message&#xA;        &#xA;        &#xA;          &#xA;              var len = try encrypted_stream.reader().read(&amp;buf);&#xA;        &#xA;        &#xA;          &#xA;              std.log.debug(&quot;{s}&quot;, .{buf[0..len]});&#xA;        &#xA;        &#xA;          &#xA;              // handle errors from the other side&#xA;        &#xA;        &#xA;          &#xA;              _ = encrypted_stream.reader().read(&amp;buf) catch |e| {&#xA;        &#xA;        &#xA;          &#xA;                  std.log.debug(&quot;err {s}&quot;, .{@errorName(e)});&#xA;        &#xA;        &#xA;          &#xA;                  var a = try encrypted_stream.alert();&#xA;        &#xA;        &#xA;          &#xA;                  std.log.debug(&quot;{s} {s} {s}&quot;, .{ @errorName(e), @tagName(a.alert), a.msg });&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          client.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The function connects to a server, expecting it to use a particular public key, and will authenticate using a provided key pair. The bulk of the work is done in the crypto.clientConnection() call, where we are following the handshake I outlined here. The result of the call is an AuthenticatedConnection structure, containing both the encrypted stream as well as the public key of the other side. Note that from the client side, if the server doesn&#x2019;t authenticate using the expected key, the call will fail with an error, so for clients, it is usually not important to check the public key, that is already something that we checked.The actual stream we return expose a reader and writer instances that you can use to talk to the other side. Note that we are using buffered data, so writing to the stream will not do anything until the buffer is full (about 16KB) or flush() is called.The other side is the server, of course, which looks like this:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var client : std.net.Connection = try server.accept();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var con = try crypto.serverConnection(std.heap.page_allocator, client.stream, server_kp);&#xA;        &#xA;        &#xA;          &#xA;          std.log.debug(&quot;Connected, I&#x27;m {s} - other side {s}&quot;, .{&#xA;        &#xA;        &#xA;          &#xA;              crypto.KeyPair.keyBase64(server_kp.public),&#xA;        &#xA;        &#xA;          &#xA;              crypto.KeyPair.keyBase64(con.pub_key),&#xA;        &#xA;        &#xA;          &#xA;          });&#xA;        &#xA;        &#xA;          &#xA;          var encrypted_stream = con.stream;&#xA;        &#xA;        &#xA;          &#xA;          defer encrypted_stream.deinit();&#xA;        &#xA;        &#xA;          &#xA;          var w = encrypted_stream.writer();&#xA;        &#xA;        &#xA;          &#xA;          try w.writeAll(&quot;hi there&quot;);&#xA;        &#xA;        &#xA;          &#xA;          try encrypted_stream.flush();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var msg = &quot;Opps, msg&quot;.*;&#xA;        &#xA;        &#xA;          &#xA;          try encrypted_stream.send_alert(crypto.AlertTypes.Badness, &amp;msg);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          server.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;On the server side, we have the crypto.serverConnection() call, it accepts a new connection from a listening socket and starts the handshake process. Note that this code, unlike the client, does not verify that the other side is known to us. Instead, we return that to the caller which can then check the public key of the client. This is intentional, because at this point, we have a secure channel, but not yet authentication. The server can then safely tell the other side that they authorize them (or not) using the channel with not one being able to peek what is going on there.Let&#x2019;s dig a bit deeper into the implementation. We&#x2019;ll start from the client code, which is simpler:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn clientConnection(&#xA;        &#xA;        &#xA;          &#xA;              allocator: *std.mem.Allocator,&#xA;        &#xA;        &#xA;          &#xA;              host: []const u8,&#xA;        &#xA;        &#xA;          &#xA;              port: u16,&#xA;        &#xA;        &#xA;          &#xA;              client_keys: crypto.KeyPair,&#xA;        &#xA;        &#xA;          &#xA;              expected_server_key: ?protocol.Client.ExpectedPublicKey,&#xA;        &#xA;        &#xA;          &#xA;          ) !AuthenticatedConnection {&#xA;        &#xA;        &#xA;          &#xA;              var con = try std.net.tcpConnectToHost(allocator, host, port);&#xA;        &#xA;        &#xA;          &#xA;              errdefer con.close();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var handshake = protocol.Client.init(client_keys, expected_server_key);&#xA;        &#xA;        &#xA;          &#xA;              var hello = try handshake.hello();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = con.writer();&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;hello));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var reader = con.reader();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var msg: protocol.ChallengeMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              try reader.readNoEof(std.mem.asBytes(&amp;msg));&#xA;        &#xA;        &#xA;          &#xA;              var response = try msg.respond(&amp;handshake);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              try writer.writeAll(std.mem.asBytes(&amp;response));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var session = try handshake.generateKey();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var rc: AuthenticatedConnection = undefined;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;rc.pub_key, &amp;handshake.server.long_term_public_key);&#xA;        &#xA;        &#xA;          &#xA;              rc.stream = try crypto.NetworkStream.init(allocator, con, session);&#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          clientConnection.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The handshake protocol itself is handled by the protocol.Client. The way I have coded it, we are reading known lengths from the network into in memory structure and using them directly. I can do that because the structures are basically just bunch of packed []u8 (char arrays), so the in memory and network representation are one and the same. That makes things simpler. You can see that I&#x2019;m calling readNoEof on the structures as bytes. That ensure that I get the whole message from the network and then the actual operations that I need to make are handled. Here is the sequence of operations:After sending the hello, the server will respond with a challenge, the client replies and both sides now know that they other side is who they say they are.Let&#x2019;s dig a bit deeper, shall we, and see how we have the hello message:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn hello(self: *Client) !HelloMessage {&#xA;        &#xA;        &#xA;          &#xA;              var req: HelloMessage = undefined;&#xA;        &#xA;        &#xA;          &#xA;              req.version = Client.ExpectedVersion;&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(u8, &amp;req.client_session_public_key, &amp;self.session.public);&#xA;        &#xA;        &#xA;          &#xA;              std.mem.copy(&#xA;        &#xA;        &#xA;          &#xA;                  u8,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;req.expected_server_public_key.data,&#xA;        &#xA;        &#xA;          &#xA;                  &amp;self.server.expected_server_key.end_public_key,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              try req.expected_server_public_key.encrypt(&#xA;        &#xA;        &#xA;          &#xA;                  self.server.expected_server_key.middlebox_public_key,&#xA;        &#xA;        &#xA;          &#xA;                  self.session.secret,&#xA;        &#xA;        &#xA;          &#xA;              );&#xA;        &#xA;        &#xA;          &#xA;              return req;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          pub fn EncryptedBoxBuffer(size: usize) type {&#xA;        &#xA;        &#xA;          &#xA;              return packed struct {&#xA;        &#xA;        &#xA;          &#xA;                  const Self = @This();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  data: [size]u8,&#xA;        &#xA;        &#xA;          &#xA;                  mac: [mac_len]u8,&#xA;        &#xA;        &#xA;          &#xA;                  nonce: [nonce_len]u8,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  pub fn encrypt(&#xA;        &#xA;        &#xA;          &#xA;                      self: *Self,&#xA;        &#xA;        &#xA;          &#xA;                      public_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                      secret_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                  ) !void {&#xA;        &#xA;        &#xA;          &#xA;                      c.randombytes_buf(&amp;self.nonce, self.nonce.len);&#xA;        &#xA;        &#xA;          &#xA;                      var rc = c.crypto_box_detached(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.mac,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          size,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.nonce,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;public_key,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;secret_key,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.EncryptionFailure;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  pub fn decrypt(&#xA;        &#xA;        &#xA;          &#xA;                      self: *Self,&#xA;        &#xA;        &#xA;          &#xA;                      public_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                      secret_key: [KeyLen]u8,&#xA;        &#xA;        &#xA;          &#xA;                  ) !void {&#xA;        &#xA;        &#xA;          &#xA;                      var rc = c.crypto_box_open_detached(&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.data[0],&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.mac,&#xA;        &#xA;        &#xA;          &#xA;                          size,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;self.nonce,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;public_key,&#xA;        &#xA;        &#xA;          &#xA;                          &amp;secret_key,&#xA;        &#xA;        &#xA;          &#xA;                      );&#xA;        &#xA;        &#xA;          &#xA;                      if (rc != 0) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.DecryptionFailure;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          hello.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There isn&#x2019;t much here, we set the version field to a known value, we copy our own session public key (which was just generated and tells no one nothing about us) and then we copy the expected server public key, but we aren&#x2019;t sending that over the wire in the clear. Instead, we encrypt that. We encrypt it with the client session public key (which we just send over) as well as the expected middlebox key (remember, those might be different). The idea is that the server on the other end may decide to route the request, but at the same time, we want to ensure that we are never revealing any information to 3rd parties. The actual encryption is handled via the EncryptedBoxBuffer structure, you can see that I&#x2019;m using Zig&#x2019;s comptime support to generate a structure with a compile time variant size. That make is trivial to do certain things without really needing to think about the details. It used to be more complex, and be able to support arbitrary embedded structures, but I simplified it to a single buffer. For that matter, for most of the code here, the size I&#x2019;m using is fixed (32 bytes / 256 bits). The key here is that all the details of nonce generation, MAC validation, etc are hidden and handled. I also don&#x2019;t really need to think about the space for that, since this directly part of the structure.It gets more interesting when we look at how the client respond to the challenge from the server:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub const ChallengeMessage = packed struct {&#xA;        &#xA;        &#xA;          &#xA;              server_session_public_key: [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;              server_long_term_public_key: crypto.EncryptedBoxKey,&#xA;        &#xA;        &#xA;          &#xA;              long_term_key_proof: crypto.EncryptedBoxKey,&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              pub fn respond(self: *ChallengeMessage, state: *Client) !ChallengeResponse {&#xA;        &#xA;        &#xA;          &#xA;                  var resp = std.mem.zeroes(ChallengeResponse);&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;state.server.session_public_key, &amp;self.server_session_public_key);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.server_long_term_public_key.decrypt(self.server_session_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;state.server.long_term_public_key, &amp;self.server_long_term_public_key.data);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (state.server.validate_server_key) {&#xA;        &#xA;        &#xA;          &#xA;                      if (!std.crypto.utils.timingSafeEql(&#xA;        &#xA;        &#xA;          &#xA;                          [crypto.KeyLength]u8,&#xA;        &#xA;        &#xA;          &#xA;                          state.server.expected_server_key.end_public_key,&#xA;        &#xA;        &#xA;          &#xA;                          state.server.long_term_public_key,&#xA;        &#xA;        &#xA;          &#xA;                      )) {&#xA;        &#xA;        &#xA;          &#xA;                          return error.ExpectedServerPublicKeyMismatch;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try self.long_term_key_proof.decrypt(state.server.long_term_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (!std.crypto.utils.timingSafeEql([crypto.KeyLength]u8, self.long_term_key_proof.data, state.session.public)) {&#xA;        &#xA;        &#xA;          &#xA;                      return error.LongTermProofValueAndSessionPublicKeyMismatch;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;resp.client_long_term_key.data, &amp;state.long_term.public);&#xA;        &#xA;        &#xA;          &#xA;                  try resp.client_long_term_key.encrypt(state.server.session_public_key, state.session.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  std.mem.copy(u8, &amp;resp.challenge_answer.data, &amp;state.server.session_public_key);&#xA;        &#xA;        &#xA;          &#xA;                  try resp.challenge_answer.encrypt(state.server.session_public_key, state.long_term.secret);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  return resp;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ChallengeMessage.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We copy the server&#x2019;s session public key to our own state, then we decrypt the server&#x2019;s long term public key using the public key that we were sent alongside the client&#x2019;s own secret key. Without both of them, we cannot decrypt the information that was sealed using the server&#x2019;s secret key and the client&#x2019;s public key. Remember that we have a very important distinction here:Session key pair &#x2013; generated per connection, transient, meaningless. If you know what the session public key is, you don&#x2019;t get much.Long term key pair &#x2013; used for authentication of the other side. If you know what the long term public key, you may figure out who the client or server are.Because of that, we never send the long term public keys in the clear. However, just getting the public key isn&#x2019;t enough, we need to ensure that the other side actually holds the full keypair, not just saying that it does.We handle that part asking that the server will encrypt the client&#x2019;s public session key using its long term secret key. Because the public session key is something that the client controls, the fact that the server can produce a value that decrypt to that using the stated public key ensures that it holds the secret portion as well. To answer the challenge, we do much the same thing in reverse. In other words, we are encrypting the server&#x2019;s public session key with our own long term key and sending that to the server. The final step is actually generating the symmetric keys for the channel, which is done using:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          pub fn generate_client(client: KeyPair, server_public_key: [KeyLen]u8) !SecretKeys {&#xA;        &#xA;        &#xA;          &#xA;              var rc: SecretKeys = undefined;&#xA;        &#xA;        &#xA;          &#xA;              if (c.crypto_kx_client_session_keys(&#xA;        &#xA;        &#xA;          &#xA;                  &amp;rc.recieve[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;rc.transmit[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;client.public[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;client.secret[0],&#xA;        &#xA;        &#xA;          &#xA;                  &amp;server_public_key[0],&#xA;        &#xA;        &#xA;          &#xA;              ) != 0) {&#xA;        &#xA;        &#xA;          &#xA;                  return error.FailedToGenerateKey;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return rc;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          gen_keys.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We are using the client&#x2019;s session key pair as well as the server&#x2019;s public key to generate a shared secret. Actually, a pair of secrets, one for sending and one for receiving. On the other side, you do pretty much the same in reverse. You can see the full source code here. This is only a partial work, of course, we still need to deal with the issue of actually sending data after the handshake, I&#x2019;ll deal with that in my next post.</p>
        <a href="https://ardalis.com/better-faster-demos-with-screencast-videos/" target="_blank"><h1 class="title mb-6">Better Faster Demos with Screencast Videos</h1></a>
        <p class="mb-2">by Ardalis</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: October 06, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Do you ever need to demo your app to users, customers, or stakeholders? Is it part of your regular software delivery process? What about&#x2026;Keep Reading &#x2192;</p>
        <a href="https://ayende.com/blog/194849-B/a-pki-less-secure-communication-channel-the-record-layer" target="_blank"><h1 class="title mb-6">A PKI-less secure communication channel</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: October 04, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I talked a lot about the manner in which both client and server will authenticate one another safely and securely. The reason for all the problem is that we want to ensure that we are talking to the entity we believe we do, protect ourselves from man in the middle, etc. The entire purpose of the handshake exchange is to establish that the person on the other side is the right one and not a malicious actor (like the coffee shop router or the corporate firewall). Once we establish who is on the other side, the rest is pretty easy. Each side of the connection generated a key pair specifically for this connection. They then managed to send each other both the other side&#x2019;s public key as well as prove that they own another key pair (trust in which was established separately, in an offline manner).In other words, on each side, we have:My key pair (public, secret)&#xA;Other side public keyWith those, we can use key exchange to derive a shared secret key. The gist of this is that we know that this statement holds:op(client_secret, server_public) == op(server_secret, client_public)The details on the actual op() aren&#x2019;t important for understanding, but I&#x2019;m using sodium, so this is scalar multiplication over curve 25519. If this tells you anything, great. Otherwise, you can trust that people who do understand the math says that this is safe to do. Diffie-Hellman is the search term to use to understand how this works.Now that we have a shared secret key, we can start sending data to one another, right? It would appear that the answer to that is&#x2026; no. Or at least, not yet. The communication channel that we build here is based is built on top of TCP, providing two way communication for client and server. The TCP uses the stream abstraction to send data over the wire. That does not work with modern cryptographic algorithm.How can that be? After is literally this thing called stream cipher, after all. If you cannot use a stream cipher for stream, what is it for?A stream cipher is a basic building block for modern cryptography. However, it also has a serious problem. It doesn&#x2019;t protect you from modification of the ciphertext. In other words, you will &#x201C;successfully&#x201D; decrypt the value and use it, even though it was modified. Here is a scary scenario of how you can abuse that badly.Because of such issues, all modern cryptographic algorithms uses Authenticated Encryption. In other words, to successfully complete their operation, they require that the cipher stream will match a cryptographic key. In other words, conceptually, the first thing that a modern cipher will do on decryption is something like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          def decrypt(key, nonce, cipher_text):&#xA;        &#xA;        &#xA;          &#xA;            mac = cipher_text[:16] # last 16 bytes are the signature&#xA;        &#xA;        &#xA;          &#xA;            expected_mac = crypto_hash(key, nonce, cipher_text[0:-16])&#xA;        &#xA;        &#xA;          &#xA;            if not timeSafeEql(mac, expected_mac):&#xA;        &#xA;        &#xA;          &#xA;              raise &quot;Invalid cipher text&quot;&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            return actually_decrypt(key, nonce, cipher_text[0:-16])&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          cipher.py&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;That isn&#x2019;t quite how this looks like, but it is close enough to understand what is going on. If you want to look at how a real implementation does it, you can look here. The python code is nicer, but this is basically the same concept.So, why does that matter for us? How does this relate to having to dealing with streams?Consider the following scenario, in this model, in order to successfully decrypt anything, we first need to validate the MAC (message authentication code) for the encrypted value. But in order to do that, we have to have the whole value, not just part of that. In other words, we cannot use a real stream, instead, we need to send the data in chunks. The TLS protocol has the same issue, that is handled via the notion of records, with a maximum size of about 16KB. So a TLS stream is actually composed of records that are processed independently from one another. That also means that before you get to the TLS a buffered stream is a must, otherwise we&#x2019;ll send just a few plain text bytes for a lot of cryptographic envelope. In other words, if you call tls.Write(buffer[0..4]), if you don&#x2019;t have buffering, this will send a packet with a cryptographic envelope that is much bigger than the actual plain text value that you sent.&#xA0; Looking at the TLS record layer, I think that I&#x2019;ll adopt many of the same behaviors. Let&#x2019;s consider a record:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          RecordEnvelope = {&#xA;        &#xA;        &#xA;          &#xA;            Len  : u16,       // Max 16KB, *includes* the size of Len&#xA;        &#xA;        &#xA;          &#xA;            Record : [Len -2]u8  // The cipher text&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          Record = {&#xA;        &#xA;        &#xA;          &#xA;            Len  : u16,        // &lt; RecordEnvelope.Len, includes the size of Len &amp; Data.&#xA;        &#xA;        &#xA;          &#xA;            Type : u8,         // Data | Alert&#xA;        &#xA;        &#xA;          &#xA;            Data : [Len - 3]u8,    // If Alert - Lne &gt;= 3 and Data starts with 16 bits error code, then a string for the error itself.&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Note that padding here is explicitly allowed.&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          record.zig&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;So each record is composed of an envelope, that simply contains the length, then we have the cipher text itself. I&#x2019;m intending to use the libsodium&#x2019;s encrypted stream, because it lets me handle things like re-keying on the fly transparently, etc. We read the record from the network, decrypt and then need to decide what to do. If this is an alert, we raise it to the user (this is critical for good error reporting). Note that in this way I can send (an encrypted) stream to the other side to give a good error for the caller. For data, we just pass it to the caller. Note that there is one very interesting aspect here. We have two Len fields. This is because we allow padding, that can help avoid attacks such as BREACH and mitigate traffic analysis.&#xA0; We ensure that the padding is always set to zero, similar in reason to the TLS model, to avoid mistakes and to force implementation correctness.I think that this is enough theory for now. In my next post, I want to get to actually implementing this.As usual, I would love to hear your feedback and comments.</p>
        <a href="https://ayende.com/blog/194819-B/a-pki-less-secure-communication-channel-design" target="_blank"><h1 class="title mb-6">A PKI-less secure communication channel</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: October 01, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Following our recent hiccup with certificate expiration, I spent some time thinking about what we could do better. One of the paths that this led me to was to consider how I would design the underlying communication channel for RavenDB if I had a blank slate. Currently, RavenDB uses TLS over TCP and HTTPS (which is the same thing) as the sole communication mechanism between servers and clients and between the servers in the cluster. That relies on TLS to ensure the safety of the information, as well as client certificates for authentication. TLS, of course, require the use of server certificates, which means that we have mutual authentication between clients and servers. However, the PKI infrastructure that is required to support that is freaking complex. It is mostly invisible, except when it isn&#x2019;t, when something fails.The idea in this design exercise is to consider how I would do things differently. This is a thought exercise only, not something that we intend to put into any kind of system at this point in time. The use of TLS has proven itself to be very successful and was greatly beneficial. I consider such design exercises to be vital to the overall health of a project (and my own mind), because it allows me to dive deeply into a topic and consider this from a different view point. Therefor, I&#x2019;m going to proceed based on the RavenDB&#x2019;s set of requirements, even though this is all theoretical.That disclaimer aside, what do we actually need from an secure communication channel?Build on top of TCP &#x2013; nothing else would do, and while UDP is nice to consider, that isn&#x2019;t relevant for RavenDB&#x2019;s scenario, so not worth considering. RavenDB makes a lot of use of the streaming nature of TCP connections. It allows us to make a lot of assumptions on the state of the other side. The key aspect we take advantage of is the fact that for a given connection, if I send you a document, I can assume that you already go (and processed successfully) all previous documents. That saves a lot of back &amp; forth to maintain distributed state.Encrypted over the wire &#x2013; naturally that means that we need to satisfy the same level of security as TLS.Provide mutual authentication of clients and servers &#x2013; including in a hostile network environment.Let&#x2019;s consider what we want to achieve here. The situation is not deployment of servers and clients by many independent organizations (each distrusting all others). Instead, we are setting up a cluster of RavenDB nodes that will talk to one another as well as any number of clients that will talk to those servers. That means that we can safely assume that there is a background channel which we trust. That remove the need to setup PKI and having a trusted third party that we&#x2019;ll talk to. Instead, we are going to use public key cryptography to do authentication between nodes and clients.Here is how it is going to look like. When setting up a cluster, the admin will generate a key pair, like so:Server Secret: I_lfn5vna3p1OxyJ_kCJzRaBOWD-vio6hvpL6b2qYs8Server Public: oXQJcrZfMNoDDl1ZVSuJlKbREsd5yoprViQOTqmSSCkThe secret portion is going to remain written to the server&#x2019;s configuration file, and the public portion will be used when connecting to the server, to ensure that we are talking to the right one. In the same sense, we&#x2019;ll have the client generate a key pair as well:Client Secret: TVwQXoiYfvuToz5NY8D27bIeJR-LgR4y8gCM4UE3ZScClient Public: 5nNpLTSQmqzh3yttyD1DyM2a2caLORtecPj5LQ2tIHsWith those in place, we can now setup the following configuration on the server side:&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            &quot;Listen&quot;: &quot;tcp://0.0.0.0:1981&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;ServerKeyPair&quot;: {&#xA;        &#xA;        &#xA;          &#xA;              &quot;Secret&quot;: &quot;I_lfn5vna3p1OxyJ_kCJzRaBOWD-vio6hvpL6b2qYs8&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;Public&quot;: &quot;oXQJcrZfMNoDDl1ZVSuJlKbREsd5yoprViQOTqmSSCk&quot;&#xA;        &#xA;        &#xA;          &#xA;            },&#xA;        &#xA;        &#xA;          &#xA;            &quot;AuthorizedClients&quot;: {&#xA;        &#xA;        &#xA;          &#xA;               &quot;5nNpLTSQmqzh3yttyD1DyM2a2caLORtecPj5LQ2tIHs&quot;: { &#xA;        &#xA;        &#xA;          &#xA;                  &quot;SecurityClearance&quot;: &quot;User&quot;,&#xA;        &#xA;        &#xA;          &#xA;                  &quot;Databases&quot;: [&#xA;        &#xA;        &#xA;          &#xA;                    { &quot;Name&quot;: &quot;Northwind&quot;, &quot;Permissions&quot;: &quot;ReadWrite&quot; },&#xA;        &#xA;        &#xA;          &#xA;                    { &quot;Name&quot;: &quot;Southsand&quot;, &quot;Permissions&quot;: &quot;ReadOnly&quot; },&#xA;        &#xA;        &#xA;          &#xA;                  ]&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          settings.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA; Note that the settings.json contains the key pair of the server, but only the public key of the authorized clients. Conversely, the connection string for RavenDB would be:Server=crypto.protocol.ravendb.example;ServerPublicKey=oXQJcrZfMNoDDl1ZVSuJlKbREsd5yoprViQOTqmSSCk; ClientSecretKey=TVwQXoiYfvuToz5NY8D27bIeJR-LgR4y8gCM4UE3ZSc; ClientPublicKey=5nNpLTSQmqzh3yttyD1DyM2a2caLORtecPj5LQ2tIHs; In this case, the client connection string has the key pair of the client, and just the public key of the server. The idea is that we&#x2019;ll use these to validate that either end is actually who we think they are.The details of public key cryptography is beyond the topic of this blog post (or indeed, my own understanding, if you get down to it), but the best metaphor that I found was the color mixing one. I&#x2019;ll remind you that in public key cryptography, we have:Client Secret Key (CSK), Client Public Key (CPK)Server Secret Key (SSK), Server Public Key (SPK)We can use the following operations:Encrypt(CPK, SSK) &#x2013;&gt; Decrypt(SPK, CSK)Encrypt(SPK, CSK) &#x2013;&gt; Decrypt(CPK, SSK)In other words, we can use a public / secret from both ends to encrypt and decrypt the data. Note that so far, everything I did was pretty bog standard Intro to Cryptography 101. Let&#x2019;s see how we take those idea and turn them into an actual protocol. The details are slightly more involved, and instead of using just two key pairs, we actually need to use five(!), let&#x2019;s look at them in turn.The couple of key pairs are the one that we are familiar with, the server&#x2019;s and the client&#x2019;s. However, we are going to tag them with long term key pairs and show them as:The problem with using those keys is that we have to assume that they will leak at some point. In fact, one of the threat model that TLS has is dealing with adversaries that can record all network communication between parties for arbitrary amount of time. Given that this is encrypted, and assuming that no one can deal break the encryption algorithm itself, we need to worry about key leakage after the fact. In other words, if we use a pair of key to communicate securely, but the communication was recorded, it is enough to capture a single key (from either server or client) to be able to decrypt past conversations. That is not ideal. In order to handle that, we introduce the notion of session keys. Those are keys that are in no way or shape are related to the long term keys. They are generated using secured cryptographic method and are used of a single connection. Once that connection is closed, they are discarded.The idea is that even if you manage to lay your hands on the long term keys, the session keys, which are actually used to encrypt the communication, are long gone (and were never kept) anyway. For more details, the Wiki article on Perfect Forward Secrecy does a great job explaining the details.I&#x2019;m counting four pairs of keys so&#xA0; far, but I mentioned that we&#x2019;ll use five in this protocol, what is that about? I&#x2019;m going to introduce the idea of a middlebox key. A middlebox is a server that the client will connect to, the client wants to be able to provide just enough information to the middlebox to route the request to the right location, but without providing any external observer with any idea about what is the final destination of the client is. In essence, this is ESNI (Encrypted Server Name Indication). A key aspect of this is that the client does not trust the middlebox, and the only thing a malicious middlebox can do is to record what is the final destination of the connection. It cannot eavesdrop on the details or modify them in any way.With all of that in place, and hopefully clear, let&#x2019;s talk about the handshake that is required to make both sides verify that the other one is legit. The connection starts with a hello message, with the following details:Client &#x2013;&gt; ServerOverall size: 108 bytesAlgorithm &#x2013; crypto_box (sodium) - Key exchange: X25519 Encryption: XSalsa20 stream cipher Authentication: Poly1305 MACField #SizeContentEncrypted using14VersionPlain text232Client&#x2019;s session public keyPlain text332Expected server public keyMiddlebox&#x2019;s public key &#x2B; Client&#x2019;s session secret key416MAC for field 3&#xA0;524Nonce for field 3&#xA0;This requires some explanation. I know enough to know my limitation with cryptography. I&#x2019;m going to lean on well known and tested library, libsodium for the actual cryptographic details and try to do as little as possible on my own. The hello message details contains just three actual fields , but the third field is encrypted. Modern encryption practices are meant to make it as hard as possible to misuse. That means that pretty much any encryption algorithm that you are likely to use will use Authenticated Encryption. This is to ensure that any modification to the cypher text will fail the decryption process, rather than give corrupted results.To handle that scenario, we need to send a MAC (message authentication code), which you can see as field 4 on the message. The last field is a random value that will be used to ensure that when we encrypt the same data with the same keys, we&#x27;ll not output the same value. That can have catastrophic impact on the safety of your system. You can think of the last two fields as part of the encryption envelope we need to properly encrypt the data.As the first field, we have the protocol version, which allows to change the protocol over time. Note that this is the only choice that we have, there is no negotiation or choice involved here at all. If we want to change the cryptographic details of the protocol, we&#x2019;ll need to create a new version for that. This is in contrast with how TLS works, where we have both clients and servers offering their supported options and having to pick which one to use. That ends up being complex, so it is simpler to tie it down. Wireguard works in a similar manner, for example.You&#x2019;ll notice that the client&#x2019;s session public key is sent in the clear. That is fine, it is the public key, after all, and we ensure that each separate connection will generate a new key pair, there is nothing that can be gleaned from this data.Now, let&#x2019;s go back to the fields that are actually meaningful, the client&#x2019;s session public key and the expected server public key. What is that about?The client will first generate a key pair and send to the server the public portion of that key pair. Along with another keypair, we&#x2019;ll be able to establish communication. However, what other key pair?&#xA0; In order to trust the remote server, we need to know its public key in advance. The administrator will be able to tell us that, of course, but requiring this is a PITA. We may want to implement TUFU (Trust Upon First Use), like SSH does, or we may want to tie ourselves to a particular key. In any event, at the protocol level, we cannot require that the public key for the server will be known before the first message, not if we want to apply it.To solve this issue, we have to consider why we have this expected server public key in the message in the first place. This is there to provide the middlebox a secure manner to discover what server the client wants to connect to. How the client discover the public key of the middlebox is intentionally left blank here. You can use the same manner as ESNI and grab the public key from a DNS entry, for example. Regardless, a key aspect of this is that the expected server public key is meant to be advisory only. If we are able to successfully decrypt it, then we know what server public key the client is looking for. We can lookup in some table and route the connection directly, without being able to figure out anything else on the contents of any future traffic.If we cannot successfully decrypt this, we can just ignore this and assume that the client is expecting any key (at any rate, the client itself will do its own validation down the line). In many cases, by the way, I expect that the middlebox and the end server will be one and the same, this middlebox feature is meant for some advanced scenarios, likely never to be relevant here.The server will reply to the hello message with a challenge, here is how it looks like:Server &#x2013;&gt; ClientOverall size: 168 bytesAlgorithm &#x2013; crypto_box (sodium)Field #SizeContentEncrypted using132Server&#x2019;s session public keyPlain text232Server&#x2019;s long term public keyClient&#x2019;s session public key &#x2B; Server&#x2019;s session secret key316MAC for field 2&#xA0;424Nonce for field 2&#xA0;532Client&#x2019;s session public keyClient&#x2019;s session public key &#x2B; Server&#x2019;s session long term key616MAC for field 6&#xA0;724Nonce for field 6&#xA0;Here we are starting to see some more interesting details. The server is sending its session public key, to complete the key exchange between the client and server. As before, this is a transient value, generated on a per connection basis and has no relation to the actual long term key pair. There it nothing that you can figure out from the plain text public key, so we don&#x2019;t mind sending it.We send the long term key on field 2, on the other hand, encrypted. Why are we encrypting this? To prevent an outside observer from figuring out what server we are using (if we are using a middlebox).The idea is that once we exchange the public keys for the session key pairs for both sides, we&#x2019;ll encrypt the long term public key using this and let the client know. We&#x2019;ll also encrypt the client&#x2019;s session&#x2019;s public key. This time, however, we&#x2019;ll encrypt using the server long term key as well as the client&#x2019;s session public key. The idea is that the server is encrypting a value that the client chose (the client&#x2019;s session public key, which is also transient) and encrypt that with Authenticated Encryption. If the client can successfully decrypt that, we know that the session&#x2019;s public key was encrypted using the long term secret key. In this manner, we prove that we own the long term key pair.The client, upon receiving this message, will do the following:Decrypt field 2 &#x2013; verifying their authenticity using the MAC in field 3.Decrypt field 5 &#x2013; using the public key we got from the server.Assuming that those two decryption procedures were successful, we can compare the plain text value for field 3 and field 6. If they are the same, we know that the server has the long term key pair (both public and secret). If it didn&#x2019;t have the secret portion of the key, the server would be unable to properly encrypt the value so we&#x2019;ll be able to read it. The fact that it does this encryption with the client&#x2019;s session key (which differs on each call) means that you can&#x2019;t do reply / caching or any such tricks.The last thing that the client needs to do now is to figure out if the long term public key they got from the server is a match to the public key that they need. That can be part of a TUFU system, or we can reject the connection if the public key does not match.Client &#x2013;&gt; ServerOverall size: 136 bytesAlgorithm &#x2013; crypto_box (sodium)Field #SizeContentEncrypted using132Client&#x2019;s long term public keyServer&#x2019;s session public key &#x2B; client&#x2019;s session secret key216MAC for field 1&#xA0;324Nonce for field 1&#xA0;424Server&#x2019;s session public keyServer&#x2019;s session public key &#x2B; client&#x2019;s long term secret key216MAC for field 4&#xA0;324Nonce for field 4&#xA0;At this point, the same pattern applies. The server will decrypt the client&#x2019;s long term public key from field 1 using the session keys. It will then use its own secret session key in conjunction with the client&#x2019;s long term public key to decrypt the value in field 4. The act of successfully decrypting the value in field 4 serves as a proof that the client indeed holds the secret key for the long term value. At the end of processing this message, the server know who is the client and verified that they posses the relevant key pair.From there, we are left with the simple act of doing key exchange using the session keys. Now both client and server know who the other side is and have agreed on the cryptographic keys that they will use to communicate with one another.I mentioned that I&#x2019;m not an expert cryptographer, right? The design of this protocol isn&#x2019;t innovative in any way. It takes heavily from the design of TLS 1.3, the most successful cryptographic protocol on the planet, which was design by people who actually know their craft here. What I&#x2019;m mostly doing here is making assumptions, because I can:I don&#x2019;t need PKI infrastructure, the communicating nodes all have a separate channel to establish trust by distributing the public keys. There is no need for negotiation between the client &amp; server, we fixed all the parameters at the protocol version.The messages exchanged are all pretty small, that means that we can put them all on a single packet. Most importantly of all, the entire system relies on local state, there is absolutely nothing here that relies or uses any external party. That is kind of amazing, when you think about it, and obviously one of the major reasons why I&#x2019;m doing this exercise. The tables and description above make it see exactly what is going on, even if they give all the details. I find that code make sense of code samples. Here is some sample code, showing how the server works:&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          class ServerConnection:&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            long_term: KeyPair&#xA;        &#xA;        &#xA;          &#xA;            authorized_clients: []&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;            def accept(self, stream : Stream):&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              (session_sk, session_pk) = gen_key_pair()&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              buffer = stream.read_exactly(108)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              version = int(buffer[0:4])&#xA;        &#xA;        &#xA;          &#xA;              client_session_pk, expected_server_pk, mac, nonce  = buffer[4:36],  buffer[36:68], buffer[68:84], buffer[84, 108]&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              # okay to mess this up&#xA;        &#xA;        &#xA;          &#xA;              if try_decrypt(expected_server_pk, mac, nonce, client_session_pk, long_term.secret):&#xA;        &#xA;        &#xA;          &#xA;                if not timeSafeEqual(expected_server_pk, long_term.public):&#xA;        &#xA;        &#xA;          &#xA;                  log.debug(&quot;wrong server pk requested by client, client will reject connection&quot;)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              long_term_proof_encrypted = encrypt(client_session_pk, client_session_pk, self.long_term.secret)&#xA;        &#xA;        &#xA;          &#xA;              session_pk_encrypted = encrypt(session_pk, client_session_pk, session_sk)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              stream.write(long_term_proof_encrypted &#x2B; session_pk_encrypted)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              buffer = stream.read_exactly(136)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;             client_long_term_key, mac, nonce = buffer[0:32], buffer[32:48], buffer[48:72]&#xA;        &#xA;        &#xA;          &#xA;             if not try_decrypt(client_long_term_key, mac, nonce, client_session_pk, session_sk):&#xA;        &#xA;        &#xA;          &#xA;                raise &quot;Invalid connection: Cannot get long term client key&quot;&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;             challenge_answer, mac, nonce = buffer[72:104], buffer[104:122], buffer[122:136]&#xA;        &#xA;        &#xA;          &#xA;             &#xA;        &#xA;        &#xA;          &#xA;             if not try_decrypt(challenge_answer, mac, nonce, client_long_term_key, session_sk):&#xA;        &#xA;        &#xA;          &#xA;                raise &quot;Invalid connection: Cannot validate challenge&quot;&#xA;        &#xA;        &#xA;          &#xA;                &#xA;        &#xA;        &#xA;          &#xA;             if not timeSafeEqual(challenge_answer, session_pk):&#xA;        &#xA;        &#xA;          &#xA;                raise &quot;Invalid connection: Wrong challenge message&quot;&#xA;        &#xA;        &#xA;          &#xA;                &#xA;        &#xA;        &#xA;          &#xA;             if client_long_term_key not in authorized_clients:&#xA;        &#xA;        &#xA;          &#xA;                raise &quot;Invalid connection: Unknown client&quot;&#xA;        &#xA;        &#xA;          &#xA;                &#xA;        &#xA;        &#xA;          &#xA;             return CryptoStream(stream, client_session_pk, session_sk, session_pk)&#xA;        &#xA;        &#xA;          &#xA;           &#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          server.py&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;The server will read the first message and then send a reply, the client will respond to the challenge, and the server will read the data and validate it. This is meant to be pseudo code, mind you, not real code. Just to get you to figure out how this interacts. Here is the client side of things:&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          class ClientConnection:&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            long_term: KeyPair&#xA;        &#xA;        &#xA;          &#xA;            expected_server_key: bytes&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;            def accept(self, stream: Stream):&#xA;        &#xA;        &#xA;          &#xA;              (session_sk, session_pk) = generate_key_pair()&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if len(expected_server_key) != 32:&#xA;        &#xA;        &#xA;          &#xA;                raise &quot;Invalid server key&quot;&#xA;        &#xA;        &#xA;          &#xA;                &#xA;        &#xA;        &#xA;          &#xA;              validate_server_pk =  any(expected_server_key)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if not validate_server_pk:&#xA;        &#xA;        &#xA;          &#xA;                randombuf(expected_server_key)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              buffer = encrypt(expected_server_key, expected_server_key, session_sk)&#xA;        &#xA;        &#xA;          &#xA;              stream.write(session_pk &#x2B; buffer)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              buffer = stream.read_exactly(168)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              server_session_pk = buffer[0:32]&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              server_long_term_pk, mac, nonce = buffer[32:64], buffer[64:80], buffer[80:96]&#xA;        &#xA;        &#xA;          &#xA;              if not try_decrypt(server_long_term_pk, mac, nonce, server_session_pk,session_sk):&#xA;        &#xA;        &#xA;          &#xA;                raise &quot;Unable to decrypt long term server key&quot;&#xA;        &#xA;        &#xA;          &#xA;                &#xA;        &#xA;        &#xA;          &#xA;              if validate_server_pk:&#xA;        &#xA;        &#xA;          &#xA;                if not timeSafeEqual(server_long_term_pk, expected_server_key):&#xA;        &#xA;        &#xA;          &#xA;                   raise &quot;Unepxected server key&quot;&#xA;        &#xA;        &#xA;          &#xA;                    &#xA;        &#xA;        &#xA;          &#xA;              long_term_proof, mac, nonce = buffer[96:128], buffer[128:144], buffer[144:168]&#xA;        &#xA;        &#xA;          &#xA;              if not try_decrypt(long_term_proof, mac, nonce, server_long_term_pk, session_sk):&#xA;        &#xA;        &#xA;          &#xA;                  raise &quot;Unable to decrypt long term proof&quot;&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;               if not timeSafeEqual(long_term_proof, session_pk):&#xA;        &#xA;        &#xA;          &#xA;                  raise &quot;Bad long term proof&quot;&#xA;        &#xA;        &#xA;          &#xA;               &#xA;        &#xA;        &#xA;          &#xA;              client_long_term_key = encrypt(self.long_term.public, server_session_pk, session_sk)&#xA;        &#xA;        &#xA;          &#xA;              challenge_answer = encrypt(server_session_pk, server_session_pk, self.long_term.secret)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              stream.write(client_long_term_key &#x2B; challenge_answer)&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              return CryptoStream(stream, server_session_pk, session_sk, session_pk)&#xA;        &#xA;        &#xA;          &#xA;             &#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          client.py&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;I hope that the code sample would make it clearer what is going on. I haven&#x2019;t mentioned the key generation for the follow up communication. All I talked about here is the ability to setup a key exchange after validating the keys from both sides. At the same time, the long term keys aren&#x2019;t used for anything except authentication, so we get perfect forward secrecy. The idea with the middlebox key also allows us to natively support more complex routing and topologies, which is nice (but also probably YAGNI for this exercise).I would love to get your feedback and thoughts about this idea.</p>
        <a href="https://ayende.com/blog/194818-B/how-cross-signing-works-with-x509-certificates" target="_blank"><h1 class="title mb-6">How cross signing works with X509 certificates</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: September 30, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This is an interesting and a somewhat confusing topic, so I decided to write down my understanding of how certificates signature works with cross signing.A certificate is basically an envelope over a public key and some metadata (name, host, issuer, validation dates, etc). There is a format called ASN.1 that specify how the data is structured and there are multiple encoding options DER / BER. None of that really matters for this purpose. A lot of the complexity of certificates can be put down to the issues in the surrounding technology. It would probably be a lot more approachable if the format was JSON or even XML. However, ASN.1 dates to 1984. Considering that this is the age of MS-DOS 3.0 and the very first Linux was 7 years in the future, it is understandable why this wasn&#x2019;t done. I&#x2019;m talking specifically about the understandability issue here, by the way. The fact that certificates are basically opaque blocks that requires special tooling to operate and understand has made the whole thing a lot more complex than it should be. A good example of that can be seen here, this will parse the certificate using ASN.1 and let you see its contents.Here is the same data (more or less) as a JSON document:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            &quot;subject&quot;: {&#xA;        &#xA;        &#xA;          &#xA;              &quot;common_name&quot;: &quot;R3&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;country&quot;: &quot;US&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;organization&quot;: &quot;Let&#x27;s Encrypt&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;names&quot;: [&quot;US&quot;, &quot;Let&#x27;s Encrypt&quot;, &quot;R3&quot;]&#xA;        &#xA;        &#xA;          &#xA;            },&#xA;        &#xA;        &#xA;          &#xA;            &quot;issuer&quot;: {&#xA;        &#xA;        &#xA;          &#xA;              &quot;common_name&quot;: &quot;DST Root CA X3&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;organization&quot;: &quot;Digital Signature Trust Co.&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;names&quot;: [&quot;Digital Signature Trust Co.&quot;, &quot;DST Root CA X3&quot;]&#xA;        &#xA;        &#xA;          &#xA;            },&#xA;        &#xA;        &#xA;          &#xA;            &quot;serial_number&quot;: &quot;85078157426496920958827089468591623647&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;not_before&quot;: &quot;2020-10-07T19:21:40Z&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;not_after&quot;: &quot;2021-09-29T19:21:40Z&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;sigalg&quot;: &quot;SHA256WithRSA&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;authority_key_id&quot;: &quot;C4:A7:B1:A4:7B:2C:71:FA:DB:E1:4B:90:75:FF:C4:15:60:85:89:10&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;subject_key_id&quot;: &quot;14:2E:B3:17:B7:58:56:CB:AE:50:09:40:E6:1F:AF:9D:8B:14:C2:C6&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;authority_inforamtion_access&quot;: &quot;http://apps.identrust.com/roots/dstrootcax3.p7c&quot;,&#xA;        &#xA;        &#xA;          &#xA;            &quot;public_key&quot;: [&#xA;        &#xA;        &#xA;          &#xA;              &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuwIVKMz2oJTTDxLsjVWS&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;w/iC8ZmmekKIp10mqrUrucVMsa&#x2B;Oa/l1yKPXD0eUFFU1V4yeqKI5GfWCPEKpTm71&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;O8Mu243AsFzzWTjn7c9p8FoLG77AlCQlh/o3cbMT5xys4Zvv2&#x2B;Q7RVJFlqnBU840&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;yFLuta7tj95gcOKlVKu2bQ6XpUA0ayvTvGbrZjR8&#x2B;muLj1cpmfgwF126cm/7gcWt&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;0oZYPRfH5wm78Sv3htzB2nFd1EbjzK0lwYi8YGd1ZrPxGPeiXOZT/zqItkel/xMY&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;6pgJdz&#x2B;dU/nPAeX1pnAXFK9jpP&#x2B;Zs5Od3FOnBv5IhR2haa4ldbsTzFID9e1RoYvb&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;FQIDAQAB&quot;&#xA;        &#xA;        &#xA;          &#xA;            ],&#xA;        &#xA;        &#xA;          &#xA;            &quot;signature&quot;: [&#xA;        &#xA;        &#xA;          &#xA;              &quot;2UzgyfWEiDcx27sT4rP8i2tiEmxYt0l&#x2B;PAK3qB8oYevO4C5z70kHejWEHx2taPDY&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;/laBL21/WKZuNTYQHHPD5b1tXgHXbnL7KqC401dk5VvCadTQsvd8S8MXjohyc9z9&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;/G2948kLjmE6Flh9dDYrVYA9x2O&#x2B;hEPGOaEOa1eePynBgPayvUfLqjBstzLhWVQL&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;GAkXXmNs&#x2B;5ZnPBxzDJOLxhF2JIbeQAcH5H0tZrUlo5ZYyOqA7s9pO5b85o3AM/OJ&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;&#x2B;CktFBQtfvBhcJVd9wvlwPsk&#x2B;uyOy2HI7mNxKKgsBTt375teA2TwUdHkhVNcsAKX&quot;,&#xA;        &#xA;        &#xA;          &#xA;              &quot;1H7GNNLOEADksd86wuoXvg==&quot;&#xA;        &#xA;        &#xA;          &#xA;            ]&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          cert.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The only difference between the two options is that one is easy to parse, and the other&#x2026; not so much, to be honest. After we dove into the format, let&#x2019;s understand what are the important fields we have in the certificate itself. A certificate is basically just the public key, the name (or subject alternative names) and the validity period. In order to establish trust in a certificate, we need to trace it back up to a valid root certificate on our system (I&#x2019;m not touch that topic in this post). The question is now, how do we create this chain?Well, the certificate itself will tell us. The certificate contains the name of the issuer, as well as the digital signature that allows us to verify that the claimed issuer is the actual issuer. Let&#x2019;s talk about that for a bit.How does digital signatures work? We have a key pair (public / secret) that we associate with a particular name. Given a set of bytes, we can use the key pair to generate a cryptographic signature. Another party can then take the digital signature, the original bytes we signed and the public key that was used and validate that they match. The details of how this works are covered elsewhere, so I&#x2019;ll just assume that you take this on math. The most important aspect is that we don&#x2019;t need the secret part of the key to do the verification. That allows us to trust that a provided value is a match to the value that was signed by the secret key, knowing only the public portion of it.As an aside, doing digital signatures for JSON is a PITA. You need to establish what is the canonical form of the JSON document. For example: with or without whitespace? With the fields sorted, or in arbitrary order? If sorted, using what collation? What about duplicated keys? Etc&#x2026; the nice thing about ASN.1 is that at least no one argues about how it should look. In fact, no one cares.In order to validate a certificate, we need to do the following:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          def validate(cert):&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            now = datetime.now()&#xA;        &#xA;        &#xA;          &#xA;            if now &lt; cert.not_before or now &gt; cert.not_after:&#xA;        &#xA;        &#xA;          &#xA;              return False, &quot;Expired certificate&quot;&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;        &#xA;          &#xA;            for issuer_cert in lookup_cert_by_name(cert.issuer):&#xA;        &#xA;        &#xA;          &#xA;              if now &lt; issuer_cert.not_before or now &gt; issuer_cert.not_after:&#xA;        &#xA;        &#xA;          &#xA;                  continue&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;              if validate_signature(cert.data, cert.signature, issuer_cert.public_key):&#xA;        &#xA;        &#xA;          &#xA;                 if cert.issuer is None:&#xA;        &#xA;        &#xA;          &#xA;                    if is_trusted_root_ca(cert):&#xA;        &#xA;        &#xA;          &#xA;                      return True, &quot;Valid certificate&quot;&#xA;        &#xA;        &#xA;          &#xA;                    else:&#xA;        &#xA;        &#xA;          &#xA;                      return False, &quot;Uknown root CA&quot;&#xA;        &#xA;        &#xA;          &#xA;                    &#xA;        &#xA;        &#xA;          &#xA;                  return validate(issuer_cert)&#xA;        &#xA;        &#xA;          &#xA;                &#xA;        &#xA;        &#xA;          &#xA;           return False, &quot;No parent certificate&quot;&#xA;        &#xA;        &#xA;          &#xA;            &#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          valid_cert.py&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There are a few things to note in this code. We do the lookup of the issuer certificate by name. The name isn&#x2019;t anything special, mind you. And the process for actually doing the lookup by name is completely at the hands of the client, an implementation detail for the protocol. You can see that we validate the time, then check if the issuer certificate that we found can verify the digital signature for the certificate we validate. We continue to do so until we find a trusted root authority or end the chain. There are a lot of other details, but these are the important ones for our needs.A really important tidbit of information. We find the issuer certificate using a name, and we establish trust by verifying the signature of the certificate with the issuer public key. The actual certificate only carries the signature, it knows nothing about the issuer except for its name. That is where cross signing can be applied.Consider the following set of (highly simplified) certificates:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // certificate&#xA;        &#xA;        &#xA;          &#xA;          { &quot;name&quot;: &quot;www.example.com&quot;, &quot;issuer&quot;: [&quot;My Encrypt Authority Z1&quot;], &quot;sig&quot;: &quot;ABCD&quot;, &quot;public_key&quot;: 1234 }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // intermediate&#xA;        &#xA;        &#xA;          &#xA;          { &quot;name&quot;: &quot;My Encrypt Authority Z1&quot;, &quot;issuer&quot;: [&quot;My Encrypt Root Sep21&quot;], &quot;sig&quot;: &quot;DEFG&quot;, &quot;public_key&quot;: 3456 }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // root&#xA;        &#xA;        &#xA;          &#xA;          { &quot;name&quot;: &quot;My Encrypt Root Sep21&quot;, &quot;issuer&quot;: [&quot;My Encrypt Root Sep21&quot;], &quot;sig&quot;: &quot;GLMN&quot;, &quot;public_key&quot;: 5678 }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          certs.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The www.example.com certificate is signed by the Z1 certificate, which is signed by the Root Sep21 certificate, which is signed by itself. A root certificate is always signed by itself. Now, let&#x2019;s add cross signing to this mix. I&#x2019;m not going to touch any of the certificates we have so far, instead, I&#x2019;m going to have:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // intermediate - 2nd&#xA;        &#xA;        &#xA;          &#xA;          { &quot;name&quot;: &quot;My Encrypt Authority Z1&quot;, &quot;issuer&quot;: [&quot;Their Encrypt Y4&quot;], &quot;sig&quot;: &quot;HGYE&quot;, &quot;public_key&quot;: 3456 }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // root - 2nd&#xA;        &#xA;        &#xA;          &#xA;          { &quot;name&quot;: &quot;Their Encrypt Y4&quot;, &quot;issuer&quot;: [&quot;Their Encrypt Y4&quot;], &quot;sig&quot;: &quot;VBNA&quot;, &quot;public_key&quot;: 9284 }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          cross_cert.json&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is where things get interesting. You&#x2019;ll notice that the name of the intermediate certificate is the same in both cases, as well as the public key. Everything else is different (including validity periods, thumbprint, parent issuer, etc). And this works. But how does this work?Look at the validate() code, what we actually need to do to verify the certificate is to have the same name (so we can lookup the issuer certificate) and public key. We aren&#x2019;t using any of the other data of the certificate, so if we reuse the same name and public key in another certificate, we can establish another chain entirely from the same source certificate. The question that we have to answer now is simple, how do we select which chain to use? In the validate() code above, we simply select the first chain that has an element that matches. In the real world, we may actually have multiple certificates with the same public key in our system. Let&#x2019;s take a look:Take a look here 8d02536c887482bc34ff54e41d2ba659bf85b341a0a20afadb5813dcfbcf286d, these are all certificates that has the same name and public key, issued at different times and by different issuers.We don&#x2019;t generally think about the separate components that makes a certificate, but it turns out to be a very useful property.Note that cross signed here is a misnomer. Take a look at this image, which shows the status of the Let&#x2019;s Encrypt certificates as of August 2021. You can see that the R3 certificate is &#x201C;signed&#x201D; by two root certificates: DST Root CA X3 and ISRG Root X1. That isn&#x2019;t actually the case, there isn&#x2019;t a set of digital signatures on the R3 certificate, just a single one. That means that we can produce a different chain of trust from an existing certificate, without modifying it at all. For example, I can create a new R3 certificate, which is issued by Yours Truly CA, which will validate just fine, as long as you trust the Yours Truly CA. For fun, I don&#x2019;t even need to have the secret key for the R3 certificate, all the information I need to generate the R3 certificate is public, after all. I wouldn&#x2019;t be able to generate valid leaf certificates, but I can add parents at will.The question now become, how will a client figure out which chain to use? That is where things get really interesting. During TLS negotiation, when we get the server certificate, the server isn&#x2019;t going to send us just a single certificate, instead, it is going to send us (typically) at least the server certificate it will use to authenticate the connection as well as an issuer&#x2019;s certificate. The client will then (usually, but it doesn&#x2019;t have to) will use the second certificate that was sent from the server to walk up the chain. Most certificate chains are fairly limited in size. For example, using the R3 certificate that I keep referring back to, you can see that it has the ability to generate certificates that cannot properly sign child certificates (that is because its Path Length Constraint is zero, there is no more &#x201C;room&#x201D; for child certificates to also sign valid certs).What will happen usually is that the client will use the second certificate to lookup the actual root certificate in the local certificate authority store. That must be local, otherwise it wouldn&#x2019;t be trusted. So by sending both the certificate itself and its issuer from the server, we can ensure that the client will be able to do the whole certificate resolution without having to make an external call*.* Not actually true, the client may decide to ignore the server &#x201C;recommendation&#x201D;, it will likely issue an OSCP call or CRL call to validate the certificate, etc.I hope that this will help you make sense of how we are using cross signed certificates to add additional trust chains to a existing certificate.</p>
        <a href="https://ardalis.com/grouping-assertions-in-tests/" target="_blank"><h1 class="title mb-6">Grouping Assertions in Tests</h1></a>
        <p class="mb-2">by Ardalis</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: September 28, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Although it&#x27;s generally considered a best practice to assert only one thing per test, sometimes one logical &quot;thing&quot; may require multiple&#x2026;Keep Reading &#x2192;</p>
        <a href="https://ayende.com/blog/194785-B/postmortem-partial-ravendb-cloud-outage" target="_blank"><h1 class="title mb-6">Postmortem</h1></a>
        <p class="mb-2">by Oren Eini</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: September 27, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">On Friday, Sep 24, 2021, our monitoring tool started emit alerts. Our customers&#x2019; nodes were losing connectivity to one another. Not all of them, but a significant percentage.&#xA0; The issue impacted nodes in all availability zones, in all regions and across cloud providers. We are running isolated clusters, and aside from a total breakdown of the Internet, there shouldn&#x2019;t be a scenario where this happens. Looking into the details, it soon became clear that the issue wasn&#x2019;t with the infrastructure or the network. Actual connectivity between the nodes was fine, they were able to reach one another, but they weren&#x2019;t trusting one another. Following a checklist, we verified that this isn&#x2019;t an issue with a specific release or version, the issue was affecting (some) nodes across all our supported versions, including many that has been running in production for years without issue.&#xA;&#xA;TLDR; If you are using RavenDB and you run into SSL / TLS connection issues such as:&#xA;System.Security.Authentication.AuthenticationException: The remote certificate is invalid because of errors in the certificate chain&#xA;You can resolve the issue by running the following command on your instances:&#xA;rm /home/$RAVENDB_USER/.dotnet/corefx/cryptography/x509stores/ca/DAC9024F54D8F6DF94935FB1732638CA6AD77C13.pfxrm /home/$RAVENDB_USER/.dotnet/corefx/cryptography/x509stores/ca/48504E974C0DAC5B5CD476C8202274B24C8C7172.pfx&#xA;&#xA;RavenDB uses X509 certificates for authentication. One of the primary reasons that it is doing so is that reduce the dependency on external actions (like LDAP, for example). We were able to quickly figure out what the root cause was. Clients were not trusting the servers. Usually, for authentication, it is the other way around, but in this case, somehow, the client connection would detect that the remote server is using an invalid certificate.&#xA;We are using Let&#x2019;s Encrypt certificate, like the vast majority of the web, and a quick look on our own showed us nothing. Our browsers certainly thought that the certificate was valid, and locally everything worked. On the production systems (and that impacted a few dozen clusters), on the other hand, they were flat out rejected. That was not supposed to happen. The certificate were valid, and we would get a different error if they were expired. One of the good things about using X509 certificates is that it is easy to debug independently. Here is an example of what we saw:&#xA;&#xA;ayende@oren-pc:~$ curl https://a.free.ayende.ravendb.cloud&#xA;curl: (60) SSL certificate problem: unable to get local issuer certificate&#xA;More details here: https://curl.haxx.se/docs/sslcerts.html&#xA;&#xA;curl failed to verify the legitimacy of the server and therefore could not&#xA;establish a secure connection to it. To learn more about this situation and&#xA;how to fix it, please visit the web page mentioned above.&#xA;&#xA;Digging a bit deeper, we can use OpenSSL to see the real details:&#xA;&#xA;ayende@oren-pc:~$ openssl s_client -connect a.free.ayende.ravendb.cloud:443&#xA;CONNECTED(00000003)&#xA;depth=1 C = US, O = Let&#x27;s Encrypt, CN = R3&#xA;verify error:num=20:unable to get local issuer certificate&#xA;verify return:1&#xA;depth=0 CN = *.free.ayende.ravendb.cloud&#xA;verify return:1&#xA;---&#xA;Certificate chain&#xA; 0 s:CN = *.free.ayende.ravendb.cloud&#xA;   i:C = US, O = Let&#x27;s Encrypt, CN = R3&#xA; 1 s:C = US, O = Let&#x27;s Encrypt, CN = R3&#xA;   i:O = Digital Signature Trust Co., CN = DST Root CA X3&#xA;---&#xA;&#xA;So the issue is that is is now no longer trusting Let&#x2019;s Encrypt? What the hell is going on. The start of the answer is here, the root certificate for Let&#x2019;s Encrypt will expire at the end of the month. That was known well in advance, and there is a new root certificate in place that should be in pretty much all devices that you use (except very old Androids, which aren&#x2019;t relevant here).&#xA;The problem is that for some reason, which if I understand correctly has to do with old versions of OpenSSL, the ca-certificates package, which is a common way to maintain a list of trusted root certificates has removed the soon to be expiring (but not yet actually expired) from the list of trusted root certificates. That was pushed (as a security update), to many instances. It is at this point that problem started:&#xA;&#xA;Established connections are fine and worked just great, since they already authenticated and were working without issue.&#xA;New connections, on the other hand, would fail, because the trusted root was now untrusted.&#xA;&#xA;As you can imagine, this caused somewhat of an uproar for our operations team.&#xA;&#xA;The killer thing for us, I have to say, is that we tested this scenario before hand. There has been plenty of time to get ready, and our ops team have made sure that we provisioned the certificates with the new root. This should have been a non event, given that we prepared specifically for that.&#xA;&#xA;However&#x2026; what happened was that on some portion of our machines, the certificate that was used was using the old chain, the one that is no longer valid. At this point we were looking at having to redeploy certificates to hundreds of clusters and we split the team to work on things in parallel. While one part of the team prepped the emergency patch to all instances, the other half focused on how to properly generate the right certificate.&#xA;That is a bit complex, we intentionally do not keep the private keys of the clusters on our management plane, they are located solely on customer instances, so we first had to fetch them from the store, generate a new Let&#x2019;s Encrypt certificate and then distribute it back to the right location. Tricky bit of work, but we are used to working at this scale.&#xA;Except&#x2026; that didn&#x2019;t work. To be rather more exact, the certificates that we got from Let&#x2019;s Encrypt were always using the old root certificate, never the new one. There is a way to get the specific chain from Let&#x2019;s Encrypt, but our client for interacting with Let&#x2019;s Encrypt did not support it. It shouldn&#x2019;t matter, however, all recent (6 months or so, at least) certificates from Let&#x2019;s Encrypt are signed using the new chain, so how can this be?&#xA;Here is how you&#x2019;ll typically see a discussion of cross-signed certificates:&#xA;&#xA;Basically, you have a single certificate that is signed using both chains. Except, that isn&#x2019;t how it works. A certificate can be signed by a single issuer. The key here is that the issuer is not a certificate. The issuer is the public key &#x2B; name of the certificate that provided the signature. The key here is that you can get the same public key &#x2B; name to be signed by multiple parties. Which means, of course, that when you serve the certificate to a client, you typically need to tell it what certificate signed this one. I&#x2019;ll have a more detailed post on that topic, but for now, assume that when the server reply to a client, it sends either:&#xA;&#xA;Our Certificate &#x2B; Issuer (green)&#xA;Our Certificate &#x2B; Issuer (red)&#xA;&#xA;Note that the client that receive the certificate is free to absolutely ignore any other certificate that the server it sending, but most of the time, it will use that to follow the chain of certificates and find a trusted root.&#xA;In our case, we could see that we were serving the wrong certificate chain. We were serving the (valid) server certificate, and an intermediate that pointed to a removed root. That meant that the client would follow the chain we provided and then would find a missing root, leading to a trust violation and an aborted connection.&#xA;That, in a word, sucks. Because we couldn&#x2019;t figure out what was going on. Given the scope of the problem and the number of impacted customers, we needed to figure out a way to resolve that as soon as possible.&#xA;Going back to the Let&#x2019;s Encrypt certificates that we were generating, what we actually get back from Let&#x2019;s Encrypt is actually a certificate that contains:&#xA;&#xA;Server Certificate (a.free.ayende.ravendb.cloud, for example)&#xA;Intermediate certificate R3 signed by DST Root CA X3 &#x2013; that one is the problematic one&#xA;Intermediate certificate R3 signed by ISRG Root X1 &#x2013; that is the one we want&#xA;&#xA;We verified that not only are we getting the right certificate, we have been getting the right certificate for quite some time now, including on all the impacted servers.&#xA;&#xA;A note on the state of the system at that frame. We have quite a few customers running on the cloud, and the problem only impacted a small percentage at the time. Given features such as connection pooling, actually creating new connection tends to be rare. But the longer we let it go, the more chance is that a connection would break and we can&#x2019;t renew those.&#xA;What is more, that impacts both server to server communication in the cluster and clients connecting to the server. That means that this also happened to customers on their application (although it was pretty rare), the major impact that we could see is that the cluster connections broke, which meant that we effectively had a network split, even though the network itself was fine.&#xA;RavenDB is actually designed to operate in such an environment, and the nodes carried on their task. Reads and writes to the database worked as usual, but cluster wide tasks (such as deploying indexes) would fail.&#xA;&#xA;So the sky wasn&#x2019;t falling yet, but there were some dark clouds in the horizon. At this point, we have managed to figure out why the certificate isn&#x2019;t trusted anymore, because of the automatic update for the ca-certificates package. The test environment showed that reinstalling the removed certificate would restore proper behavior. After verifying that this indeed fixes the issue, we rolled out across our fleet.&#xA;Problem solved? Not so fast. We plugged the hole in the ship, but in a but a few days, we are going to be looking into the exact same issue, because the certificate will actually expire. We had to figure out what happened and why RavenDB wasn&#x2019;t serving the right certificate chain in this context.&#xA;Cue putting of spelunking equipment and digging into pretty much every code base in site. We scoured OpenSSL, .NET framework and dug through documentation about the certificate infrastructure in Windows. We couldn&#x2019;t figure out what was going on. This should work. In fact, all our tests showed us that it is working, except it didn&#x2019;t.&#xA;At this point, we believe that we figured it out, and this is pretty insane reason. Four years ago, we run into a serious problem inside of RavenDB when running in a secured environment. If the certificate chain wasn&#x2019;t available on the host, it would download that so it could serve the appropriate chain when doing TLS handshake. To avoid this issue, RavenDB will build the certificate chain once on startup, and then store that in the CA X509Store for the RavenDB user. That allowed us to remove a few remote calls on connection startup and made us more resilient when we are facing network issues.&#xA;The actual problem we were trying to solve is that occasionally, RavenDB would fail when (a completely random, as far as we are concerned) server (which is serving the missing intermediate certificate) is missing. Registering the certificate ourselves in the RavenDB&#x2019;s user store was a way to avoid this issue entirely. It also falls in line with the It Just Works model that we have. The other alternative would be to ask users to setup the full certificate chains locally (for each platform and environment). We rather handle that ourselves and not have to have another item in the checklist.&#xA;That said, this created an interesting issue. On Linux machines, there are now multiple certificate stores that are being used. There is the .NET X509 certificate store, which is stored at ~/.dotnet/corefx/cryptography/x509stores/ca/ and there is the system store, which is stored in /etc/ssl/certs (usually).&#xA;The ca-certificates update, however, caused an interesting problem. The relevant certificate was removed from the system store, but it was still on the .NET store. If it would have expired, as we expected it to, the situation would be just fine. The stores would agree and serve the new chain without issue.&#xA;However, given that it didn&#x2019;t expire yet, we had a discrepancy. .NET will obviously favor its X509 store if it can find the certificate there, so it kept serving the old chain. The solution to that it to manually clear the old certificate from the cache as well, you can do that by issuing the following commands:&#xA;&#xA;rm /home/$RAVENDB_USER/.dotnet/corefx/cryptography/x509stores/ca/DAC9024F54D8F6DF94935FB1732638CA6AD77C13.pfxrm /home/$RAVENDB_USER/.dotnet/corefx/cryptography/x509stores/ca/48504E974C0DAC5B5CD476C8202274B24C8C7172.pfx&#xA;If you are running on windows, you can run the following commands to achieve the same goal:&#xA;.\PsExec.exe -u &quot;nt authority\Local Service&quot; powershell.exe&#xA0;Get-ChildItem cert:/CurrentUser/CA/48504E974C0DAC5B5CD476C8202274B24C8C7172 | Remove-Item&#xA0;&#xA;&#xA;That would remove the relevant chain from the store and make RavenDB use the right chain. There is no need to restart the service, it should automatically fix itself.&#xA;For the future, we are going to take a long look into our policies in this matter. Given the advent of Docker &amp; Cloud services, we feel that the actual management of the entire environment should be left to the environment, not to the RavenDB process itself.</p>
        <a href="https://ardalis.com/github-actions-on-demand/" target="_blank"><h1 class="title mb-6">GitHub Actions On Demand</h1></a>
        <p class="mb-2">by Ardalis</p>
        <p class="mb-6 flex gap-1.5">
                    <span>
                                    <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                                         xmlns="http://www.w3.org/2000/svg"><path
                                            xmlns="http://www.w3.org/2000/svg"
                                            d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
            posted on: September 27, 2021
        </p>
        <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I use GitHub Actions a lot. They&#x27;re a great tool for performing continuous integration (CI) and continuous deployment (CD) for your&#x2026;Keep Reading &#x2192;</p>
        <div class="button flex justify-between">
            <a href="52.html"><span class="back arrow"></span></a>

            <a href="54.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
</body>
</html>