
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 214 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-2131">
            <a href="https://ardalis.com/measuring-aggregate-complexity-in-software-applications/" target="_blank">
                <h2 class="title mb-6" id="article-2131">Measuring Aggregate Complexity in Software Applications</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 13, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">A variety of tools will let you measure the complexity of a given method in your .NET applications. If you have a high-end SKU of Visual&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-2132">
            <a href="https://ayende.com/blog/184101-C/reading-the-nsas-codebase-lemongraph-review-part-vi-executing-queries" target="_blank">
                <h2 class="title mb-6" id="article-2132">Reading the NSA&#x2019;s codebase: LemonGraph review&#x2013;Part VI&#x2013;Executing queries</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 10, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After going over many layers inside LemonGraph, I think we are ready to get to the real deal. We know how LemonGraph starts to execute a query. It find the clause that is likely to have the least number of items and starts from there. These are the seeds of the query, but how is it going to actually process that?Here is my graph:And here is the query that I want to run on it: n()-&gt;e(type=&quot;likes&quot;, value=&quot;yes&quot;)-&gt;n()LemonGraph detects that the cheapest source of seeds for this query is the edge and provides these to the MatchCTX class which does the actual processing. Let&#x2019;s explore how it is working on a single seed. The actual behavior starts from the matches() method, which starts here:As usual for this codebase, the use of tuples for controlling behavior is prevalent and annoying. In this case, the idx argument controls the position of the target in the query, whatever this is the start, end or somewhere in the middle. The deltas define what direction the matches should go and the stops where you must stop searching, I think.Now that we setup the ground rules, the execution is as follows:In this case, because the seed of our query is the edge (which is in the middle) it determines that deltas are (1, &#x2013;1) and stops are (2, 0). We&#x2019;ll also go to the first clause in the if statement. The link variable there controls whatever we should follow links going in or out. There is a lot of logic actually packed into the link initialization. The self.link is an array that has &#x2018;next&#x2019; and &#x2018;prev&#x2019; as its values, so the idea is that it find what property to look at, then use the dictionary syntax to get the relevant property and decide what kind of direction it should go. We&#x2019;ll focus on the _recurse() method for now. In this case, we are being passed:idx = 1delta = 1stop = 2Here is the actual method:As you can see, we first validate that the match is valid (this is where we mostly check other properties of the value that we are currently checking, filtering them in place). Usually the do_seen will be set to True, which will ensure that we only traverse each node once. The main iteration logic is done in combination with the _next() method, shown below: The first line there shows usage of delta, which control in what direction to move. I&#x2019;m not quite sure why the filter is set in the if statements, since it is also being set immediately after. This looks like redundant code that snuck in somehow. The bulk of the work is shelled out to iterlinks, so let&#x2019;s check what is going on there&#x2026; I know that we are running on an edge here, so we need to look at the Edge.iterlinks() method:There isn&#x2019;t really much to tell here, it checks the filters and return the incoming or outgoing edges, nothing more. On the other hand, the Node.iterlinks() implementation is a bit simpler:We&#x2019;ll explore exactly how the edges are loaded for a node in a bit, however, I do want to note right now that the _next() method isn&#x2019;t passing the types of the edge, even though it looks to me that it has this information. In that case, that would give a performance boost because it could filter a lot of edges in busy graphs.Actually, I already looked at how iterators working in a previous post, so I won&#x2019;t go over all of that again. This is basically calling this methodThe graph_node_edges_in() and graph_node_edges_out() methods are pretty simple, basically just scanning the DB_TGTNODE_IDX or DB_SRCNODE_IDX indexes, respectively. The graph_node_edges() however, is really strange. Here it is:It took me a few reads to figure out that this is probably a case of someone unpacking a statement for debugging but forgetting to remove the packed statement. The second return statement is ignored and likely stripped out as unreachable, but it is pretty confusing to read.The graph_iter_concat() answers a question I had about how graph_iter_t is used, here is how it looks like:This is using C&#x2019;s support for passing an unknown number of parameters to a method. This basically builds a simple linked list, which also answers the usage of _blarf() function and its behavior a few posts ago.So we are back were we started, we understand how the data flows into the Python code, now let&#x2019;s go back and look at _recurse() and _next() calls.Now I know a lot more about the behavior of the code, so this make sense. The stop argument to the _recurse() control the depth of the number of links that would be traversed in a particular query. Now that I know how this particular clause work, I understand how LemonGraph goes from the edge to the node in e()-&gt;n(), but I don&#x2019;t know how it goes to back to find the full path. The key for that are the calls to push()&#xA0; and pop() in the the MatchCtx._recurse() methods. These update the chain, like so:In processing the query, we first append the edge to the chain:The next step goes from the edge to it&#x2019;s destination, giving us Oscar:Remember that in the matches(), we got into this if clause:This is when we start scanning an edge, which first add things to the right, then it scan things to the left in the _next() method. Look at the push() method there. By the time we get to the result(), we have iterated both sides of the connection, giving us:That is a very clever way of doing things. Let&#x2019;s try doing things a little bit differently. I&#x2019;m going to check a slightly different query: n(type=&#x201D;dog&#x201D;, value=&#x201D;arava&#x201D;)-&gt;e(type=&quot;likes&quot;, value=&quot;yes&quot;)-&gt;n()If I understand things correctly, this is going to select the node as the starting point, because that is a lot more efficient. That will allow me to figure out the other side of this operation. I just run this through the debugger, and this is indeed how it actually works. The usage of yield to pass control midway is not trivial to follow, but it ends up being quite a nice implementation. This is enough for this post. In my next one, I want to explore a few of the possible operations that exposed by LemonGraph.</p>
        </article>
        <article id="article-2133">
            <a href="https://ayende.com/blog/184100-C/reading-the-nsas-codebase-lemongraph-review-part-v-query-parsing" target="_blank">
                <h2 class="title mb-6" id="article-2133">Reading the NSA&#x2019;s codebase: LemonGraph review&#x2013;Part V&#x2013;Query parsing</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 09, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I said before that I don&#x2019;t want to get into the details of how LemonGraph is dealing with parsing the queries. Unfortunately, I can&#x2019;t avoid that. There seems to be a lot of logic, magic and mystery in the MatchLGQL() class, which is critical to understanding how queries work.The problem is that either my Python-fu is lacking or it is just really hard to figure out a non trivial codebase behavior in a dynamic language like python. I find it hard to figure out what data is stored where and how it is manipulated. Therefor, I decided to break with my usual custom and actually run the code in the debugger to try to follow what is going on there. I tried to run this on WSL, but it crashed horribly, so I had to spin up a VM and setup PyCharm on it. First time that I&#x2019;m actually using that and the experience is pretty nice so far. Being able to inspect things directly means that it is much easier to figure out the behavior of the code. In order to explore how queries work in LemonGraph, I created the following graph, which represents the relationships between my dogs:Here is how this looks like in code:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          with g.transaction(write=True) as txn:&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              arava = txn.node(type=&#x27;dog&#x27;, value=&#x27;arava&#x27;)&#xA;        &#xA;        &#xA;          &#xA;              oscar = txn.node(type=&#x27;dog&#x27;, value=&#x27;oscar&#x27;)&#xA;        &#xA;        &#xA;          &#xA;              pheobe = txn.node(type=&#x27;dog&#x27;, value=&#x27;pheobe&#x27;)&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              txn.edge(src=arava, tgt=oscar, type=&#x27;likes&#x27;, value=&#x27;yes&#x27;)&#xA;        &#xA;        &#xA;          &#xA;              txn.edge(src=arava, tgt=pheobe, type=&#x27;likes&#x27;, value=&#x27;no&#x27;)&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              txn.edge(src=oscar, tgt=arava, type=&#x27;likes&#x27;, value=&#x27;yes&#x27;)&#xA;        &#xA;        &#xA;          &#xA;              txn.edge(src=oscar, tgt=pheobe, type=&#x27;likes&#x27;, value=&#x27;yes&#x27;)&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              txn.edge(src=pheobe, tgt=oscar, type=&#x27;likes&#x27;, value=&#x27;no&#x27;)&#xA;        &#xA;        &#xA;          &#xA;              txn.edge(src=pheobe, tgt=arava, type=&#x27;likes&#x27;, value=&#x27;no&#x27;)&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          with g.transaction(write=False) as txn:&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for chain in txn.query(&#x27;n()-&gt;e(type=&quot;likes&quot;, value=&quot;yes&quot;)-&gt;n()&#x27;):&#xA;        &#xA;        &#xA;          &#xA;                  print(chain)&#xA;        &#xA;        &#xA;          &#xA;              print()&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          graph.py&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This tells us to find all the dogs that like each other. And it finds:Arava &#x2013;&gt; OscarOscar &#x2013;&gt; AravaOscar &#x2013;&gt; PheobeNow that we have a query that we can sink our teeth into, let&#x2019;s figure out how this work, shall we? Inside the dreaded MatchLGQL() class, there are all sorts of regular expressions running on the parse this thing, but eventually we get to the partially processed parsed query:This screen shot might explain why I wasn&#x2019;t happy with the code structure for figuring out what is going on without debugging. The number of tuples here is quite amazing, and they are used everywhere. This make static analysis (as in, just reading the code) too hard for me. But with the debugger, that is much easier. If you are familiar with ASTs, this should be pretty easy to figure out.Here is a piece of code that we already looked at (and criticized), this is in munge_obj() method, where it is deciding how to optimize the query:This piece of code is critical for the performance of the system. And it is really hard to understand. Here is what is going on.The accel array tell a later piece of code how to accelerate the query, using the type or type and value to start from a particular source. The info is used to carry state about particular clause in the query. Before this code run there is some code that builds the dictionary d which is used to figure out the filters on the particular clause. This is fun, because it is using missing a key lookup in the dictionary for control flow.Let&#x2019;s follow the logic?Line 2 - If the clause operates on a node, rank it as 6. If it is an edge, rank it as 7.Line 6 &#x2013; If the clause has a type specified, rank is as 4 if it is a node, 5 if it is an edge. Otherwise, abort the optimization.You might not see the &#x201C;abort this optimization&#x201D; in line 6, because it relies on the dictionary to throw if the key isn&#x2019;t found. This is a common pattern in this code and something that I personally greatly dislike.Line 8 &#x2013; it uses the length of the type as a metric for secondary ranking. I&#x2019;m not quite sure why this is the case. I guess the code needed a tie breaker, but I can&#x2019;t imagine why the length of a type would have any impact on performance.Unless, of course, the code assumes that shorter types are more common, and therefor will prefer to use the rare longer types?Line 10 &#x2013; If there is a type and a value defined, that is even better. Note that again the is the ranking of node (2) and edge (3) which I find non obvious.Here are the results of the matches after they have been munged, I marked the ranking:Looking at this, this seems very strange, the rank2 value is 1 in the second element, but I expected it to be the length of the string. As it turns out, this is not working directly on the string, it is working on the tuple of possible values, so the secondary ranking here is not based on the length of the type or the value but on the number of possible types and values that were specified for each clause.The code judges that the best place to start this query is with the second entry, since it is the most specific option. This in turn takes us the the seeds() method that we previously covered. In this case, the code is going to hit this branch:This means that it is going to be iterating over all the edges of a particular type and filtering them in Python code. This is strange, because the on disk indexes actually support doing a direct query on the (type, value) directly and would probably be much cheaper in the case you have many values for a particular type of an edge. In fact, just that is implemented for querying nodes by (type, value):I&#x2019;m guessing that they are either don&#x2019;t have a lot of queries on (type, value) on edges or not a lot of different values for edge types that they can optimize in this manner.That is enough for now, I have a pretty good grasp of how queries are parsed and how they fetch data from the underlying storage. The next post will talk about how LemonGraph takes the seeds of the query and execute the actual graph operations on them. The code that does this is tight and will require a full post to explore properly.</p>
        </article>
        <article id="article-2134">
            <a href="https://ayende.com/blog/184099-C/reading-the-nsas-codebase-lemongraph-review-part-iv-compressed-sortable-integers" target="_blank">
                <h2 class="title mb-6" id="article-2134">Reading the NSA&#x2019;s codebase: LemonGraph review&#x2013;Part IV&#x2013;Compressed, sortable integers</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 08, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Before going over the actual query implementation, I wanted to talk about something that I just realized. I said previously that I don&#x2019;t understand why LemonGraph is using its integer encoding method, because it is less efficient than using variant sized integer. What I didn&#x2019;t take into account is that the method LemonGraph is using gives short, but sortable, integers.Here is the encoding method:Now, let&#x2019;s see what kind of binary output this will generate when given a few numbers:The key here is that the number of bytes is stored as the first item. This means that when we compare two numbers using memcmp(), the number with more bytes is considered greater. This is indeed the case, because if you need more bytes to store a number, it is obviously larger.What about two numbers that have the same number of bytes? This is handled by simple binary comparison of the values. If they are the same size, the fact that the encode() output them in big endian format means that we can compare them using memcmp() and be done with it.This is a really nice way to both keep the values sorted and to avoid storing the full 8 bytes for numbers that are usually much smaller.</p>
        </article>
        <article id="article-2135">
            <a href="https://ayende.com/blog/184098-C/reading-the-nsas-codebase-lemongraph-review-part-iii-figuring-out-queries" target="_blank">
                <h2 class="title mb-6" id="article-2135">Reading the NSA&#x2019;s codebase: LemonGraph review&#x2013;Part III - Figuring out queries</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 07, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After figuring out how LemonGraph is storing data on disk, my next task is to figure out how queries are handled. Here are some queries:&#xA;&#xA;A query starts in the Python&#x2019;s Query class, where it is parsed by the MatchLGQL class. I scanned this code briefly, but this is basically doing query parsing into the in memory representation. This is typically ugly piece of code, and that holds true for this code as well. Python&#x2019;s dynamic nature also means that there isn&#x2019;t an easy to follow set of AST classes. I&#x2019;ll skip the details of query parsing and just see how it is actually handling the queries, then.&#xA;I started to look into the query execution and got lost in details that I didn&#x2019;t understand. In particular, there is a very strong tie between the query parsing and the execution. More so than I expected. What brought this home was this piece of code, which is used to rank the most efficient manner in which you should start executing the query.&#xA;&#xA;At this point, I think that the idea here is that when you start running a query, you want to start from the smallest set of seed nodes. the ranking here seems to be a nice way to go about doing just that, but I&#x2019;m not really sure yet how this is applied.&#xA;This is later used to figure out what the best starting location is in the Query.finalize() method.&#xA;&#xA;This all come together for me inside the _adhoc() method on Query, where the query is actually being run:&#xA;&#xA;The self.compiled is the set of already parsed matches. On each of them, we create a context (which will track already visited nodes / edges) and start by finding the seeds on the query. Seeds are handled using&#x2026; an interesting approach:&#xA;&#xA;It took me a few reads to get what this code is trying to do and I still thing that this is an obnoxious way to write things. This basically does the other side of the ranking. It is using the ranking to decide which method to call. I think that an enum would be about three time more readable. Especially since a bit lower you have:&#xA;&#xA;I have to say that the modulus usage is the sign of true genius. Or madness. I&#x2019;m not sure which, because I can&#x2019;t figure out what the history of this code is. This was the same way from the initial commit, but I think that this code has history from before the public release. And it might have a reason for this kind of code. But I don&#x2019;t like it and I think it would have been much easier to read if it wasn&#x2019;t using magic numbers all over the place.&#xA;At any rate, let&#x2019;s assume that we have the simplest query, for all the nodes. This would send us to txn.nodes() method. This would be rank 6, by the way. Here is how this looks like:&#xA;&#xA;As you can see, we have two modes here. If the rank was 6, we aren&#x2019;t sent a type. But if the rank was 4, we are getting a type. I&#x2019;m going to start from the search for types, which seems more interesting.&#xA;Here is where we end up in the C code:&#xA;&#xA;Yes, the graph_nodes_type() method is calling _graph_nodes_edges_type() method. That was confusing as well to me. The key here is the DB_NODE_IDX index there, which tell it to use a different tree for the lookups.&#xA;The graph_string_lookup() is something that we already run into, this is the __blob_resolve() method, which is searching for the string id for the given type. The code starts to get interesting when we see the graph_iter_new() call:&#xA;&#xA;So we specify an iterator on the given prefix. From the previous post, you might recall that DB_NODE_IDX is specific as (type, val &#x2013;&gt; id). So this does a search on the first item that matches the prefix.&#xA0; The _cleanse_beforeID() method will ensure that the beforeID is only valid if it represent a value that is between 1 and the max log id that was generated on the graph.&#xA;The iterator we got from the nodes() method just implement&#x2019;s Python iteration interface, starting from the graph_iter_new() item, then calling graph_iter_next() until the end. This is implemented like so:&#xA;&#xA;Here we see for the first time the actual usage of beforeID. I&#x2019;m not sure what this does yet, so we&#x2019;ll skip this for now and look at the _iter_idx_nextID() method and come back to it later. This method is quite interesting. We have the head of the iterator, which is set to true in the iterator init. I&#x2019;m not sure what this means yet. What seems to be interesting is that _blarf() method, which I understand to be a cry of frustration (I had to look it up).&#xA;&#xA;I&#x2019;m not sure what the next pointer is doing there at all. We&#x2019;ll look at that after I&#x2019;ll inspect (with some measure of dread) the _blarf() function.&#xA;&#xA;To start with, I love the use of goto instead of return statements. I understand that this may be a coding convention here and this is used to clearly mark when resources are supposed to be disposed, but still&#x2026;&#xA;The iter_next_key() ends up moving the cursor (and validating that the prefix is still valid). The _parse_idx_logID() call is here:&#xA;&#xA;And this is just a fancy way of saying, gimme the last value in this buffer.&#xA;To understand what is going on, let&#x2019;s go back a bit and understand what is going on here. We are actually scanning the index DB_NODE_IDX. And that index has the value of (type, val, id). Since the iteration is done in sorted order, this means that you can iterate over all the matches that match the type you want. The use of beforeID for filtering here, however, is interesting. I wonder how common is the use of historical queries like this are. Because if you need to skip over a lot of items, this will result in an O(N) operation while you are scanning and discarding a lot of data.&#xA;Anyway, there doesn&#x2019;t seem to be any use of the graph_iter_t.next in this code path, so I&#x2019;ll leave it for now. The iteration over all the nodes is done with the exact same method, but without specifying any prefix, which means that it matches everything.&#xA;I have to admit that at this point, I don&#x2019;t really get how it process the more complex queries. I had to give up the &#x201C;let&#x2019;s not run the code&#x201D; and try a few things out. Surprisingly, on WSL, the code just cause segmentation fault. I tracked it down to something in cffi, but I didn&#x2019;t care that much. I created a simple ubuntu machine and played with it for a bit. So far, we just looked at how we get the first seeds of the query. A lot of the smarts seems to be hidden in the MatchCTX class.&#xA0; In particular, the matches() method seems to be doing a lot of magic.&#xA;I&#x2019;m going to concentrate on that in my next post.</p>
        </article>
        <article id="article-2136">
            <a href="https://andrewlock.net/adding-serilog-to-the-asp-net-core-generic-host/" target="_blank">
                <h2 class="title mb-6" id="article-2136">Adding Serilog to the ASP.NET Core Generic Host</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 07, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I introduce the Serilog.Extensions.Hosting package, discuss why it&#x27;s necessary, and describe how to use it to add Serilog to a generic host app&#x2026;</p>
        </article>
        <article id="article-2137">
            <a href="https://ayende.com/blog/184097-C/reading-the-nsas-codebase-lemongraph-review-part-ii-storing-edges-and-properties" target="_blank">
                <h2 class="title mb-6" id="article-2137">Reading the NSA&#x2019;s codebase: LemonGraph review&#x2013;Part II - Storing edges and properties</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 06, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The last post left us figuring out how LemonGraph is storing nodes and edges. There are the special properties type and val that are used for this kind of lookup. I find it interesting that these two properties are treated in a special manner. It seems like it would be more useful to have such distinction completely arbitrary or use a single property. A more common approach would be to just have a unique key for each node / edge and be done with it. I&#x2019;m guessing that this is needed because you might want to do partial searches. So give me all the nodes whose type is X without caring what the value is.&#xA;Here is the sample code from the project&#x2019;s page:&#xA;&#xA;In the last post, I was able to follow up on the first two lines. Now, let&#x2019;s see how the edge is actually used and how properties are stored. The edge() method call ends up calling the __edge_resolve() method:&#xA;&#xA;This is very similar to what we saw with __node_resolve() method. This might be a good time to stop and consider the edge_t and node_t structures:&#xA;&#xA;They seems pretty simple. The is_new:1 syntax is used by C for bitfields. In other words, the is_new field takes a single bit, while the rectype takes 7 bits.&#xA;A node has an id, the record type, the next pointer (which I assume is used for historical queries) and the type/val fields. The edge is pretty much the same shape, except that it has the source and target fields as well.&#xA;I&#x2019;m going to skip detailed dive into the internals of __edge_resolve(), they are nearly identical as the __node_resolve() one. I do want to note that LemonGraph define the following indexes on edges:&#xA;&#xA;type, val, src, tgt &#x2013;&gt; id&#xA;src, type &#x2013;&gt; id&#xA;tgt, type &#x2013;&gt; id&#xA;&#xA;In other words, it can very quickly find matches for queries on:&#xA;&#xA;Edges by type and values&#xA;Edges from a source of a particular type&#xA;Edges to a target of a particular type&#xA;&#xA;Setting a property ends up calling _prop_resolve() which looks like this:&#xA;&#xA;Again, very similar to what we have seen before. This is a good thing. Predictability in a code base is a very nice property (pun intended).&#xA;Properties are indexes on:&#xA;&#xA;parent, key &#x2013;&gt; id&#xA;&#xA;In other words, you can lookup the properties of a node (or an edge) based on its parent or type. Interestingly enough, it isn&#x2019;t indexing the value of a property. I would expect to have an index on (key, value &#x2013;&gt; id), which would allow for richer queries. On the other hand, I guess they do most / all of their queries on the type/val pair as the source.&#xA;With this, I feel like I have a good grasp on what is going on in LemonGraph in terms of the on disk data structure. In the next post, I&#x2019;m going to try to figure out how it is handling queries.</p>
        </article>
        <article id="article-2138">
            <a href="https://ayende.com/blog/184066-C/reading-the-nsas-codebase-lemongraph-review-part-i-storing-nodes" target="_blank">
                <h2 class="title mb-6" id="article-2138">Reading the NSA&#x2019;s codebase: LemonGraph review&#x2013;Part I - Storing Nodes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 03, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">A few months ago the NSA released LemonGraph, a graph database based on LMDB. This weekend I took the time to explore the codebase. As usual, I&#x2019;m going to be reading the code in lexical order, and mostly trying to figure out where things are happening and what the code is doing.&#xA;I started to read the Python code, but it immediately called to native C code:&#xA;&#xA;Looking at the lemongraph.h file, I see a lot of quite interesting methods. This looks like the heart of LemonGraph is implemented in C, while the higher level Python code is orchestrating things. Not sure if this is a fair statement, but I&#x2019;m going to be reading some C code now.&#xA;&#xA;The first interesting thing in the C code is that LemonGraph actually wrapped LMDB with their own interface. From db.c, we have:&#xA;&#xA;The MDB_xyz flags are defined by LMDB, DB_xyz are defined by LemonGraph. I assume that this was done to hedge their bets with regards to the underlying storage engine. From my own experience, any such attempt is usually doomed to failure. It isn&#x2019;t the compilation errors that will kill you but the different behavior that you are coupled to that matters. A lot of the code there is basically forwarding directly to LMDB, but there is actual behavior implemented in db.c. In particular, they seem to have a lot of logic around managing remapping of LMDB (which is fixed size and requires reopening to change).&#xA;The lemongraph.c file is about 1,750 lines in size. I skimmed it a bit, but let&#x2019;s get to the interesting bits. I tried to check where it is creating a new node and follow the code from there, but I got lost. So I started with the docs and looked at this code:&#xA;&#xA;As a reminder, I&#x2019;m reading this code in a text editor, not running it, so I&#x2019;m somewhat limited by what I can discover. This Python code is strange, because it is doing creation by omission. In other words, if you already had a a node with &#x201C;foo:bar&#x201D; there, it would return it. Otherwise, a new node is created. Not my cup of tea, but make sense for a Python interface.&#xA;Let&#x2019;s dig deeper into how this is built, shall we? This call ends up here:&#xA;&#xA;This then calls to:&#xA;&#xA;I want to stop everything for a moment and look at the first line of this code. It calls malloc, and it does this in a pretty strange manner. Note that it looks likes it dereferences the variable before it has been initialized. This isn&#x2019;t what is actually going on.&#xA;The sizeof operator is a compile time feature. And this relies on this code:&#xA;&#xA;In C, structs are referred to as &#x201C;struct STRUCT_NAME&#x201D; and are typically typedef to themselves to make things easier. In this codebase, there is &#x201C;struct node_t&#x201D; and &#x201C;node_t&#x201D;, which is a pointer to the struct. I find this very confusing, to be honest.&#xA;At any rate, back to _node_resolve method. You can see something pretty interesting here. we have the _string_resolve method. What is it doing there? This just forward the call to __resolve_blob, which is really interesting.&#xA;It is a bit long, and you can read it at your leisure here. The signature is here:&#xA;&#xA;Basically, it uses a feature of LMDB that allow to store multiple values for a key. I started describing what this is doing, but then I realized that this is crazy. Sample code would be much easier. Here is the essence of this method:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          Dictionary&lt;uint, List&lt;long&gt;&gt; _crcToIds;&#xA;        &#xA;        &#xA;          &#xA;          Dictionary&lt;long, string&gt; _idsToStrs;&#xA;        &#xA;        &#xA;          &#xA;          long _lastId;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          long __resolve_blob(string str){&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uint crc = ComputeCrc(str);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if(_crcToIds.TryGetValue(crc, out var list))&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;foreach(var id in list)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;var existingStr = _idsToStrs[id];&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if(existingStr == str)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;return id;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;else&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;_crcToIds[crc] = list = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var id = &#x2B;&#x2B;_lastId;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;list.Add(id);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;_idsToStrs.Add(id, str);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return id;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          __resolve_blob.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, the idea is that LemonGraph maintains an internal string index, allowing it to turn any existing string into a numeric id. Going back to the _node_resolve() method, you can see that the _string_resolve method is used to get a unique id for both the type and val parameters. This is then sent to the __node_resolve() method.&#xA;As an aside, I&#x2019;m loving the fact that you can figure out the call graph for methods based on the number of underscores prefixed to the name. No underscore, public method. Single underscore, private method used internally. Two underscores, hidden method, used sparingly. At three underscores, I could tell you what it means, but given that this is NSA&#x2019;s codebase, I&#x2019;ll have to kill you afterward.&#xA;&#xA;This is a nice method. We first do a lookup, and if it isn&#x2019;t there, we&#x2019;ll append a new node. I&#x2019;m going to look at the _node_append() method first, because it will likely make looking at the _node_lookup() method easier.&#xA;&#xA;The encode() method uses length prefixed ints to encode int64 values in fewer bytes. I&#x2019;m not sure why they chose this format over variant size int. That would save at least one byte in almost all cases. The end result of this method is that we pass the dbuf buffer to the _log_append() method with the (next, type, val) values encoded in it. I&#x2019;m not sure what next is at this point, but I know that in the case we have here, this is meant to be 0, so we can probably ignore it for now. The _log_append() method simply append the buffer to a tree and returns a sequential id, nothing more. Going back up a bit, the _node_index() is now called, which looks like this:&#xA;&#xA;This is basically is just adding the value to the log and creating an index to search by (type,val) &#x2013; giving the id. This just make me that much more interested in the next. I&#x2019;m pretty sure that this is required for a feature they call historical views, which likely means that they never actually do deletes, just markers. This is a nice feature if you want to effectively go back in time, or maybe compare current and past events.&#xA;On the one hand, this limits the usability of the graph, because your data set will only grow. On the other hand, not having to worry about deletes is so much easier.&#xA;Now we can go and figure out what is going on with the _node_lookup() method.&#xA;&#xA;You can see that this is using the same DB_NODE_IDX from the _node_index() method. So basically this is doing the reverse of the past few methods. This will lookup the index, then fetch the relevant log id for this.&#xA;This is enough for now, I have a good grasp of the basic underlying data structures. I&#x2019;m pretty sure that now that I know how nodes works, I can quickly check how edges and properties work as well. Hopefully, next post will be able to talk about the graph operations directly, but I might run into other interesting bits first.</p>
        </article>
        <article id="article-2139">
            <a href="https://ayende.com/blog/184065-C/playing-with-graphs-and-logic-systems" target="_blank">
                <h2 class="title mb-6" id="article-2139">Playing with graphs and logic systems</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 02, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Recently I have been playing with graphs a bit, trying to understand them in more depth. Because I learn much better by doing, I thought that I would build a toy graph query engine to see how that works. I loaded the MovieLens small data set into a set of C# classes and started playing with them.Here is what the source data looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public class Movie&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public int MovieId;&#xA;        &#xA;        &#xA;          &#xA;              public string Title;&#xA;        &#xA;        &#xA;          &#xA;              public string[] Genres;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public class UserRating&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public int MovieId;&#xA;        &#xA;        &#xA;          &#xA;              public float Rating;&#xA;        &#xA;        &#xA;          &#xA;              public DateTime Timestamp;&#xA;        &#xA;        &#xA;          &#xA;              public List&lt;string&gt; Tags = new List&lt;string&gt;();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public class User&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public int UserId;&#xA;        &#xA;        &#xA;          &#xA;              public Dictionary&lt;int, UserRating&gt; Ratings = new Dictionary&lt;int, UserRating&gt;();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var users = new Dictionary&lt;int, User&gt;();&#xA;        &#xA;        &#xA;          &#xA;          var movies = new Dictionary&lt;int, Movie&gt;();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          setup.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I&#x2019;m not dealing with typical issues, such as how to fetch the data, optimizing indexes, etc. Instead, I want to focus solely on the problem of finding patterns in the graph.Here is a simple example of a pattern in the graph:(userA:User)-[:Rated]-&gt;(movie:Movie)&lt;-[:Rated]-(userB:User)The syntax is called Cypher, which is commonly used for graph queries. What we are trying to find here is a set of triads. User A who rated a movie that was also rated by user B. The result of this query is a list of tuples matching (userA, movie, userB).This is really similar to the way I remember learning Prolog, so I thought about giving it a shot and solving the problem in this way.The first thing to do is to break the query itself into independent steps:(userA:User)-[:Rated]-&gt;(movie:Movie) AND (userB:User)-[:Rated]-&gt;(movie:Movie)Note that in this case, the first and second queries are exactly the same, but now they are somewhat easier to reason about. We just need to do the match ups property, here is how I would write the code:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;           var user_and_movie = (&#xA;        &#xA;        &#xA;          &#xA;             from user in users.Values&#xA;        &#xA;        &#xA;          &#xA;             from rating in user.Ratings.Values&#xA;        &#xA;        &#xA;          &#xA;             select new&#xA;        &#xA;        &#xA;          &#xA;             {&#xA;        &#xA;        &#xA;          &#xA;                 user,&#xA;        &#xA;        &#xA;          &#xA;                 movie = movies[rating.MovieId]&#xA;        &#xA;        &#xA;          &#xA;             }&#xA;        &#xA;        &#xA;          &#xA;           ).ToList();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;           var one = user_and_movie;&#xA;        &#xA;        &#xA;          &#xA;           var two = user_and_movie;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;           var results = (&#xA;        &#xA;        &#xA;          &#xA;              from userA in one&#xA;        &#xA;        &#xA;          &#xA;              join userB in two&#xA;        &#xA;        &#xA;          &#xA;                on userA.movie equals userB.movie&#xA;        &#xA;        &#xA;          &#xA;              where userA.user != userB.user&#xA;        &#xA;        &#xA;          &#xA;              select new&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  userA = userA.user.UserId,&#xA;        &#xA;        &#xA;          &#xA;                  userB = userB.user.UserId,&#xA;        &#xA;        &#xA;          &#xA;                  movie = userA.movie.MovieId&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;           ).ToList();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          simple.query.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This query can take a while to run, because on the small data set (with just 100,004 recommendations and 671 users) there are over 6.2 million such connections. And yes, I used join intentionally, because it show case the interesting problem of cartesian product.Now, these queries aren&#x2019;t really interesting and they can be quite expensive. A better query would be to find the set of movies that were rated by both user 1 and user 306. This can be done as simple as changing the previous code starting location:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var one = (&#xA;        &#xA;        &#xA;          &#xA;              from user in new[] { users[1] }&#xA;        &#xA;        &#xA;          &#xA;              from rating in user.Ratings.Values&#xA;        &#xA;        &#xA;          &#xA;              select new&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  user,&#xA;        &#xA;        &#xA;          &#xA;                  movie = movies[rating.MovieId]&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          ).ToList();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var two = (&#xA;        &#xA;        &#xA;          &#xA;              from user in new[] { users[306] }&#xA;        &#xA;        &#xA;          &#xA;              from rating in user.Ratings.Values&#xA;        &#xA;        &#xA;          &#xA;              select new&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  user,&#xA;        &#xA;        &#xA;          &#xA;                  movie = movies[rating.MovieId]&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          ).ToList();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          specific.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Again, this is a pretty simple scenario. A more complex one would be to find a list of movies a particular user has not rated that were rated by people who liked the same movies as this user. As a query, this will look roughly like this:(userA:User)-[:Rated(Rating &gt;= 4)]-&gt;(:Movie)&lt;-[:Rated(Rating &gt;= 4)]-(userB:User) AND (userB:User)-[:Rated(Rating &gt;= 4)]-&gt;(notRatedByA:Movie) AND NOT (userA:User)-[:Rated]-&gt;(notRatedByA:Movie)Note that this merely specify the first part, find me users that liked the same movies as userA.&#xA0; The second part is a bit more complex, we want to find movies rated by the second users and exclude movies rated by the first. Let&#x2019;s break it into its component parts, shall we?Here is the code for the first clause:&#xA0; (userA:User)-[:Rated(Rating &gt;= 4)]-&gt;(:Movie)&lt;-[:Rated(Rating &gt;= 4)]-(userB:User) &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var one = (&#xA;        &#xA;        &#xA;          &#xA;              from user in new[] { users[1] }&#xA;        &#xA;        &#xA;          &#xA;              from rating in user.Ratings.Values&#xA;        &#xA;        &#xA;          &#xA;              where rating.Rating &gt;= 4&#xA;        &#xA;        &#xA;          &#xA;              select new&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  user,&#xA;        &#xA;        &#xA;          &#xA;                  movie = movies[rating.MovieId]&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          ).ToList();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var two = (&#xA;        &#xA;        &#xA;          &#xA;              from user in users.Values   &#xA;        &#xA;        &#xA;          &#xA;              from rating in user.Ratings.Values&#xA;        &#xA;        &#xA;          &#xA;              where rating.Rating &gt;= 4&#xA;        &#xA;        &#xA;          &#xA;              select new&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  user,&#xA;        &#xA;        &#xA;          &#xA;                  movie = movies[rating.MovieId]&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          ).ToList();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var clauseA = (&#xA;        &#xA;        &#xA;          &#xA;                          from userA in one&#xA;        &#xA;        &#xA;          &#xA;                          join userB in two&#xA;        &#xA;        &#xA;          &#xA;                          on userA.movie equals userB.movie&#xA;        &#xA;        &#xA;          &#xA;                          where userA.user != userB.user&#xA;        &#xA;        &#xA;          &#xA;                          select new&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              userA = userA.user,&#xA;        &#xA;        &#xA;          &#xA;                              userB = userB.user&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                      ).ToList();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          first.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;As you can see, the output of this code is a set of ( userA, userB ). Now, let&#x2019;s go to the second one, shall we? We already have a match on userB in this case, so we can start evaluating that. Here is the next stage: (userB:User)-[:Rated(Rating &gt;= 4)]-&gt;(notRatedByA:Movie)&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var clauseB = from matches in clauseA&#xA;        &#xA;        &#xA;          &#xA;                        from rating in matches.userB.Ratings.Values&#xA;        &#xA;        &#xA;          &#xA;                        where rating.Rating &gt;= 4&#xA;        &#xA;        &#xA;          &#xA;                        select new&#xA;        &#xA;        &#xA;          &#xA;                        {&#xA;        &#xA;        &#xA;          &#xA;                            matches.userA,&#xA;        &#xA;        &#xA;          &#xA;                            matches.userB,&#xA;        &#xA;        &#xA;          &#xA;                            notRatedByA = movies[rating.MovieId]&#xA;        &#xA;        &#xA;          &#xA;                        };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          clauseB.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Now we have the last stage, where we need to filter things out: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var clauseC = from matches in clauseB&#xA;        &#xA;        &#xA;          &#xA;                        where matches.userA.Ratings.ContainsKey(matches.notRatedByA.MovieId)&#xA;        &#xA;        &#xA;          &#xA;                        select matches;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          clauseC.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;And now we have the final results.For me, thinking about these kind of queries as a &#x201C;fill in the blanks&#x201D; makes the most sense.</p>
        </article>
        <article id="article-2140">
            <a href="https://ayende.com/blog/184033-C/when-the-code-flat-out-lies-to-you" target="_blank">
                <h2 class="title mb-6" id="article-2140">When the code flat out lies to you</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 01, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Take a look at the following snippet. This is a table definition using Esent.At a glance, this looks fine. It defines a table with a primary key that is auto incrementing whose type is long. Everything seems fine and dandy.Unfortunately, there is a horrible bug in this code. The Long type here refers to Win32 long type in C which is&#x2026; 32 bits. When I wrote this code, I assumed that this is C#&#x2019;s long type, which is 64 bits in size.The difference matters, because after just over 2 billion inserts to this table, everything is going to break in a horrible horrible horrible manner. At which point the only fix is to run a schema upgrade on the internal data structure, which is&#x2026; an interesting experience when you have literally billions of records there.</p>
        </article>
        <div class="button flex justify-between">
            <a href="213.html"><span class="back arrow"></span></a>

            <a href="215.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>