
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 35 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-341">
            <a href="https://ayende.com/blog/200101-C/filtering-negative-numbers-fast-unroll" target="_blank">
                <h2 class="title mb-6" id="article-341">Filtering negative numbers, fast</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 12, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, we looked into what it would take to reduce the cost of filtering negative numbers. We got into the assembly and analyzed exactly what was going on. In terms of this directly, I don&#x2019;t think that even hand-optimized assembly would take us further. Let&#x2019;s see if there are other options that are available for us to get better speed.&#xA;The first thing that pops to mind here is to do a loop unrolling. After all, we have a very tight loop, if we can do more work per loop iteration, we might get better performance, no? Here is my first version:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_Unroll(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (items.Length &lt;= 0)&#xA;        &#xA;        &#xA;          &#xA;                  return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (; i &#x2B; 4 &lt; items.Length; i &#x2B;= 4)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var i0 = items[i &#x2B; 0];&#xA;        &#xA;        &#xA;          &#xA;                  var i1 = items[i &#x2B; 1];&#xA;        &#xA;        &#xA;          &#xA;                  var i2 = items[i &#x2B; 2];&#xA;        &#xA;        &#xA;          &#xA;                  var i3 = items[i &#x2B; 3];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i0);&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i1);&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i2);&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, i3);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  AddToOutput(ref output, items[i]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [MethodImpl(MethodImplOptions.AggressiveInlining)]&#xA;        &#xA;        &#xA;          &#xA;              void AddToOutput(ref long output, long input)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (input &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      return;&#xA;        &#xA;        &#xA;          &#xA;                  Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;) = input;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_Unroll.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And here are the benchmark results:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;274.6 ns&#xA;0.40 ns&#xA;0.35 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;257.5 ns&#xA;0.94 ns&#xA;0.83 ns&#xA;0.94&#xA;606 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;748.1 ns&#xA;2.91 ns&#xA;2.58 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;702.5 ns&#xA;5.23 ns&#xA;4.89 ns&#xA;0.94&#xA;606 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;501,545.2 ns&#xA;4,985.42 ns&#xA;4,419.45 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;446,311.1 ns&#xA;3,131.42 ns&#xA;2,929.14 ns&#xA;0.89&#xA;606 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;29,637,052.2 ns&#xA;184,796.17 ns&#xA;163,817.00 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;29,275,060.6 ns&#xA;145,756.53 ns&#xA;121,713.31 ns&#xA;0.99&#xA;606 B&#xA;&#xA;&#xA;&#xA;That is quite a jump, 6% &#x2013; 11% savings is no joke. Let&#x2019;s look at what is actually going on at the assembly level and see if we can optimize this further.&#xA;As expected, the code size is bigger, 264 bytes versus the 55 we previously got. But more importantly, we got the range check back, and a lot of them:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;                 lea       r11d,[r8&#x2B;1]        ; var i01_idx = i&#x2B;1&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r11d,ecx           ; if i01_idx &gt;=&#xA;        &#xA;        &#xA;          &#xA;                 jae       near ptr M02_L10   ; jump to range check&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_Unroll.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The JIT isn&#x2019;t able to reason about our first for loop and see that all our accesses are within bounds, which leads to doing a lot of range checks, and likely slows us down. Even with that, we are still showing significant improvements here.&#xA;Let&#x2019;s see what we can do with this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (; i &#x2B; 4 &lt; items.Length; i &#x2B;= 4)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 0));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 1));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 2));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 3));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ElidedRangeChecks.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;With that, we expect to have no range checks and still be able to benefit from the unrolling.&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;275.4 ns&#xA;2.31 ns&#xA;2.05 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;253.6 ns&#xA;2.59 ns&#xA;2.42 ns&#xA;0.92&#xA;0.01&#xA;563 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;741.6 ns&#xA;5.95 ns&#xA;5.28 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;665.5 ns&#xA;2.38 ns&#xA;2.22 ns&#xA;0.90&#xA;0.01&#xA;563 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;497,624.9 ns&#xA;3,904.39 ns&#xA;3,652.17 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;444,489.0 ns&#xA;2,524.45 ns&#xA;2,361.38 ns&#xA;0.89&#xA;0.01&#xA;563 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;29,781,164.3 ns&#xA;361,625.63 ns&#xA;320,571.70 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;29,954,093.9 ns&#xA;588,614.32 ns&#xA;916,401.59 ns&#xA;1.01&#xA;0.04&#xA;563 B&#xA;&#xA;&#xA;&#xA;That helped, by quite a lot, it seems, for most cases, the 32M items case, however, was slightly slower, which is quite a surprise.&#xA;Looking at the assembly, I can see that we still have branches, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          M02_L03:&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;2]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]&#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9          ; if items[i&#x2B;2] &lt; 0:&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L04  ;     continue&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,eax&#xA;        &#xA;        &#xA;          &#xA;                 lea       eax,[r10&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r10*8],r9&#xA;        &#xA;        &#xA;          &#xA;          M02_L04:&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;3]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8] &#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9          ; if items[i&#x2B;3] &lt; 0:&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L05  ;     continue&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,eax&#xA;        &#xA;        &#xA;          &#xA;                 lea       eax,[r10&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r10*8],r9&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          branches.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;And here is why this is the case:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.AggressiveInlining)]&#xA;        &#xA;        &#xA;          &#xA;          void AddToOutput(ref long output, long input)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (input &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                  return;&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;) = input;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          AddToOutput.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Now, can we do better here? It turns out that we can, by using a branchless version of the operation. Here is another way to write the same thing:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.AggressiveInlining)]&#xA;        &#xA;        &#xA;          &#xA;          unsafe void AddToOutput(ref long output, long input)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              bool isNegative = (input &lt; 0);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.Add(ref output, outputIdx) = input;&#xA;        &#xA;        &#xA;          &#xA;              outputIdx &#x2B;= *(byte*)&amp;isNegative;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          AddToOutput.Branchless.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What happens here is that we are unconditionally setting the value in the array, but only increment if the value is greater than or equal to zero. That saves us in branches and will likely result in less code. In fact, let&#x2019;s see what sort of assembly the JIT will output:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;                 movsxd    r9,r8d         ; r9 = i&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]  ; r9 = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9         ; copy the item to r10 temporary&#xA;        &#xA;        &#xA;          &#xA;                 not       r10            ; flips the bits, important for the next instruction&#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F         ; r10 = r9 &gt;&gt; 63 (basically, if &lt; 0, it&#x27;s 1, otherwise 0)&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax        ; r11 = outputIdx&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9 ; items[outputIdx] = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d       ; outputIdx &#x2B;= (items[i] &lt; 0 ? 0 : 1);&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;1]     ; i&#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]  ; r9 = items[&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9         ; and the same here for the next round...&#xA;        &#xA;        &#xA;          &#xA;                 not       r10&#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          movsxd    r9,r8d         &#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8] &#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9         ; &#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F         &#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax        ; r11 is the outputIdx &#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9 ; items[outputIdx]&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d       ; outputIdx &#x2B;= r10 (which is 1 i&#xA;        &#xA;        &#xA;          &#xA;                 lea       r9d,[r8&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r9,r9d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,r9&#xA;        &#xA;        &#xA;          &#xA;                 shr       r10,3F&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,eax&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;r11*8],r9&#xA;        &#xA;        &#xA;          &#xA;                 add       eax,r10d&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Unrolled.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What about the performance? I decided to pit the two versions (normal and branchless) head to head and see what this will give us:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;276.3 ns&#xA;4.13 ns&#xA;3.86 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;23&#xA;263.6 ns&#xA;0.95 ns&#xA;0.84 ns&#xA;0.96&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;743.7 ns&#xA;9.41 ns&#xA;8.80 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1047&#xA;733.3 ns&#xA;3.54 ns&#xA;3.31 ns&#xA;0.99&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;502,631.1 ns&#xA;3,641.47 ns&#xA;3,406.23 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1048599&#xA;495,590.9 ns&#xA;335.33 ns&#xA;297.26 ns&#xA;0.99&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;29,356,331.7 ns&#xA;207,133.86 ns&#xA;172,966.15 ns&#xA;1.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;33554455&#xA;29,709,835.1 ns&#xA;86,129.58 ns&#xA;71,922.10 ns&#xA;1.01&#xA;547 B&#xA;&#xA;&#xA;&#xA;Surprisingly enough, it looks like the branchless version is very slightly slower. That is a surprise, since I would expect reducing the branches to be more efficient.&#xA;Looking at the assembly of those two, the branchless version is slightly bigger (10 bytes, not that meaningful). I think that the key here is that there is a 0.5% chance of actually hitting the branch, which is pretty low. That means that the branch predictor can likely do a really good job and we aren&#x2019;t going to see any big benefits from the branchless version.&#xA;That said&#x2026; what would happen if we tested that with 5% negatives? That difference in behavior may cause us to see a different result. I tried that, and the results were quite surprising. In the case of the 1K and 32M items, we see a slightl&#xA0;cost for the branchless version (additional 1% &#x2013; 4%) while for the 1M entries there is an 18% reduction in latency for the branchless version.&#xA;I ran the tests again with a 15% change of negative, to see what would happen. In that case, we get:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;23&#xA;273.5 ns&#xA;3.66 ns&#xA;3.42 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;23&#xA;280.2 ns&#xA;4.85 ns&#xA;4.30 ns&#xA;1.03&#xA;0.02&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1047&#xA;1,675.7 ns&#xA;29.55 ns&#xA;27.64 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1047&#xA;1,676.3 ns&#xA;16.97 ns&#xA;14.17 ns&#xA;1.00&#xA;0.02&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;1048599&#xA;2,206,354.4 ns&#xA;6,141.19 ns&#xA;5,444.01 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;1048599&#xA;1,688,677.3 ns&#xA;11,584.00 ns&#xA;10,835.68 ns&#xA;0.77&#xA;0.01&#xA;547 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp_Unroll&#xA;33554455&#xA;205,320,736.1 ns&#xA;2,757,108.01 ns&#xA;2,152,568.58 ns&#xA;1.00&#xA;0.00&#xA;537 B&#xA;&#xA;&#xA;FilterCmp_Unroll_Branchleses&#xA;33554455&#xA;199,520,169.4 ns&#xA;2,097,285.87 ns&#xA;1,637,422.86 ns&#xA;0.97&#xA;0.01&#xA;547 B&#xA;&#xA;&#xA;&#xA;As you can see, we have basically the same cost under 15% negatives for small values, a big improvement on the 1M scenario and not much improvement on the 32M scenario.&#xA;All in all, that is very interesting information. Digging into the exact why and how of that means pulling a CPU instruction profiler and starting to look at where we have stalls, which is a bit further that I want to invest in this scenario.&#xA;What if we&#x2019;ll try to rearrange the code a little bit. The code looks like this (load the value and AddToOutput() immediately):&#xA;&#xA;AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 0));&#xA;&#xA;What if we split it a little bit, so the code will look like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (; i &#x2B; 4 &lt; items.Length; i &#x2B;= 4)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var i0 = Unsafe.Add(ref itemsRef, i &#x2B; 0);&#xA;        &#xA;        &#xA;          &#xA;              var i1 = Unsafe.Add(ref itemsRef, i &#x2B; 1);&#xA;        &#xA;        &#xA;          &#xA;              var i2 = Unsafe.Add(ref itemsRef, i &#x2B; 2);&#xA;        &#xA;        &#xA;          &#xA;              var i3 = Unsafe.Add(ref itemsRef, i &#x2B; 3);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i0);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i1);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i2);&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, i3);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ReShuffle.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The idea here is that we are trying to get the JIT / CPU to fetch the items before they are actually needed, so there would be more time for the memory to arrive.&#xA;Remember that for the 1M scenario, we are dealing with 8MB of memory and for the 32M scenario, we have 256MB. Here is what happens when we look at the loop prolog, we can see that it is indeed first fetching all the items from memory, then doing the work:&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;                 movsxd    r9,r8d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rdx&#x2B;r9*8]&#xA;        &#xA;        &#xA;          &#xA;                 lea       r10d,[r8&#x2B;1]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r10,r10d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,[rdx&#x2B;r10*8]&#xA;        &#xA;        &#xA;          &#xA;                 lea       r11d,[r8&#x2B;2]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    r11,r11d&#xA;        &#xA;        &#xA;          &#xA;                 mov       r11,[rdx&#x2B;r11*8]&#xA;        &#xA;        &#xA;          &#xA;                 lea       esi,[r8&#x2B;3]&#xA;        &#xA;        &#xA;          &#xA;                 movsxd    rsi,esi&#xA;        &#xA;        &#xA;          &#xA;                 mov       rsi,[rdx&#x2B;rsi*8]&#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          shuffled.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;In terms of performance, that gives us a small win (1% &#x2013; 2% range) for the 1M and 32M entries scenario.&#xA;The one last thing that I wanted to test is if we&#x2019;ll unroll the loop even further, what would happen if we did 8 items per loop, instead of 4.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (; i &#x2B; 8 &lt; items.Length; i &#x2B;= 8)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Sse.Prefetch2(Unsafe.AsPointer(ref Unsafe.Add(ref itemsRef, i &#x2B; 0)));&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 0));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 1));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 2));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 3));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 4));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 5));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 6));&#xA;        &#xA;        &#xA;          &#xA;              AddToOutput(ref itemsRef, Unsafe.Add(ref itemsRef, i &#x2B; 7));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Roll8AndPreftech.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There is some improvement, (4% in the 1K scenario, 1% in the 32M scenario) but also slowdowns&#xA0; (2% in the 1M scenario).&#xA;I think that this is probably roughly the end of the line as far as we can get for scalar code.&#xA;We already made quite a few strides in trying to parallelize the work the CPU is doing by just laying out the code as we would like it to be. We tried to control the manner in which it touches memory and in general, those are pretty advanced techniques.&#xA;To close this post, I would like to take a look at the gains we got. I&#x2019;m comparing the first version of the code, the last version we had on the previous post and the unrolled version for both branchy and branchless with 8 operations at once and memory prefetching.&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;277.3 ns&#xA;0.69 ns&#xA;0.64 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;23&#xA;270.7 ns&#xA;0.42 ns&#xA;0.38 ns&#xA;0.98&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;23&#xA;257.6 ns&#xA;1.45 ns&#xA;1.21 ns&#xA;0.93&#xA;0.00&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;23&#xA;259.9 ns&#xA;1.96 ns&#xA;1.84 ns&#xA;0.94&#xA;0.01&#xA;682 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;754.3 ns&#xA;1.38 ns&#xA;1.22 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1047&#xA;749.0 ns&#xA;1.81 ns&#xA;1.69 ns&#xA;0.99&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;1047&#xA;647.2 ns&#xA;2.23 ns&#xA;2.09 ns&#xA;0.86&#xA;0.00&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;1047&#xA;721.2 ns&#xA;1.23 ns&#xA;1.09 ns&#xA;0.96&#xA;0.00&#xA;682 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;499,675.6 ns&#xA;2,639.97 ns&#xA;2,469.43 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1048599&#xA;494,388.4 ns&#xA;600.46 ns&#xA;532.29 ns&#xA;0.99&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;1048599&#xA;426,940.7 ns&#xA;1,858.57 ns&#xA;1,551.99 ns&#xA;0.85&#xA;0.01&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;1048599&#xA;483,940.8 ns&#xA;517.14 ns&#xA;458.43 ns&#xA;0.97&#xA;0.00&#xA;682 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;30,282,334.8 ns&#xA;599,306.15 ns&#xA;531,269.30 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;33554455&#xA;29,410,612.5 ns&#xA;29,583.56 ns&#xA;24,703.61 ns&#xA;0.97&#xA;0.02&#xA;397 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8&#xA;33554455&#xA;29,102,708.3 ns&#xA;42,824.78 ns&#xA;40,058.32 ns&#xA;0.96&#xA;0.02&#xA;672 B&#xA;&#xA;&#xA;FilterCmp_Unroll_8_Branchless&#xA;33554455&#xA;29,761,841.1 ns&#xA;48,108.03 ns&#xA;42,646.51 ns&#xA;0.98&#xA;0.02&#xA;682 B&#xA;&#xA;&#xA;&#xA;The unrolled 8 version is the winner by far, in this scenario (0.5% negatives). Since that is the scenario we have in the real code, that is what I&#x2019;m focusing on.&#xA;Is there anything left to do here?&#xA;My next step is to explore whether&#xA0;using vector instructions will be a good option for us.</p>
        </article>
        <article id="article-342">
            <a href="https://ayende.com/blog/200100-C/filtering-negative-numbers-fast-scalar" target="_blank">
                <h2 class="title mb-6" id="article-342">Filtering negative numbers, fast</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 11, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">While working deep on the guts of RavenDB, I found myself with a seemingly simple task. Given a list of longs, I need to filter out all negative numbers as quickly as possible.&#xA;The actual scenario is that we run a speculative algorithm, given a potentially large list of items, we check if we can fulfill the request in an optimal fashion. However, if that isn&#x2019;t possible, we need to switch to a slower code path that does more work.&#xA;Conceptually, this looks something like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void Run(Span&lt;long&gt; entries, long switchOverPoint, Aggregation state)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;            long cost = 0;&#xA;        &#xA;        &#xA;          &#xA;            for (var i = 0; i &lt; entries.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;            {&#xA;        &#xA;        &#xA;          &#xA;              var (item, searchCost) = FetchCheaply(entries[i]);&#xA;        &#xA;        &#xA;          &#xA;              cost &#x2B;= searchCost;&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if(item is not null)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                 entries[i] = -entries[i]; // mark as processed&#xA;        &#xA;        &#xA;          &#xA;                 if(state.Aggregate(item))&#xA;        &#xA;        &#xA;          &#xA;                    return; // we have enough results to bail early&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              &#xA;        &#xA;        &#xA;          &#xA;              if(cost &gt; switchOverPoint)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                // speculative execution failed, we need to do this the hard way&#xA;        &#xA;        &#xA;          &#xA;                RunManually(entries, state);&#xA;        &#xA;        &#xA;          &#xA;                return;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Choices.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;That is the setup for this story. The problem we have now is that we now need to filter the results we pass to the RunManually() method.&#xA;There is a problem here, however. We marked the entries that we already used in the list by negating them. The issue is that RunManually() does not allow negative values, and its internal implementation is not friendly to ignoring those values.&#xA;In other words, given a Span&lt;long&gt;, I need to write the code that would filter out all the negative numbers. Everything else about the list of numbers should remain the same (the order of elements, etc).&#xA;From a coding perspective, this is as simple as:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public Span&lt;long&gt; FilterNegative(Span&lt;long&gt; entries)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return entries.ToArray().Where(l =&gt; l &gt; 0).ToArray();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          VeryBad.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Please note, just looking at this code makes me cringe a lot. This does the work, but it has an absolutely horrible performance profile. It allocates multiple arrays, uses a lambda, etc.&#xA;We don&#x2019;t actually care about the entries here, so we are free to modify them without allocating a new value. As such, let&#x2019;s see what kind of code we can write to do this work in an efficient manner. Here is what I came up with:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              int output = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (items[i] &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  items[output&#x2B;&#x2B;] = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return output;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Cmp.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The way this works is that we scan through the list, skipping writing the negative lists, so we effectively &#x201C;move down&#x201D; all the non-negative lists on top of the negative ones. This has a cost of O(N) and will modify the entire array, the final output is the number of valid items that we have there.&#xA;In order to test the performance, I wrote the following harness:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [RPlotExporter]&#xA;        &#xA;        &#xA;          &#xA;          [DisassemblyDiagnoser]&#xA;        &#xA;        &#xA;          &#xA;          public class SimdVsScalar&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              private long[] items;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Params(1024 &#x2B; 23, 1024 * 1024 &#x2B; 23, 32 * 1024 * 1024 &#x2B; 23)]&#xA;        &#xA;        &#xA;          &#xA;              public int N;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [GlobalSetup]&#xA;        &#xA;        &#xA;          &#xA;              public void Setup()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  items = new long[N];&#xA;        &#xA;        &#xA;          &#xA;                  var r = new Random(2391);&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      items[i] = r.NextInt64();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private void SprinkleNegatives()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var r = new Random(13245);&#xA;        &#xA;        &#xA;          &#xA;                  var negatives = Math.Max((int)(items.Length * 0.005), 1);&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; negatives; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var idx = r.Next(items.Length);&#xA;        &#xA;        &#xA;          &#xA;                      items[idx] = -items[idx];&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Benchmark]&#xA;        &#xA;        &#xA;          &#xA;              public int FilterOr()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  SprinkleNegatives();&#xA;        &#xA;        &#xA;          &#xA;                  return Filter.FilterOr(items);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Benchmark]&#xA;        &#xA;        &#xA;          &#xA;              public int FilterCmp()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  SprinkleNegatives();&#xA;        &#xA;        &#xA;          &#xA;                  return Filter.FilterCmp(items);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              [Benchmark]&#xA;        &#xA;        &#xA;          &#xA;              public int Base()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  SprinkleNegatives();&#xA;        &#xA;        &#xA;          &#xA;                  return items.Length;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Bench.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;We compare 1K, 1M and 32M elements arrays, each of which has about 0.5% negative, randomly spread across the range. Because we modify the values directly, we need to sprinkle the negatives across the array on each call. In this case, I&#x2019;m testing two options for this task, one that uses a direct comparison (shown above) and one that uses bitwise or, like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterOr(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              int output = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if ((items[i] &amp; ~long.MaxValue) != 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  items[output&#x2B;&#x2B;] = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return output;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterOr.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m testing the cost of sprinkling negatives as well, since that has to be done before each benchmark call (since we modify the array during the call, we need to &#x201C;reset&#x201D; its state for the next one).&#xA;Given the two options, before we discuss the results, what would you expect to be the faster option? How would the size of the array matter here?&#xA;I really like this example, because it is simple, there isn&#x2019;t any real complexity in what we are trying to do. And there is a very straightforward implementation that we can use as our baseline. That also means that I get to analyze what is going on at a very deep level. You might have noticed the disassembler attribute on the benchmark code, we are going to dive deep into that. For the same reason, we aren&#x2019;t using exactly 1K, 1M, or 32M arrays, but slightly higher than that, so we&#x2019;ll have to deal with remainders later on.&#xA;Let&#x2019;s first look at what the JIT actually did here. Here is the annotated assembly for the FilterCmp function:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          ; Filter.FilterCmp(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 sub       rsp,28            ; Reserve stack space&#xA;        &#xA;        &#xA;          &#xA;                 mov       rax,[rcx]         ; rax now holds the pointer from the span&#xA;        &#xA;        &#xA;          &#xA;                 mov       edx,[rcx&#x2B;8]       ; edx now holds the length of the span&#xA;        &#xA;        &#xA;          &#xA;                 xor       ecx,ecx           ; zero ecx (i)&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d           ; zero r8d (output)&#xA;        &#xA;        &#xA;          &#xA;                 test      edx,edx           ; if items.Length &lt;= 0&#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L02     ; jump the epilog &amp; return&#xA;        &#xA;        &#xA;          &#xA;          M02_L00:&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9d,r8d           &#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,[rax&#x2B;r9*8]     ; r9 = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 test      r9,r9             ; r9 &lt; 0&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L01     ; continue to next iteration&#xA;        &#xA;        &#xA;          &#xA;                 &#xA;        &#xA;        &#xA;          &#xA;                 ; items[output] -- range check&#xA;        &#xA;        &#xA;          &#xA;                 lea       r10d,[rcx&#x2B;1]      ; r10d = output&#x2B;1&#xA;        &#xA;        &#xA;          &#xA;                 cmp       ecx,edx           ; check against items.length&#xA;        &#xA;        &#xA;          &#xA;                 jae       short M02_L03     ; jump to out of range exception&#xA;        &#xA;        &#xA;          &#xA;                 &#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,ecx           ; clear high bits in rcx (overflow from addition?)&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rax&#x2B;rcx*8],r9    ; items[output] = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,r10d          ; output = r10d&#xA;        &#xA;        &#xA;          &#xA;          M02_L01:&#xA;        &#xA;        &#xA;          &#xA;                 inc       r8d               ; i&#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r8d,edx           ; i &lt; item.Length&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L00     ; back to start of the loop&#xA;        &#xA;        &#xA;          &#xA;          M02_L02:&#xA;        &#xA;        &#xA;          &#xA;                 mov       eax,ecx           ; return output&#xA;        &#xA;        &#xA;          &#xA;                 add       rsp,28&#xA;        &#xA;        &#xA;          &#xA;                 ret&#xA;        &#xA;        &#xA;          &#xA;          M02_L03:                           ; range check failure&#xA;        &#xA;        &#xA;          &#xA;                 call      CORINFO_HELP_RNGCHKFAIL&#xA;        &#xA;        &#xA;          &#xA;                 int       3&#xA;        &#xA;        &#xA;          &#xA;          ; Total bytes of code 69&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For the FilterOr, the code is pretty much the same, except that the key part is:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          -       test      r9,r9&#x9;&#xA;        &#xA;        &#xA;          &#xA;          -       jl        short M02_L01&#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;       mov       r10,8000000000000000&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;       test      r10,r9&#xA;        &#xA;        &#xA;          &#xA;          &#x2B;       jne       short M02_L01&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          CmpVsOr.diff&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, the cmp option is slightly smaller, in terms of code size. In terms of performance, we have:&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;&#xA;&#xA;&#xA;&#xA;FilterOr&#xA;1047&#xA;745.6 ns&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;745.8 ns&#xA;&#xA;&#xA;&#x2014;&#xA;&#x2013;&#xA;&#x2013;&#xA;&#xA;&#xA;FilterOr&#xA;1048599&#xA;497,463.6 ns&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;498,784.8 ns&#xA;&#xA;&#xA;&#x2014;&#xA;&#x2013;&#xA;&#x2013;&#xA;&#xA;&#xA;FilterOr&#xA;33554455&#xA;31,427,660.7 ns&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;30,024,102.9 ns&#xA;&#xA;&#xA;&#xA;The costs are very close to one another, with Or being very slightly faster on low numbers, and Cmp being slightly faster on the larger sizes. Note that the difference level between them is basically noise. They have the same performance.&#xA;The question is, can we do better here?&#xA;Looking at the assembly, there is an extra range check in the main loop that the JIT couldn&#x2019;t elide (the call to items[output&#x2B;&#x2B;]). Can we do something about it, and would it make any difference in performance? Here is how I can remove the range check:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_NoRangeCheck(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (items[i] &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  ref var outputDest = ref Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  outputDest = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here I&#x2019;m telling the JIT: &#x201C;I know what I&#x2019;m doing&#x201D;, and it shows.&#xA;Let&#x2019;s look at the assembly changes between those two methods, first the prolog:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          &#x9;; Filter.FilterCmp_NoRangeCheck(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 sub       rsp,28             ; setup stack space&#xA;        &#xA;        &#xA;          &#xA;                 mov       rax,[rcx]          ; rax is not the pointer for the span&#xA;        &#xA;        &#xA;          &#xA;                 mov       edx,[rcx&#x2B;8]        ; edx is the length of the span&#xA;        &#xA;        &#xA;          &#xA;                 xor       ecx,ecx            ; zero ecx (i = 0)&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d            ; zero r8d (outputIdx = 0)&#xA;        &#xA;        &#xA;          &#xA;                 test      edx,edx            ; if items.Length == 0&#xA;        &#xA;        &#xA;          &#xA;                 je        short M02_L03      ; jump to CORINFO_HELP_RNGCHKFAIL&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,rax             ; output = items[0]&#xA;        &#xA;        &#xA;          &#xA;                 test      edx,edx            ; if items.Length &lt;= 0&#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L02      ; jump past the for loop&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck.prolog.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Here you can see what we are actually doing here. Note the last 4 instructions,&#xA0;we have a range check for the items, and then we have another check for the loop. The first will get you an exception, the second will just skip the loop. In both cases, we test the exact same thing. The JIT had a chance to actually optimize that, but didn&#x2019;t.&#xA;Here is a funny scenario where adding code may reduce the amount of code generated. Let&#x2019;s do another version of this method:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public static int FilterCmp_NoRangeCheck(Span&lt;long&gt; items)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              if (items.Length == 0)&#xA;        &#xA;        &#xA;          &#xA;                  return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              int i = 0;&#xA;        &#xA;        &#xA;          &#xA;              ref var output = ref items[i];&#xA;        &#xA;        &#xA;          &#xA;              for (; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (items[i] &lt; 0)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;                  ref var outputDest = ref Unsafe.Add(ref output, outputIdx&#x2B;&#x2B;);&#xA;        &#xA;        &#xA;          &#xA;                  outputDest = items[i];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              return outputIdx;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck2.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In this case, I added a check to handle the scenario of items being empty. What can the JIT do with this now? It turns out, quite a lot. We dropped 10 bytes from the method, which is a nice result of our diet.&#xA0; Here is the annotated version of the assembly:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          ; Filter.FilterCmp_NoRangeCheck(System.Span`1&lt;Int64&gt;)&#xA;        &#xA;        &#xA;          &#xA;                 mov       rdx,[rcx]        ; rdx = pointer of items&#xA;        &#xA;        &#xA;          &#xA;                 mov       ecx,[rcx&#x2B;8]      ; ecx = length of items&#xA;        &#xA;        &#xA;          &#xA;                 test      ecx,ecx          ; items.Length == 0&#xA;        &#xA;        &#xA;          &#xA;                 jne       short M02_L00    ; if not true, jump ahead&#xA;        &#xA;        &#xA;          &#xA;                 xor       eax,eax          ; return 0&#xA;        &#xA;        &#xA;          &#xA;                 ret&#xA;        &#xA;        &#xA;          &#xA;          M02_L00:&#xA;        &#xA;        &#xA;          &#xA;                 xor       eax,eax          ; outputIdx = 0&#xA;        &#xA;        &#xA;          &#xA;                 xor       r8d,r8d          ; i = 0&#xA;        &#xA;        &#xA;          &#xA;                 mov       r9,rdx           ; output = items.pointer&#xA;        &#xA;        &#xA;          &#xA;                 test      ecx,ecx          ; if items.Length &lt;= 0&#xA;        &#xA;        &#xA;          &#xA;                 jle       short M02_L03    ; jump to end function exit&#xA;        &#xA;        &#xA;          &#xA;          M02_L01:&#xA;        &#xA;        &#xA;          &#xA;                 mov       r10d,r8d          &#xA;        &#xA;        &#xA;          &#xA;                 mov       r10,[r9&#x2B;r10*8]   ; r10 = items[i]&#xA;        &#xA;        &#xA;          &#xA;                 test      r10,r10          ; if items[i] &lt; 0&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L02&#xA;        &#xA;        &#xA;          &#xA;                 lea       r11d,[rax&#x2B;1]     ; r11d = output &#x2B;1&#xA;        &#xA;        &#xA;          &#xA;                 cdqe                       ; sign extent RAX (32 bits module on the addition)&#xA;        &#xA;        &#xA;          &#xA;                 mov       [rdx&#x2B;rax*8],r10  ; copy r10 (items[i]) to items[r11d]&#xA;        &#xA;        &#xA;          &#xA;                 mov       eax,r11d         ; outputIdx = r11d&#xA;        &#xA;        &#xA;          &#xA;          M02_L02:&#xA;        &#xA;        &#xA;          &#xA;                 inc       r8d              ; i&#x2B;&#x2B;&#xA;        &#xA;        &#xA;          &#xA;                 cmp       r8d,ecx          ; i &lt; items.Length&#xA;        &#xA;        &#xA;          &#xA;                 jl        short M02_L01    ; do the loop again&#xA;        &#xA;        &#xA;          &#xA;          M02_L03:&#xA;        &#xA;        &#xA;          &#xA;                 ret                        ; return&#xA;        &#xA;        &#xA;          &#xA;          ; Total bytes of code 59&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          FilterCmp_NoRangeCheck.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;A lot of the space savings in this case come from just not having to do a range check, but you&#x2019;ll note that we still do an extra check there (lines 12..13), even though we already checked that. I think that the JIT knows that the value is not zero at this point, but has to consider that the value may be negative.&#xA;If we&#x2019;ll change the initial guard clause to: items.Length &lt;= 0, what do you think will happen? At this point, the JIT is smart enough to just elide everything, we are at 55 bytes of code and it is a super clean assembly (not a sentence I ever thought I would use). I&#x2019;ll spare you going through more assembly listing, but you can find the output here.&#xA;And after all of that, where are we at?&#xA;&#xA;&#xA;&#xA;Method&#xA;N&#xA;Mean&#xA;Error&#xA;StdDev&#xA;Ratio&#xA;RatioSD&#xA;Code Size&#xA;&#xA;&#xA;&#xA;&#xA;FilterCmp&#xA;23&#xA;274.5 ns&#xA;1.91 ns&#xA;1.70 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;23&#xA;269.7 ns&#xA;1.33 ns&#xA;1.24 ns&#xA;0.98&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1047&#xA;744.5 ns&#xA;4.88 ns&#xA;4.33 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1047&#xA;745.8 ns&#xA;3.44 ns&#xA;3.22 ns&#xA;1.00&#xA;0.00&#xA;397 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;1048599&#xA;502,608.6 ns&#xA;3,890.38 ns&#xA;3,639.06 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;1048599&#xA;490,669.1 ns&#xA;1,793.52 ns&#xA;1,589.91 ns&#xA;0.98&#xA;0.01&#xA;397 B&#xA;&#xA;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA0;&#xA;&#xA;&#xA;FilterCmp&#xA;33554455&#xA;30,495,286.6 ns&#xA;602,907.86 ns&#xA;717,718.92 ns&#xA;1.00&#xA;0.00&#xA;411 B&#xA;&#xA;&#xA;FilterCmp_NoRangeCheck&#xA;33554455&#xA;29,952,221.2 ns&#xA;442,176.37 ns&#xA;391,977.84 ns&#xA;0.99&#xA;0.02&#xA;397 B&#xA;&#xA;&#xA;&#xA;There is a very slight benefit to the NoRangeCheck, but even when we talk about 32M items, we aren&#x2019;t talking about a lot of time.&#xA;The question what can we do better here?</p>
        </article>
        <article id="article-343">
            <a href="https://www.meziantou.net/listing-windows-virtual-desktops-using-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-343">Listing Windows virtual desktops using .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 11, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the blog post Per virtual desktop single-instance application, I introduced the IVirtualDesktopManager interface to detect if a window is on the current virtual desktop. In this post, I describe how to list the virtual desktops. This can be useful to provide a list of virtual desktops to the use</p>
        </article>
        <article id="article-344">
            <a href="https://ardalis.com/building-resilient-email-method-dotnet-retry-outbox-pattern/" target="_blank">
                <h2 class="title mb-6" id="article-344">Building a Resilient Email Sending Method in .NET with SmtpClient, Retry Support, and the Outbox Pattern</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 08, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Introduction In the world of software applications, email sending functionalities are indispensable. From password resets to notifications&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-345">
            <a href="https://andrewlock.net/exploring-the-dotnet-8-preview-introducing-the-identity-api-endpoints/" target="_blank">
                <h2 class="title mb-6" id="article-345">Introducing the Identity API endpoints</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 05, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Exploring the .NET 8 preview - Part 8</p>
        </article>
        <article id="article-346">
            <a href="https://ayende.com/blog/200065-B/optimizing-a-three-way-merge" target="_blank">
                <h2 class="title mb-6" id="article-346">Optimizing a three-way merge</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 04, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Deep inside of the Corax indexing engine inside of RavenDB there is the notion of a posting list. A posting list is just an ordered set of entry ids that contains a particular term. During the indexing process, we need to add and remove items from that posting list. This ends up being something like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          // All three parameters are sorted, the output is the merged list in &#xA;        &#xA;        &#xA;          &#xA;          // the existing parameter&#xA;        &#xA;        &#xA;          &#xA;          long[] Merge(long[] existing, long[] additions, long[] removals);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          merge.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;For fun, go and ask ChatGPT to write you the code for this task.&#xA;You can assume that there are no duplicates between the removals and additions, and that adding an existing item is a no-op (so just one value would be in the end result). Here is a quick solution for this task (not actually tested that much, mind, but sufficient to understand what I&#x2019;m trying to do):&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static long[] Merge(long[] existing, long[] additions, long[] removals)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              List&lt;long&gt; result = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int existingIndex = 0;&#xA;        &#xA;        &#xA;          &#xA;              int additionsIndex = 0;&#xA;        &#xA;        &#xA;          &#xA;              int removalsIndex = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              for (; existingIndex &lt; existing.Length; existingIndex&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  bool removed = false;&#xA;        &#xA;        &#xA;          &#xA;                  for (; removalsIndex &lt; removals.Length; removalsIndex&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (removals[removalsIndex] &gt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          break; // will remove in the future&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      if (removals[removalsIndex] &lt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          continue; // not in the existing, can skip&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      removed = true;&#xA;        &#xA;        &#xA;          &#xA;                      break;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (removed)&#xA;        &#xA;        &#xA;          &#xA;                      continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (additionsIndex &gt;= additions.Length)&#xA;        &#xA;        &#xA;          &#xA;                      break; // no work remaining&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  for (; additionsIndex &lt; additions.Length; additionsIndex&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (additions[additionsIndex] &gt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          break;&#xA;        &#xA;        &#xA;          &#xA;                      else if (additions[additionsIndex] &lt; existing[existingIndex])&#xA;        &#xA;        &#xA;          &#xA;                          result.Add(additions[additionsIndex]);&#xA;        &#xA;        &#xA;          &#xA;                      else&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          // it&#x27;s equal, so we&#x27;ll move to the next one and let the existing add it&#xA;        &#xA;        &#xA;          &#xA;                      }    &#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  result.Add(existing[existingIndex]);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              // add the remainders&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(additions[additionsIndex..]);&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(existing[existingIndex..]);&#xA;        &#xA;        &#xA;          &#xA;              return result.ToArray();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Merge.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;If you look at this code in terms of performance, you&#x2019;ll realize that this is quite expensive. In terms of complexity, this is actually pretty good, we iterate over the arrays just once, and the number of comparisons is also bounded to the lengths of the list.&#xA;However, there is a big issue here, the number of branches that you have to deal with. Basically, every if and every for loop is going to add a tiny bit of latency to the system. This is because these are unpredictable branches, which are pretty nasty to deal with.&#xA;It turns out that the values that we put in the posting list are actually always a multiple of 4, so the bottom 2 bits are always cleared. That means that we actually have a different way to deal with it. Here is the new logic:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static long[] MergeOptimized(long[] existing, long[] additions, long[] removals)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; removals.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  removals[i] |= 1;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              List&lt;long&gt; result = new List&lt;long&gt;();&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(existing);&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(additions);&#xA;        &#xA;        &#xA;          &#xA;              result.AddRange(removals);&#xA;        &#xA;        &#xA;          &#xA;              result.Sort();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int outputIdx = 0;&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; result.Count - 1; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  outputIdx &#x2B;= ToInt32((result[i &#x2B; 1] &amp; ~1) != result[i]);&#xA;        &#xA;        &#xA;          &#xA;                  result[outputIdx] = result[i &#x2B; 1];&#xA;        &#xA;        &#xA;          &#xA;                  outputIdx -= (int)(result[i &#x2B; 1] &amp; 1);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return result.Take(outputIdx).ToArray();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          MergeOptimized.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This code was written with an eye to being able to explain the algorithm, mind, not performance.&#xA;The idea goes like this. We flag the removals with a bit, then concatenate all the arrays together, sort them, and then do a single scan over the whole thing, removing duplicates and removals.&#xA;In the real code, we are using raw pointers, not a List, so there&#xA0;are no access checks, etc.&#xA;From an algorithmic perspective, this code makes absolutely no sense at all. We concatenate all the values together, then sort them (O(NlogN) operation) then scan it again?!&#xA;How can that be faster than a single scan across all three arrays? The answer is simple, we have a really efficient sort primitive (vxsort) that is able to sort things really fast (GB/sec). There is a really good series of posts that explain how that is achieved.&#xA;Since we consider sorting to be cheap, the rest of the work is just a single scan on the list, and there are no branches at all there. The code plays with the offset that we write into, figuring out whether&#xA0;we need to overwrite the current value (duplicate) or go back (removal), but in general it means that it can execute very quickly.&#xA;This approach also has another really important aspect. Take a look at the actual code that we have in production. This is from about an hour worth of profiling a busy indexing session:&#xA;&#xA;And the more common code path:&#xA;&#xA;In both of them, you&#x2019;ll notice something really important. There isn&#x2019;t a call to sorting at all in here. In fact, when I search for the relevant function, I find:&#xA;&#xA;That is 25 ms out of over an hour.&#xA;How can this be? As efficient as the sorting can be, we are supposed to be calling it a lot.&#xA;Well, consider one scenario, what happens if:&#xA;&#xA;&#xA;There are no removals&#xA;&#xA;&#xA;All additions happen after the last existing item in the list&#xA;&#xA;&#xA;In this case, I don&#x2019;t need to do anything beyond concatenate the lists. I can skip the entire process entirely, just copy the existing and additions to the output and call it a day.&#xA;Even when I do have a lot of removals and complicated merge processes, the code structure means that the CPU can get through this code very quickly. This isn&#x2019;t super friendly for humans to read, but for the CPU, this is chump change.</p>
        </article>
        <article id="article-347">
            <a href="https://www.meziantou.net/turn-off-monitors-when-locking-the-computer.htm" target="_blank">
                <h2 class="title mb-6" id="article-347">Turn off monitors when locking the computer</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: September 04, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">When I lock my computer, it&#x27;s because I&#x27;m going to leave it for a while. I don&#x27;t want to waste energy by keeping the monitors on and I don&#x27;t like having a useless source of light. So, I want to turn them off automatically when I lock my computer.To turn off monitors on Windows, you can use the Send</p>
        </article>
        <article id="article-348">
            <a href="https://ayende.com/blog/200033-B/not-all-o-1-operations-are-considered-equal" target="_blank">
                <h2 class="title mb-6" id="article-348">Not all O(1) operations are considered equal</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 30, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">At some point in any performance optimization sprint, you are going to run into a super annoying problem: The dictionary.&#xA;The reasoning is quite simple. One of the most powerful optimization techniques is to use a cache, which is usually implemented as a dictionary. Today&#x2019;s tale is about a dictionary, but surprisingly enough, not about a cache.&#xA;Let&#x2019;s set up the background, I&#x2019;m looking at optimizing a big indexing batch deep inside RavenDB, and here is my current focus:&#xA;&#xA;&#xA;&#xA;You can see that the RecordTermsForEntries take 4% of the overall indexing time. That is&#x2026; a lot, as you can imagine.&#xA;What is more interesting here is why. The simplified version of the code looks like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private readonly Dictionary&lt;long, List&lt;RecordedTerm&gt;&gt; _termsPerEntryId = new();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private void RecordTermsForEntries(List&lt;TermInEntryModification&gt; entriesForTerm, long termContainerId)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; entriesForTerm.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var entry = entriesForTerm[i];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  ref var entryTerms = ref CollectionsMarshal.GetValueRefOrAddDefault(_termsPerEntryId, entry.EntryId, out var exists);&#xA;        &#xA;        &#xA;          &#xA;                  if (exists == false)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      entryTerms = new List&lt;RecordedTerm&gt;();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  entryTerms.Add(&#xA;        &#xA;        &#xA;          &#xA;                      new RecordedTerm&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          TermContainerId = recordedTermContainerId&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          RecordTermsForEntries.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Basically, we are registering, for each entry, all the terms that belong to it. This is complicated by the fact that we are doing the process in stages:&#xA;&#xA;Create the entries&#xA;Process the terms for the entries&#xA;Write the terms to persistent storage (giving them the recorded term id)&#xA;Update the entries to record the term ids that they belong to&#xA;&#xA;The part of the code that we are looking at now is the last one, where we already wrote the terms to persistent storage and we need to update the entries. This is needed so when we read them, we&#x2019;ll be able to find the relevant terms.&#xA;At any rate, you can see that this method cost is absolutely dominated by the dictionary call. In fact, we are actually using an optimized method here to avoid doing a TryGetValue() and then Add() in case the value is not already in the dictionary.&#xA;If we actually look at the metrics, this is actually kind of awesome. We are calling the dictionary almost 400 million&#xA0;times and it is able to do the work in under 200 nanoseconds per call.&#xA;That is pretty awesome, but that still means that we have over 2% of our total indexing time spent doing lookups. Can we do better?&#xA;In this case, absolutely. Here is how this works, instead of doing a dictionary lookup, we are going to store a list. And the entry will record the index of the item in the list. Here is what this looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private readonly List&lt;List&lt;RecordedTerm&gt;&gt; _termsPerEntryId = new();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private void RecordTermsForEntries(List&lt;TermInEntryModification&gt; entriesForTerm, long termContainerId)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; entriesForTerm.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var entry = entriesForTerm[i];&#xA;        &#xA;        &#xA;          &#xA;                  if(entry.TermsPerEntryIndex == -1)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      entry.TermsPerEntryIndex = _termsPerEntryId.Count;&#xA;        &#xA;        &#xA;          &#xA;                      _termsPerEntryId.Add(new List&lt;RecordedTerm&gt;());&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  ref var entryTerms = ref CollectionsMarshal.AsSpan(_termsPerEntryId)[_termsPerEntryId.TermContainerId];&#xA;        &#xA;        &#xA;          &#xA;                  &#xA;        &#xA;        &#xA;          &#xA;                  entryTerms.Add(&#xA;        &#xA;        &#xA;          &#xA;                      new RecordedTerm&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          TermContainerId = recordedTermContainerId&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  );&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          RecordTermsForEntries2.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;There isn&#x2019;t much to this process, I admit. I was lucky that in this case, we were able to reorder things in such a way that skipping the dictionary lookup is a viable method.&#xA;In other cases, we would need to record the index at the creation of the entry (effectively reserving the position) and then use that later.&#xA;And the result is&#x2026;&#xA;&#xA;That is pretty good, even if I say so myself. The cost went down from 3.6 microseconds per call to 1.3 microseconds. That is almost 3 folds improvement.</p>
        </article>
        <article id="article-349">
            <a href="https://ayende.com/blog/200002-B/using-ravendb-from-cloudflare-workers" target="_blank">
                <h2 class="title mb-6" id="article-349">Using RavenDB from Cloudflare Workers</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 29, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">RavenDB is a multi-primary database, which means that it allows you to write to multiple nodes at the same time, without needing synchronization between them.&#xA;This ability to run independently from the other nodes in the cluster (or even&#xA0;across clusters) makes RavenDB highly suitable for running on the edge.&#xA;We have recently published a guide on using RavenDB from Cloudflare Workers, as well as a full template so you can get up to speed in a few minutes.&#xA;The ability to run in a Cloudflare Worker (and use a nearby RavenDB server) means that your logic is running closer to the client, which can greatly reduce your overall latency and improve the overall user experience.</p>
        </article>
        <article id="article-350">
            <a href="https://andrewlock.net/exploring-the-dotnet-8-preview-form-binding-in-minimal-apis/" target="_blank">
                <h2 class="title mb-6" id="article-350">Form binding in minimal APIs</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: August 29, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Exploring the .NET 8 preview - Part 7</p>
        </article>
        <div class="button flex justify-between">
            <a href="34.html"><span class="back arrow"></span></a>

            <a href="36.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="/js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>