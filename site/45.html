
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 45 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-441">
            <a href="https://andrewlock.net/using-octokit-graphql-to-interact-with-the-github-discussions-api/" target="_blank">
                <h2 class="title mb-6" id="article-441">Using Octokit.GraphQL to interact with the GitHub discussions API</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 16, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I describe a .NET script/tool I created to migrate the comments on my blog posts from my legacy Disqus account to GitHub discussions&#x2026;</p>
        </article>
        <article id="article-442">
            <a href="https://www.meziantou.net/generate-large-files-using-powershell.htm" target="_blank">
                <h2 class="title mb-6" id="article-442">Generate large files using PowerShell</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 15, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you need to create a large file with random data for testing purposes, you can use PowerShell or PowerShell Core to quickly generate it.PowerShellcopy$path = Join-Path $pwd &quot;test.txt&quot;&#xA;$size = 1GB&#xA;$content = New-Object byte[] $size&#xA;(New-Object System.Random).NextBytes($content)&#xA;&#xA;# Set-Content is</p>
        </article>
        <article id="article-443">
            <a href="https://ardalis.com/avoid-dbcontext-iqueryable-proliferation/" target="_blank">
                <h2 class="title mb-6" id="article-443">Avoid Proliferating DbContext or IQueryable in .NET Apps</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 10, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Most .NET apps use EF Core and a DbContext for data access, but maintainability can suffer when the use of a DbContext or an IQueryable&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-444">
            <a href="https://andrewlock.net/migrating-comments-from-dsqus-to-giscus/" target="_blank">
                <h2 class="title mb-6" id="article-444">Migrating comments from Disqus to giscus</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 09, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I describe a .NET script/tool I created to migrate the comments on my blog posts from my legacy Disqus account to GitHub discussions&#x2026;</p>
        </article>
        <article id="article-445">
            <a href="https://www.meziantou.net/control-visual-studio-from-an-external-application.htm" target="_blank">
                <h2 class="title mb-6" id="article-445">How to Control Visual Studio from an external application</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 08, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">There are multiple use cases where you need to get information from running instances of Visual Studio. For instance, if you create a git client, you may suggest the repositories that correspond to the opened solution, or you want to know if a file is not saved in the editor and show a warning. May</p>
        </article>
        <article id="article-446">
            <a href="https://ayende.com/blog/199457-B/bug-chasing-narrowing-down-the-scope" target="_blank">
                <h2 class="title mb-6" id="article-446">Bug chasing, narrowing down the scope</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 05, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I just completed a major refactoring of a piece of code inside RavenDB that is responsible for how we manage sorted queries. The first two tiers of tests all passed, which is great. Now was the time to test how this change performed. I threw 50M records into RavenDB and indexed them. I did&#x2026; not like the numbers I got back. It makes sense, since I was heavily refactoring to get a particular structure, I could think of a few ways to improve performance, but I like doing this based on profiler output.&#xA;When running the same scenario under the profiler, the process crashed. That is&#x2026; quite annoying, as you can imagine. In fact, I discovered a really startling issue.&#xA;If I index the data and query on it, I get the results I expect. If I restart the process and run the same query, I get an ExecutionEngineException. Trying to debug those is a PITA. In this case, I&#x2019;m 100% at fault, we are doing a lot of unsafe things to get better performance, and it appears that I messed up something along the way. But my only reproduction is a 50M records dataset. To give some context, this means 51GB of documents to be indexed and 18 GB of indexing. Indexing this in release mode takes about 20 minutes. In debug mode, it takes a lot longer.&#xA;Trying to find an error there, especially one that can only happen after you restart the process is going to be a challenging task. But this isn&#x2019;t my first rodeo. Part of good system design is knowing how to address just these sorts of issues.&#xA;The indexing process inside RavenDB is single-threaded per index. That means that we can rule out a huge chunk of issues around race conditions. It also means that we can play certain tricks. Allow me to present you with the nicest tool for debugging that you can imagine: repeatable traces.&#xA;Here is what this looks like in terms of code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private readonly struct IndexOperationsDumper : IDisposable&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;          #if GENERATE_INDEX_ACTION_TRACE&#xA;        &#xA;        &#xA;          &#xA;              private readonly FileStream _fs;&#xA;        &#xA;        &#xA;          &#xA;              private readonly BinaryWriter _bw;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public IndexOperationsDumper(IndexFieldsMapping fieldsMapping)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _fs = File.OpenWrite(&quot;index.bin-log&quot;);&#xA;        &#xA;        &#xA;          &#xA;                  _fs.Position = _fs.Length;&#xA;        &#xA;        &#xA;          &#xA;                  _bw = new BinaryWriter(_fs);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  if (_fs.Length == 0)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      _bw.Write7BitEncodedInt(fieldsMapping.Count);&#xA;        &#xA;        &#xA;          &#xA;                      for (int i = 0; i &lt; fieldsMapping.Count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          IndexFieldBinding indexFieldBinding = fieldsMapping.GetByFieldId(i);&#xA;        &#xA;        &#xA;          &#xA;                          _bw.Write(indexFieldBinding.FieldName.ToString());&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Index(string id, Span&lt;byte&gt; data)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _bw.Write(id);&#xA;        &#xA;        &#xA;          &#xA;                  _bw.Write7BitEncodedInt(data.Length);&#xA;        &#xA;        &#xA;          &#xA;                  _bw.Write(data);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Commit()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _bw.Write(&quot;!Commit!&quot;);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Dispose()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _bw.Dispose();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          #else&#xA;        &#xA;        &#xA;          &#xA;              public IndexOperationsDumper(IndexFieldsMapping fieldsMapping)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              public void Index(string id, Span&lt;byte&gt; data)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Commit()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Dispose()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          #endif&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          IndexOperationsDumper.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In this case, you can see that this is a development only feature, so it is really bare-bones one. What it does is capture the indexing and commit operations on the system and write them to a file. I have another piece of similarly trivial code that reads and applies&#xA0;them, as shown below. Don&#x2019;t bother to dig into that, the code itself isn&#x2019;t really that interesting. What is important is that I have captured the behavior of the system and can now replay it at will.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [Fact]&#xA;        &#xA;        &#xA;          &#xA;          public void ShouldNotCorrupt()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              RequireFileBasedPager();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              using var stream = File.OpenRead(@&quot;/path/to/index.bin-log&quot;);&#xA;        &#xA;        &#xA;          &#xA;              using var br = new BinaryReader(stream);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              using var bsc = new ByteStringContext(SharedMultipleUseFlag.None);&#xA;        &#xA;        &#xA;          &#xA;              using var builder = IndexFieldsMappingBuilder.CreateForWriter(false);&#xA;        &#xA;        &#xA;          &#xA;              var fieldsCount = br.Read7BitEncodedInt();&#xA;        &#xA;        &#xA;          &#xA;              for (int i = 0; i &lt; fieldsCount; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var name = br.ReadString();&#xA;        &#xA;        &#xA;          &#xA;                  builder.AddBinding(i, name);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var fields = builder.Build();&#xA;        &#xA;        &#xA;          &#xA;              int txns = 0;&#xA;        &#xA;        &#xA;          &#xA;              int items = 0;&#xA;        &#xA;        &#xA;          &#xA;              var wtx = Env.WriteTransaction();&#xA;        &#xA;        &#xA;          &#xA;              try&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var iw = new IndexWriter(wtx, fields);&#xA;        &#xA;        &#xA;          &#xA;                  while (true)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      string id;&#xA;        &#xA;        &#xA;          &#xA;                      try&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          id = br.ReadString();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      catch (EndOfStreamException)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          iw.Commit();&#xA;        &#xA;        &#xA;          &#xA;                          iw.Dispose();&#xA;        &#xA;        &#xA;          &#xA;                          wtx.Commit();&#xA;        &#xA;        &#xA;          &#xA;                          wtx.Dispose();&#xA;        &#xA;        &#xA;          &#xA;                          break;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      if (id == &quot;!Commit!&quot;)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          FlushIndexAndRenewWriteTransaction();&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      int len = br.Read7BitEncodedInt();&#xA;        &#xA;        &#xA;          &#xA;                      var buffer = br.ReadBytes(len);&#xA;        &#xA;        &#xA;          &#xA;                      iw.Index(id, buffer);&#xA;        &#xA;        &#xA;          &#xA;                      items&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  using (var rtx = Env.ReadTransaction())&#xA;        &#xA;        &#xA;          &#xA;                      QueryAll(rtx);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  void FlushIndexAndRenewWriteTransaction()&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      iw.Commit();&#xA;        &#xA;        &#xA;          &#xA;                      iw.Dispose();&#xA;        &#xA;        &#xA;          &#xA;                      wtx.Commit();&#xA;        &#xA;        &#xA;          &#xA;                      wtx.Dispose();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      StopDatabase();&#xA;        &#xA;        &#xA;          &#xA;                      StartDatabase();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      using (var rtx = Env.ReadTransaction())&#xA;        &#xA;        &#xA;          &#xA;                          QueryAll(rtx);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      txns&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                      Console.WriteLine(txns &#x2B; &quot; With &quot; &#x2B; items);&#xA;        &#xA;        &#xA;          &#xA;                      items = 0;&#xA;        &#xA;        &#xA;          &#xA;                      wtx = Env.WriteTransaction();&#xA;        &#xA;        &#xA;          &#xA;                      iw = new IndexWriter(wtx, fields);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              finally&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  wtx.Dispose();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              StopDatabase();&#xA;        &#xA;        &#xA;          &#xA;              StartDatabase();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              using (var rtx = Env.ReadTransaction())&#xA;        &#xA;        &#xA;          &#xA;                  QueryAll(rtx);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              void QueryAll(Transaction rtx)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var matches = new long[1024];&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; fieldsCount; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var searcher = new IndexSearcher(rtx, fields);&#xA;        &#xA;        &#xA;          &#xA;                      var field = FieldMetadata.Build(fields.GetByFieldId(i).FieldName, default, i, default, default);&#xA;        &#xA;        &#xA;          &#xA;                      var sort = searcher.OrderBy(searcher.AllEntries(), new OrderMetadata(field, true, MatchCompareFieldType.Sequence));&#xA;        &#xA;        &#xA;          &#xA;                      while (sort.Fill(matches) != 0)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ShouldNotCorrupt.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The code itself isn&#x2019;t much, but it does the job. What is more important, note that we have calls to StopDatabase() and StartDatabase(), I was able to reproduce the crash using this code.&#xA;That was a massive win, since it dropped my search area from 50M documents to merely 1.2 million.&#xA;The key aspect of this is that I now have a way to play around with things. In particular, instead of using the commit points in the trace, I can force a commit (and start / stop the database) every 10,000 items (by calling FlushIndexAndRenewWriteTransaction). When using that, I can reproduce this far faster. Here is the output when I run this in release mode:&#xA;&#xA;1 With 0&#xA;2 With 10000&#xA;3 With 10000&#xA;4 With 10000&#xA;5 With 10000&#xA;6 With 10000&#xA;7 With 10000&#xA;8 With 10000&#xA;9 With 10000&#xA;10 With 10000&#xA;11 With 10000&#xA;Fatal error. Internal CLR error. (0x80131506)&#xA;&#xA;&#xA;So now I dropped the search area to 120,000 items, which is pretty awesome. Even more important, when I run this in debug mode, I get this:&#xA;&#xA;1 With 0&#xA;2 With 10000&#xA;Process terminated. Assertion failed.&#xA;   at Voron.Data.Containers.Container.Get(Low...&#xA;&#xA;So now I have a repro in 30,000 items, what is even better, a debug assertion was fired, so I have a really good lead into what is going on.&#xA;The key challenge in this bug is that it is probably triggered as a result of a commit and an index of the next batch. There is a bunch of work that we do around batch optimizations that likely cause this sort of behavior. By being able to capture the input to the process and play with the batch size, we were able to reduce the amount of work required to generate a reproduction from 50M records to 30,000 and have a lead into what is going on.&#xA;With that, I can now start applying more techniques to narrow down what is going on. But by far the most important aspect as far as I&#x2019;m concerned is the feedback cycle. I can now hit F5 to run the code and encounter the problem in a few seconds.&#xA;&#xA;&#xA;&#xA;It looks like we hit a debug assertion because we keep a reference to an item that was already freed. That is really interesting, and now I can find out which item and then figure out why this is the case. And at each point, I can simply go one step back in the investigation, and reproduce the state, I have to hit F5 and wait a bit. This means that I can be far more liberal in how I figure out this bug.&#xA;This is triggered by a query on the indexed data, and if I follow up the stack, I have:&#xA;&#xA;&#xA;&#xA;This is really interesting, I wonder&#x2026; what happens if I query before I restart the database? With this structure, this is easy to do.&#xA;&#xA;&#xA;&#xA;This is actually a big relief. I had no idea why restarting the database would cause us to expose this bug.&#xA;Another thing to note is that when I ran into the problem, I reproduced this on a query that sorted on a single field. In the test code, I&#x2019;m testing on all fields, so that may be an asset in exposing this faster.&#xA;Right now the problem reproduces on the id field, which is unique. That helps, because it removes a large swath of code that deals with multiple terms for an entry. The current stage is that I can now reproduce this issue without running the queries, and I know exactly where it goes wrong.&#xA;&#xA;&#xA;&#xA;And I can put a breakpoint on the exact location where this entry is created:&#xA;&#xA;&#xA;&#xA;By the way, note that I&#x2019;m modifying the code instead of using a conditional breakpoint. This is because of the performance difference. For a conditional breakpoint, the debugger has to stop execution, evaluate the condition and decide what to do. If this is run a lot, it can have a huge impact on performance. Easier to modify the code. The fact that I can do that and hit F5 and get to the same state allows me to have a lot more freedom in the ergonomics of how I work.&#xA;This allows me to discover that the entry in question was created during the second transaction. But the failure happens during the third, which is really interesting. More to the point, it means that I can now do this:&#xA;&#xA;&#xA;&#xA;With the idea that this will trigger the assert on the exact entry that cause the problem. This is a good idea, and I wish that it worked, but we are actually doing a non-trivial amount of work during the commit process, so now we have a negative feedback and another clue. This is happening in the commit phase of the indexing process. It&#x2019;s not a big loss, I can do the same in the commit process as well. I have done just that and now I know that I have a problem when indexing the term: &#x201C;tweets/1212163952102137856&#x201D;. Which leads to this code:&#xA;&#xA;&#xA;&#xA;And at this point, I can now single step through this and figure out what is going on, I hope.&#xA;When working on complex data structures, one of the things that you need to do is to allow to visualize them. Being able to manually inspect the internal structure of your data structures can save you a lot of debugging. As I mentioned, this isn&#x2019;t my first rodeo. So when I narrowed it down to a specific location, I started looking into exactly what is going on.&#xA;Beforehand, I need to explain a couple of terms (pun intended):&#xA;&#xA;tweets/1212163952102137856 &#x2013; this is the entry that triggers the error.&#xA;tweets/1212163846623727616 &#x2013; this is the term that should be returned for 1679560&#xA;&#xA;Here is what the structure looks like at the time of the insert:&#xA;&#xA;&#xA;&#xA;You can notice that the value here for the last page is the same as the one that we are checking for 1679560.&#xA;To explain what is going on will take us down a pretty complex path that you probably don&#x2019;t care about, but the situation is that we are keeping track of the id in two locations. Making sure to add and remove it in both locations as appropriate. However, at certain points, we may decide to shuffle things around inside the tree, and we didn&#x2019;t sync that up properly with the rest of the system, leading to a dangling reference.&#xA;Now that I know what is going on, I can figure out how to fix it. But the story of this post was mostly about how I figured it out, not the bug itself.&#xA;The key aspect was to get to the point where I can reproduce this easily, so I can repeat it as many times that is needed to slowly inch closer to the solution.</p>
        </article>
        <article id="article-447">
            <a href="https://ayende.com/blog/199425-B/bug-chasing-the-process-is-more-important-than-the-result" target="_blank">
                <h2 class="title mb-6" id="article-447">Bug chasing, the process is more important than the result</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 04, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x2019;m doing a pretty major refactoring inside of RavenDB right now. I was able to finish a bunch of work and submitted things to the CI server for testing. RavenDB has several layers of tests, which we run depending on context.&#xA;During development, we&#x2019;ll usually run the FastTests. About 2,300 tests are being run to validate various behaviors for RavenDB, and on my machine, they take just over 3 minutes to complete. The next tier is the SlowTests, which run for about 3 hours on the CI server and run about 26,000 tests. Beyond that we actually have a few more layers, like tests that are being run only on the nightly builds and stress tests, which can take several minutes each to complete.&#xA;In short, the usual process is that you write the code and write the relevant tests. You also validate that you didn&#x2019;t break anything by running the FastTests locally. Then we let CI pick up the rest of the work. At the last count, we had about 9 dedicated machines as CI agents and given our workload, an actual full test run of a PR may complete the next day.&#xA;I&#x2019;m mentioning all of that to explain that when I reviewed the build log for my PR, I found that there were a bunch of tests that failed. That was reasonable, given the scope of my changes. I sat down to grind through them, fixing them one at a time. Some of them were quite important things that I didn&#x2019;t take into account, after all. For example, one of the tests failed because I didn&#x2019;t account for sorting on a dynamic numeric field. Sorting on a numeric field worked, and a dynamic text field also worked. But dynamic numeric field didn&#x2019;t. It&#x2019;s the sort of thing that I would never think of, but we got the tests to cover us.&#xA;But when I moved to the next test, it didn&#x2019;t fail. I ran it again, and it still didn&#x2019;t fail. I ran it in a loop, and it failed on the 5th iteration. That&#x2026; sucked. Because it meant that I had a race condition in there somewhere. I ran the loop again, and it failed again on the 5th. In fact, in every iteration I tried, it would only fail on the 5th iteration.&#xA;When trying to isolate a test failure like that, I usually run that in a loop, and hope that with enough iterations, I&#x2019;ll get it to reproduce. Having it happen constantly on the 5th iteration was&#x2026; really strange. I tried figuring out what was going on, and I realized that the test was generating 1000 documents using a random. The fact that I&#x2019;m using Random is the reason it is non-deterministic, of course, except that this is the code inside my test base class:&#xA;&#xA;&#xA;&#xA;So this is properly initialized with a seed, so it will be consistent.&#xA;Read the code again, do you see the problem?&#xA;&#xA;&#xA;&#xA;That is a static value. So there are two problems here:&#xA;&#xA;I&#x2019;m getting the bad values on the fifth run in a consistent manner because that is the set of results that reproduce the error.&#xA;This is a shared instance that may be called from multiple tests at once, leading to the wrong result because Random is not thread safe.&#xA;&#xA;Before fixing this issue so it would run properly, I decided to use an ancient debugging technique. It&#x2019;s called printf().&#xA;In this case, I wrote out all the values that were generated by the test and wrote a new test to replay them. That one failed consistently.&#xA;The problem was that it was still too big in scope. I iterated over this approach, trying to end up with a smaller section of the codebase that I could invoke to repeat this issue. That took most of the day. But the end result is a test like this:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [Fact]&#xA;        &#xA;        &#xA;          &#xA;          public void CanAddAndRemoveItems()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              using (var wtx = Env.WriteTransaction())&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var c = wtx.OpenContainer(&quot;test&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var items = Items;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; items.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      switch (items[i].Item1)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          case &#x27;&#x2B;&#x27;:&#xA;        &#xA;        &#xA;          &#xA;                              Container.Allocate(wtx.LowLevelTransaction, c, items[i].Item2, out _);&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                          case &#x27;-&#x27;:&#xA;        &#xA;        &#xA;          &#xA;                              Container.Delete(wtx.LowLevelTransaction, c, items[i].Item2);&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  wtx.Commit();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private (char, int)[] Items = new[]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 64), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16424), (&#x27;&#x2B;&#x27;, 96),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16464), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 64),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16480), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16488), (&#x27;&#x2B;&#x27;, 96), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16528), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16536), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16584), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16560), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16520), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16592), (&#x27;&#x2B;&#x27;, 64),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16544), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16424), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 128),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16480), (&#x27;&#x2B;&#x27;, 96), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;-&#x27;, 16520), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16568), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16536), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16552), (&#x27;&#x2B;&#x27;, 64), (&#x27;-&#x27;, 16576), (&#x27;&#x2B;&#x27;, 64),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16464), (&#x27;&#x2B;&#x27;, 160),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16480), (&#x27;&#x2B;&#x27;, 128), (&#x27;-&#x27;, 16488), (&#x27;&#x2B;&#x27;, 128), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;&#x2B;&#x27;, 32), (&#x27;-&#x27;, 16592), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16528), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16584), (&#x27;&#x2B;&#x27;, 96), (&#x27;-&#x27;, 16416), (&#x27;&#x2B;&#x27;, 160),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16424), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16432), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16440), (&#x27;&#x2B;&#x27;, 160), (&#x27;-&#x27;, 16448), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16456), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16464), (&#x27;&#x2B;&#x27;, 192),&#xA;        &#xA;        &#xA;          &#xA;              (&#x27;-&#x27;, 16472), (&#x27;&#x2B;&#x27;, 192), (&#x27;-&#x27;, 16488), (&#x27;&#x2B;&#x27;, 160), (&#x27;&#x2B;&#x27;, 32),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          SmallTest.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;As you can see, in terms of the amount of code that it invokes, it is pretty minimal. Which is pretty awesome, since that allowed me to figure out what the problem was:&#xA;&#xA;&#xA;&#xA;I&#x2019;ve been developing software professionally for over two decades at this point. I still get caught up with things like that, sigh.</p>
        </article>
        <article id="article-448">
            <a href="https://ayende.com/blog/199393-B/fight-for-every-byte-it-takes-decoding-the-entries" target="_blank">
                <h2 class="title mb-6" id="article-448">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 01, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this series so far, we reduced the storage cost of key/value lookups by a lot. And in the last post we optimized the process of encoding the keys and values significantly. This is great, but the toughest challenge is ahead of us, because as much as encoding efficiency matters, the absolute cost we have is doing lookups. This is the most basic operation, which we do billions of times a second. Any amount of effort we&#x2019;ll spend here will be worth it. That said, let&#x2019;s look at the decoding process we have right now. It was built to be understandable over all else, so it is a good start.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static (long Key, long Val) Decode(Span&lt;byte&gt; buffer, ushort offset)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;              var (keyLen, valLen) = (offset &amp; 0xF) switch&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  1 =&gt; (1, 1),&#xA;        &#xA;        &#xA;          &#xA;                  2 =&gt; (2, 2),&#xA;        &#xA;        &#xA;          &#xA;                  3 =&gt; (3, 3),&#xA;        &#xA;        &#xA;          &#xA;                  4 =&gt; (4, 4),&#xA;        &#xA;        &#xA;          &#xA;                  5 =&gt; (2, 1),&#xA;        &#xA;        &#xA;          &#xA;                  6 =&gt; (2, 3),&#xA;        &#xA;        &#xA;          &#xA;                  7 =&gt; (2, 4),&#xA;        &#xA;        &#xA;          &#xA;                  8 =&gt; (3, 2),&#xA;        &#xA;        &#xA;          &#xA;                  9 =&gt; (3, 4),&#xA;        &#xA;        &#xA;          &#xA;                  10 =&gt; (3, 5),&#xA;        &#xA;        &#xA;          &#xA;                  11 =&gt; (4, 2),&#xA;        &#xA;        &#xA;          &#xA;                  12 =&gt; (4, 3),&#xA;        &#xA;        &#xA;          &#xA;                  13 =&gt; (5, 4),&#xA;        &#xA;        &#xA;          &#xA;                  14 =&gt; (5, 5),&#xA;        &#xA;        &#xA;          &#xA;                  15 =&gt; (4, 5),&#xA;        &#xA;        &#xA;          &#xA;                  _ =&gt; (buffer[offsetInPage] &gt;&gt; 4, buffer[offsetInPage&#x2B;&#x2B;] &amp; 0xF), // note, inc offsetInPage&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              long k = 0;&#xA;        &#xA;        &#xA;          &#xA;              long v = 0;&#xA;        &#xA;        &#xA;          &#xA;              var entry = buffer.Slice(offsetInPage);&#xA;        &#xA;        &#xA;          &#xA;              entry[..keyLen].CopyTo(MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref k)));&#xA;        &#xA;        &#xA;          &#xA;              entry[(keyLen)..(keyLen &#x2B; valLen)].CopyTo(MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref v)));&#xA;        &#xA;        &#xA;          &#xA;              return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What this code does is to accept a buffer and an offset into the buffer. But the offset isn&#x2019;t just a number, it is composed&#xA0; of two values. The first 12 bits contain the offset in the page, but since we use 2-byte alignment for the entry position, we can just assume a zero bit at the start. That is why we compute the actual offset in the page by clearing the first four bits and then shifting left by three bits. That extracts the actual offset to the file, (usually a 13 bits value) using just 12 bits. The first four bits in the offset are the indicator for the key and value lengths. There are 15 known values, which we computed based on probabilities and one value reserved to say: Rare key/val length combination, the actual sizes are stored as the first byte in the entry.&#xA;Note that in the code, we handle that scenario by reading the key and value lengths (stored as two nibbles in the first byte) and incrementing the offset in the page. That means that we skip past the header byte in those rare situations.&#xA;The rest of the code is basically copying the key and value bytes to the relevant variables, taking advantage of partial copy and little-endian encoding.&#xA;The code in question takes 512 bytes and has 23 branches. In terms of performance, we can probably do much better, but the code is clear in what it is doing, at least.&#xA;The first thing I want to try is to replace&#xA0; the switch statement with a lookup table, just like we did before.&#xA0; Here is what the new version looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; DecodeTable =&gt; new byte[16] {&#xA;        &#xA;        &#xA;          &#xA;            (0 /*rare*/), (1 &lt;&lt; 4 | 1), (2 &lt;&lt; 4 | 2), (3 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;            (4 &lt;&lt; 4 | 4), (2 &lt;&lt; 4 | 1), (2 &lt;&lt; 4 | 3), (2 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;            (3 &lt;&lt; 4 | 2), (3 &lt;&lt; 4 | 4), (3 &lt;&lt; 4 | 5), (4 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;            (4 &lt;&lt; 4 | 3), (5 &lt;&lt; 4 | 4), (5 &lt;&lt; 4 | 5), (4 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          private static (long Key, long Val) Decode(Span&lt;byte&gt; buffer, ushort offset) {&#xA;        &#xA;        &#xA;          &#xA;            var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;            var indicator = DecodeTable[offset &amp; 0xF];&#xA;        &#xA;        &#xA;          &#xA;            if (indicator == 0) {&#xA;        &#xA;        &#xA;          &#xA;              indicator = buffer[offsetInPage&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;            }&#xA;        &#xA;        &#xA;          &#xA;            var keyLen = indicator &gt;&gt; 4;&#xA;        &#xA;        &#xA;          &#xA;            var valLen = indicator &amp; 0xF;&#xA;        &#xA;        &#xA;          &#xA;            long k = 0;&#xA;        &#xA;        &#xA;          &#xA;            long v = 0;&#xA;        &#xA;        &#xA;          &#xA;            var entry = buffer.Slice(offsetInPage);&#xA;        &#xA;        &#xA;          &#xA;            entry[..keyLen].CopyTo(MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref k)));&#xA;        &#xA;        &#xA;          &#xA;            entry[(keyLen)..(keyLen &#x2B; valLen)].CopyTo(&#xA;        &#xA;        &#xA;          &#xA;                MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref v)));&#xA;        &#xA;        &#xA;          &#xA;            return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The size of the function dropped by almost half and we have only 7 more branches involved. There are also a couple of calls to the memory copy routines that weren&#x2019;t inlined. In the encoding phase, we reduced branches due to bound checks using raw pointers, and we skipped the memory calls routines by copying a fixed size value at varied offsets to be able to get the data properly&#xA0; aligned. In this case, we can&#x2019;t really do the same. One thing that we have to be aware of is the following situation:&#xA;&#xA;&#xA;&#xA;In other words, we may have an entry that is at the end of the page, if we&#x2019;ll try to read unconditionally 8 bytes, we may read past the end of the buffer. That is not something that we can do. In the Encode() case, we know that the caller gave us a buffer large enough to accommodate the largest possible size, so that isn&#x2019;t an issue. That complicates things, sadly, but we can go the other way around.&#xA;The Decode() function will always be called on an entry, and that is part of the page. The way we place entries means that we are starting at the top and moving down. The structure of the page means that we can never actually place an entry below the first 8 bytes of the page. That is where the header and the offsets array are going, after all. Given that, we can do an unconditional read backward from the entry. As you can see in the image below, we are reading some data that we don&#x2019;t care about, but this is fine, we can fix it later, and without any branches.&#xA;&#xA;&#xA;&#xA;The end result is that we can have the following changes:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private unsafe static (long Key, long Val) Decode(byte* buffer, ushort offset)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;              var indicator = DecodeTable[offset &amp; 0xF];&#xA;        &#xA;        &#xA;          &#xA;              if (indicator == 0)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  indicator = buffer[offsetInPage&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = indicator &gt;&gt; 4;&#xA;        &#xA;        &#xA;          &#xA;              var valLen = indicator &amp; 0xF;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long k = ReadBackward(buffer, offsetInPage, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              long v = ReadBackward(buffer, offsetInPage &#x2B; keyLen, valLen);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              return (k, v);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long ReadBackward(byte* buffer, int offsetInPage, int len)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var shift = 8 - len;&#xA;        &#xA;        &#xA;          &#xA;                  var l = Unsafe.ReadUnaligned&lt;long&gt;(ref buffer[offsetInPage - shift]);&#xA;        &#xA;        &#xA;          &#xA;                  l &gt;&gt;&gt;= shift * 8;&#xA;        &#xA;        &#xA;          &#xA;                  return l;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I changed the code to use a raw pointer, avoiding bound checks that we already reasoned about. Most interesting is the ReadBackward function. This is an inner function, and was properly inlined during JIT compilation, it implements the backward reading of the value. Here is what the assembly looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;              L0041: mov r10d, r9d&#xA;        &#xA;        &#xA;          &#xA;              L0044: neg r10d&#xA;        &#xA;        &#xA;          &#xA;              L0047: add r10d, 8&#xA;        &#xA;        &#xA;          &#xA;              L004b: mov r11d, r8d&#xA;        &#xA;        &#xA;          &#xA;              L004e: sub r11d, r10d&#xA;        &#xA;        &#xA;          &#xA;              L0051: movsxd r11, r11d&#xA;        &#xA;        &#xA;          &#xA;              L0054: mov r11, [r11&#x2B;rdx]&#xA;        &#xA;        &#xA;          &#xA;              L0058: shl r10d, 3&#xA;        &#xA;        &#xA;          &#xA;              L005c: shrx r10, r11, r10&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          ReadBackward.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;With this in place, we are now at 133 bytes and a single branch operation. That is pretty awesome, but we can do better still. Consider the following code (explanations to follow):&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; DecodeTable =&gt; new byte[16] {&#xA;        &#xA;        &#xA;          &#xA;              ( 1 &lt;&lt; 3), // special!&#xA;        &#xA;        &#xA;          &#xA;              ( 1 &lt;&lt; 4 | 1),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 1),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;              ( 2 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 3 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 2),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 3),&#xA;        &#xA;        &#xA;          &#xA;              ( 5 &lt;&lt; 4 | 4),&#xA;        &#xA;        &#xA;          &#xA;              ( 5 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;              ( 4 &lt;&lt; 4 | 5),&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public unsafe static void Decode(byte* buffer, ushort offset, out long key, out long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var offsetInPage = ((offset &amp; 0xFFF0) &gt;&gt; 3);&#xA;        &#xA;        &#xA;          &#xA;              var decoderByte = DecodeTable[offset &amp; 0xF];&#xA;        &#xA;        &#xA;          &#xA;              var offload = decoderByte &amp; 8;&#xA;        &#xA;        &#xA;          &#xA;              byte decodeParts = (byte)((buffer[offsetInPage] &lt;&lt; 8 | decoderByte) &gt;&gt; offload);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              int keyLen = (decodeParts &gt;&gt; 4);&#xA;        &#xA;        &#xA;          &#xA;              int valLen = (decodeParts &amp; 0xF);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              offload &gt;&gt;= 3;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              key = ReadBackward(buffer, offsetInPage &#x2B; offload, keyLen);&#xA;        &#xA;        &#xA;          &#xA;              val = ReadBackward(buffer, offsetInPage &#x2B; offload &#x2B; keyLen, valLen);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              long ReadBackward(byte* buffer, int offsetInPage, int len)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var shift = 8 - len;&#xA;        &#xA;        &#xA;          &#xA;                  var l = Unsafe.ReadUnaligned&lt;long&gt;(ref buffer[offsetInPage - shift]);&#xA;        &#xA;        &#xA;          &#xA;                  l &gt;&gt;&gt;= shift * 8;&#xA;        &#xA;        &#xA;          &#xA;                  return l;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Decode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Note that the first element in the table here is different, it is now setting the 4th bit. This is because we are making use of that. The structure of the bytes in the table are two nibbles, but no other value in the table sets the 4th bit. That means that we can operate on that.&#xA;Indeed, what we are doing is use the decoder byte to figure out what sort of shift we want. We have the byte from the table and the byte from the buffer. And we use the fact that masking this with 8 gives (just for this value) the value of 8. We can then use that to select the appropriate byte. If we have an offloaded byte, then we&#x2019;ll shift the value by 8, getting the byte from the buffer. For any other value, we&#x2019;ll get 0 as the shift index, resulting in us getting the value from the table. That gives us a function with zero branches, and 141 bytes.&#xA;I spent a lot of time thinking about this, so now that we have those two approaches, let&#x27;s benchmark them. The results were surprising:&#xA;&#xA;|                  Method |       Mean |    Error |   StdDev |&#xA;|------------------------ |-----------:|---------:|---------:|&#xA;|  DecodeBranchlessShifts | 2,107.1 ns | 20.69 ns | 18.34 ns |&#xA;|           DecodeBranchy |   936.2 ns |  1.89 ns |  1.68 ns |&#xA;&#xA;It turns out that the slightly smaller code with the branches is able to beat up the branchless code. When looking into what they are doing, I think that I can guess why. Branches aren&#x2019;t a huge problem if they are predictable, and in our case, the whole point of all of this is that the offload process where we need to go to the entry to get the value is meant to be a rare event. In branchless code, on the other hand, you have to do something several times to avoid a branch (like shifting the value from the buffer up and maybe shifting it down, etc).&#xA;You can&#x2019;t really argue with a difference like that. We also tried an AVX version, to see if this would have better performance. It turns out that there is really no way for us to beat the version with the single branch. Everything else was at least twice as slow.&#xA;At this point, I believe that we have a winner.</p>
        </article>
        <article id="article-449">
            <a href="https://www.meziantou.net/reading-windows-application-manifest-of-an-exe-in-dotnet.htm" target="_blank">
                <h2 class="title mb-6" id="article-449">Reading Windows Application Manifest of an exe in .NET</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: May 01, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">The application manifest file is a compatibility feature that allows Windows to run older applications on newer versions of Windows. It contains information such as the supported versions of Windows, if it should run as administrator, if it supports long paths, etc.This file is stored as an embedde</p>
        </article>
        <article id="article-450">
            <a href="https://ayende.com/blog/199364-B/fight-for-every-byte-it-takes-optimizing-the-encoding-process" target="_blank">
                <h2 class="title mb-6" id="article-450">Fight for every byte it takes</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: April 28, 2023
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my previous post, I showed how we use the nibble offload approach to store the size of entries in space that would otherwise be unused. My goal in that post was clarity, so I tried to make sure that the code was as nice to read as possible. In terms of machine code, that isn&#x2019;t really ideal. Let&#x2019;s talk about how we can make it better. Here is the starting version:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          private static (int EntrySize, byte SizeNibble) Encode(Span&lt;byte&gt; buffer, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              byte inlined = (keyLen, valLen) switch&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  (1, 1) =&gt; 1,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 2) =&gt; 2,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 3) =&gt; 3,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 4) =&gt; 4,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 1) =&gt; 5,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 3) =&gt; 6,&#xA;        &#xA;        &#xA;          &#xA;                  (2, 4) =&gt; 7,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 2) =&gt; 8,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 4) =&gt; 9,&#xA;        &#xA;        &#xA;          &#xA;                  (3, 5) =&gt; 10,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 2) =&gt; 11,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 3) =&gt; 12,&#xA;        &#xA;        &#xA;          &#xA;                  (5, 4) =&gt; 13,&#xA;        &#xA;        &#xA;          &#xA;                  (5, 5) =&gt; 14,&#xA;        &#xA;        &#xA;          &#xA;                  (4, 5) =&gt; 15,&#xA;        &#xA;        &#xA;          &#xA;                  // note the trickery here with increment the write offset&#xA;        &#xA;        &#xA;          &#xA;                  _ =&gt; 0&#xA;        &#xA;        &#xA;          &#xA;              };&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = 0;&#xA;        &#xA;        &#xA;          &#xA;              if (inlined == 0) // cannot fit, need to write to entry itself&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  writeOffset = 1;&#xA;        &#xA;        &#xA;          &#xA;                  buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref key))[..keyLen].CopyTo(buffer[writeOffset..]);&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref val))[..valLen].CopyTo(buffer[(keyLen &#x2B; writeOffset)..]);&#xA;        &#xA;        &#xA;          &#xA;              return (writeOffset &#x2B; keyLen &#x2B; valLen, inlined);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This code generates a function whose size exceeds 600 bytes and contains 24(!) branches. I already talked before about why this is a problem, there is a good discussion of the details on branches and their effect on performance here. In short, fewer branches are better. And when looking at machine instructions, the smaller the function, the better we are.&#xA;The first thing to do then is to remove the switch statement and move to a table-based approach. Given that this is a lookup of a small set of values, we can precompute all the options and just do a lookup like that. Here is what the code looks like:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; EncodingTable =&gt; new byte[64]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              1, 0, 0, 0, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              5, 2, 6, 7, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 8, 3, 9, 10, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 11, 12, 4, 15, 0, 0,&#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 13, 14, 0, 0,&#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 0, 0, 0, 0, &#xA;        &#xA;        &#xA;          &#xA;              0, 0, 0, 0, 0, 0, 0, 0, 0&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;           static (int EntrySize, byte SizeNibble) Encode(Span&lt;byte&gt; buffer, long key, long val)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var inlined = EncodingTable[(keyLen-1)*8 &#x2B; valLen-1];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = 0;&#xA;        &#xA;        &#xA;          &#xA;              if (inlined == 0) // cannot fit, need to write to entry itself&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  writeOffset = 1;&#xA;        &#xA;        &#xA;          &#xA;                  buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref key))[..keyLen].CopyTo(buffer[writeOffset..]);&#xA;        &#xA;        &#xA;          &#xA;              MemoryMarshal.AsBytes(new Span&lt;long&gt;(ref val))[..valLen].CopyTo(buffer[(keyLen &#x2B; writeOffset)..]);&#xA;        &#xA;        &#xA;          &#xA;              return (writeOffset &#x2B; keyLen &#x2B; valLen, inlined);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;This is already a win, since we are now at about half the code size (340 bytes) and there are just 7 branches in the function. Let&#x2019;s take a look at the code and its assembly:&#xA;&#xA;&#xA;&#xA;&#xA;Code&#xA;Assembly&#xA;&#xA;&#xA;&#xA;if (inlined == 0)  {&#xA0;&#xA0;&#xA0;&#xA0; writeOffset = 1;&#xA0;&#xA0;&#xA0;&#xA0; buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen); }&#xA;&#xA;&#xA;L0065: test r14d, r14d L0068: jne short L0081 L006a: mov r15d, 1 L0070: mov ecx, ebx L0072: shl ecx, 4 L0075: or ecx, ebp L0077: test edi, edi L0079: je L014fL007f: mov [rsi], cl&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;As you can see, in the assembly, we first test the value, and if it isn&#x2019;t zero, we jump after the if statement. If it is 0, we compute a shift right by 4 and then or the values, then we do another check and finally set the value in the buffer.&#xA;Where does this check came from? There is no if there?&#xA;Well, that is the bound checking that we have with using Span, in fact, most of the checks there are because of Span or because of the safe intrinsics that are used.&#xA;Let&#x2019;s get rid of this. There are actually several interesting iterations in the middle, but let&#x2019;s jump directly to the final result I have. It&#x2019;s under 10 lines of code, and it is quite beautiful.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static ReadOnlySpan&lt;byte&gt; EncodingTable =&gt; new byte[64]&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;             1,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;             5,    2,    6,    7,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,    8,    3,    9,   10,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   11,   12,    4,   15,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   13,   14,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;            16,   16,   16,   16,   16,   16,   16,   16,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          unsafe static void Encode(byte* buffer, long key, long val, out int entrySize, out byte nibble)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var keyLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)key) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var valLen = (int)(8 - Lzcnt.X64.LeadingZeroCount((ulong)val) / 8);&#xA;        &#xA;        &#xA;          &#xA;              var inlined = Unsafe.Add(ref MemoryMarshal.GetReference(EncodingTable), (keyLen - 1) * 8 &#x2B; valLen - 1);&#xA;        &#xA;        &#xA;          &#xA;              nibble = (byte)(inlined &amp; 0xF);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writeOffset = inlined &gt;&gt; 4;&#xA;        &#xA;        &#xA;          &#xA;              buffer[0] = (byte)(keyLen &lt;&lt; 4 | valLen);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.WriteUnaligned(ref buffer[writeOffset], key);&#xA;        &#xA;        &#xA;          &#xA;              Unsafe.WriteUnaligned(ref buffer[writeOffset &#x2B; keyLen], val);&#xA;        &#xA;        &#xA;          &#xA;              entrySize = writeOffset &#x2B; keyLen &#x2B; valLen;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;I&#x2019;m sure that you&#x2019;ll look at this versus the previous iterations and go&#x2026; huh?! I mean, even the reference table is different now.&#xA;Let&#x2019;s analyze what is going on here in detail. The first thing you&#x2019;ll note that changed is the method signature. Before we had multiple result types and now we use out parameters. This turns out to generate slightly less code, so I went with that approach, instead.&#xA;Next, computing the number of bytes we need to copy is the same. Once we have the sizes of the key and the value, we fetch the relevant instruction from the reference table. We do that in a way that skips the bounds checking on the table, since we know that we cannot exceed the length of the array.&#xA;Unlike before, we have new values in the table, where before we had 0 for entries that we didn&#x2019;t care for, now we put 16. That means that we need to clear that when we set the nibble parameter. The reason for this is that we use this to compute the writeOffset. For cases where we have an offboarded nibble, the shift we do there will clear all the values, leaving us with a zero. For the values we cannot offload, we get 16, shifting by 4 gives us 1.&#xA;The reason we do it this way is that we do not use any conditional in this method. We unconditionally set the first byte of the buffer, because it is cheaper to do the work and discard that than check if it needs to be done.&#xA;Finally, we previously used Span.Copy() to move the data. That works, but it turns out that it is not ideal for very small writes, like what we have. At the same time, we write variable size each time, how can we manage that?&#xA;The answer is that we know that the buffer we are passed is large enough to contain the largest size possible. So we don&#x2019;t need to worry about bound checking, etc.&#xA;We take advantage of the fact that the data is laid out in little-endian format and just write the whole 8 bytes of the key to the buffer at the right location. That may be shifted by the computed writeOffset. We then write the value immediately following the computed key length. The idea is that we overwrite the memory we just wrote (because parts of that were found to be not interesting). Using this approach, we were able to drop the code for this function to 114 bytes(!). Even with the encoding table, that is under three cache lines for the whole thing. That is really small.&#xA;There are also no conditionals or branches throughout the process. This is a piece of code that is ready and willing to be inlined anywhere. The amount of effort to understand what is going on here is balanced against how much this function can achieve in its lifetime.&#xA;For reference, here is the assembly of the encoding process:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          Main.Encode(Byte*, Int64, Int64, Int32 ByRef, Byte ByRef)&#xA;        &#xA;        &#xA;          &#xA;              L0000: push rdi&#xA;        &#xA;        &#xA;          &#xA;              L0001: push rsi&#xA;        &#xA;        &#xA;          &#xA;              L0002: xor eax, eax&#xA;        &#xA;        &#xA;          &#xA;              L0004: lzcnt rax, rdx&#xA;        &#xA;        &#xA;          &#xA;              L0009: shr rax, 3&#xA;        &#xA;        &#xA;          &#xA;              L000d: neg eax&#xA;        &#xA;        &#xA;          &#xA;              L000f: add eax, 8&#xA;        &#xA;        &#xA;          &#xA;              L0012: xor r10d, r10d&#xA;        &#xA;        &#xA;          &#xA;              L0015: lzcnt r10, r8&#xA;        &#xA;        &#xA;          &#xA;              L001a: shr r10, 3&#xA;        &#xA;        &#xA;          &#xA;              L001e: neg r10d&#xA;        &#xA;        &#xA;          &#xA;              L0021: add r10d, 8&#xA;        &#xA;        &#xA;          &#xA;              L0025: lea r11d, [r10&#x2B;rax*8-9]&#xA;        &#xA;        &#xA;          &#xA;              L002a: movsxd r11, r11d&#xA;        &#xA;        &#xA;          &#xA;              L002d: mov rsi, 0x216751e0b80&#xA;        &#xA;        &#xA;          &#xA;              L0037: movzx r11d, byte ptr [r11&#x2B;rsi]&#xA;        &#xA;        &#xA;          &#xA;              L003c: mov esi, r11d&#xA;        &#xA;        &#xA;          &#xA;              L003f: and esi, 0xf&#xA;        &#xA;        &#xA;          &#xA;              L0042: mov rdi, [rsp&#x2B;0x38]&#xA;        &#xA;        &#xA;          &#xA;              L0047: mov [rdi], sil&#xA;        &#xA;        &#xA;          &#xA;              L004a: sar r11d, 4&#xA;        &#xA;        &#xA;          &#xA;              L004e: mov esi, eax&#xA;        &#xA;        &#xA;          &#xA;              L0050: shl esi, 4&#xA;        &#xA;        &#xA;          &#xA;              L0053: or esi, r10d&#xA;        &#xA;        &#xA;          &#xA;              L0056: mov [rcx], sil&#xA;        &#xA;        &#xA;          &#xA;              L0059: movsxd rsi, r11d&#xA;        &#xA;        &#xA;          &#xA;              L005c: mov [rcx&#x2B;rsi], rdx&#xA;        &#xA;        &#xA;          &#xA;              L0060: add eax, r11d&#xA;        &#xA;        &#xA;          &#xA;              L0063: movsxd rdx, eax&#xA;        &#xA;        &#xA;          &#xA;              L0066: mov [rdx&#x2B;rcx], r8&#xA;        &#xA;        &#xA;          &#xA;              L006a: add eax, r10d&#xA;        &#xA;        &#xA;          &#xA;              L006d: mov [r9], eax&#xA;        &#xA;        &#xA;          &#xA;              L0070: pop rsi&#xA;        &#xA;        &#xA;          &#xA;              L0071: pop rdi&#xA;        &#xA;        &#xA;          &#xA;              L0072: ret&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Encode.asm&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;The EncodingTable deserves a better explanation. I generated it using the following code:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          for (int i = 0; i &lt; 8; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              for (int j = 0; j &lt; 8; j&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  byte inlined = (i &#x2B; 1, j &#x2B; 1) switch&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      (1, 1) =&gt; 1,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 2) =&gt; 2,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 3) =&gt; 3,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 4) =&gt; 4,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 1) =&gt; 5,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 3) =&gt; 6,&#xA;        &#xA;        &#xA;          &#xA;                      (2, 4) =&gt; 7,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 2) =&gt; 8,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 4) =&gt; 9,&#xA;        &#xA;        &#xA;          &#xA;                      (3, 5) =&gt; 10,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 2) =&gt; 11,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 3) =&gt; 12,&#xA;        &#xA;        &#xA;          &#xA;                      (5, 4) =&gt; 13,&#xA;        &#xA;        &#xA;          &#xA;                      (5, 5) =&gt; 14,&#xA;        &#xA;        &#xA;          &#xA;                      (4, 5) =&gt; 15,&#xA;        &#xA;        &#xA;          &#xA;                      // note the trickery here with increment the write offset&#xA;        &#xA;        &#xA;          &#xA;                      _ =&gt; 16&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  Console.Write($&quot;{inlined,4}, &quot;);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              Console.WriteLine();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          EncodingGeneration.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;In other words, I basically wrote out all the options and generated the appropriate value for each one of the options. I&#x2019;m using the value of 16 here to be able to get to the right result using some bit shifts without any conditionals. So instead of doing many conditions, I replaced this with a (small) table lookup.&#xA;In my next post, I&#x2019;m going to try to handle the same process for decoding.</p>
        </article>
        <div class="button flex justify-between">
            <a href="44.html"><span class="back arrow"></span></a>

            <a href="46.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>