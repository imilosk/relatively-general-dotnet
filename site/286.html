
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 286 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-2851">
            <a href="https://ayende.com/blog/176257/10x-speedup-utilizing-nagle-algorithm-in-business-application" target="_blank">
                <h2 class="title mb-6" id="article-2851">10x speedup utilizing Nagle Algorithm in business application</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 02, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Nagle algorithm is a pretty annoying thing. Basically, it means that when we write to the network, the TCP stack will wait a bit to see if we have more stuff to send to that destination before actually emitting the packet. Most people run into this when they wonder why the minimum time for a remote operation is 200ms, even on the local network. Then you figure out how to disable Nagle Algorithm, and you are happy again. Nagle algorithm was designed for remote terminals, where the speed difference between a human typing and the machine sending packet was big enough that each single letter you typed would be sent as a separate packet. That led to a really high overhead, 40 bytes overhead to send just a single byte to the server, and the number of packets that were sent may be high enough to cause the pipe to choke. So you buffer it, the basic algorithm goes like this, if we don&#x2019;t have enough data to send a full packet, and if 200 ms didn&#x2019;t pass since the first buffered data, wait up to 200 ms for more data.&#xA0; In this manner, if you type fast enough, you will send more than a single character to the server, dramatically reducing the cost of talking with the server, and speeding up everything significantly.  So this is Nagle Algorithm, it is a pretty low level TCP detail, and often overlooked by people. If you don&#x2019;t study networks, you&#x2019;ll typically only find out about it when you have a perf problem that you can&#x2019;t figure out. So how is this relating to business applications? Imagine that you work on a system that does snail mail sending. A user will call the API and then a few days later a physical letter will show up at your door. Nothing really special about that, right? Except that we charge users based on the plan they choose. For simplicity&#x2019;s sake, we&#x2019;ll say that we have two plans:  Pay as you go &#x2013; can send as many letters as they want, and we charge a certain amount for each.  Budgetted plan &#x2013; can send up to certain number of letters per month. In either case, it is pretty important to us to record that the mail was sent, and if the user is on a budget plan (or has spending alerts on his account), we need to respond to it in certain ways.  Overall, there is nothing really surprising here, and the code to handle this is pretty simple, right? &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public async Task SendSnailMail(long userId, Address destination, PdfDocument letter)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var result = await RecordMailAsync(userId, destination.Country, letter.NumberOfPages);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if(result.IsRejected)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return EmailRejected(stats);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;// do stuff&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private async Task&lt;EmailBillingStatus&gt; RecordMailAsync(long userId, string country, int numberOfPages)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;var result = await billingServiceClient.GetAsync(&quot;/record/mail?userId=&quot;&#x2B;userId&quot;&amp;country=&quot;&#x2B;country&#x2B;&quot;&amp;pages=&quot;&#x2B;numberOfPages);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;retuslt.EnsureSuccessStatusCode();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return JsonConverter.Deserialize&lt;EmailBillingStatus&gt;(await result.Content.ReadAsSttringAsync();&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          send-mail.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; The problem is that under load, we&#x2019;re going to have query a few requests going on to the billing service, and that is likely to be a bottleneck for us. Note that this is the case because while processing a single RecordMail request is pretty fast, the problem is that we are actually going to have to wait for both the actual processing and the back and forth between the machines. If the cost of processing a RecordMail request is 1 ms, and the cost of going over the network is 0.5 ms, that adds up quickly. Now, let us see how we can do it better. We&#x2019;ll start with moving from making the call immediately to placing the details in a queue. &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public async Task SendSnailMail(long userId, Address destination, PdfDocument letter)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var result = await RecordMailAsync(userId, destination.Country, letter.NumberOfPages);&#xA;        &#xA;        &#xA;          &#xA;              if(result.IsRejected)&#xA;        &#xA;        &#xA;          &#xA;                  return EmailRejected(stats);&#xA;        &#xA;        &#xA;          &#xA;              // do stuff&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private class RecordMailArgs&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public long UserId;&#xA;        &#xA;        &#xA;          &#xA;              public string Country;&#xA;        &#xA;        &#xA;          &#xA;              public int NumberOfPages;&#xA;        &#xA;        &#xA;          &#xA;              public TaskCompletionSource&lt;RecordMailArgs&gt; TaskCompletionSource = new TaskCompletionSource&lt;RecordMailArgs&gt;();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private BlockingCollection&lt;RecordMailArgs&gt; queue = new BlockingCollection&lt;RecordMailArgs&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private Task&lt;EmailBillingStatus&gt; RecordMailAsync(long userId, string country, int numberOfPages)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var args = new RecordMailArgs{UserId = userId, Country = country, NumberOfPages = numberOfPages};&#xA;        &#xA;        &#xA;          &#xA;              queue.Add(args);&#xA;        &#xA;        &#xA;          &#xA;              return args.TaskCompletionSource.Task;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          send-mail-batched.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; You can see that we use a task completion source to wait for the result of the call. Next, we need to actually handle this, this is done in the following methods: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private void WriteQueueToServer(CancellationToken cancellationToken)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;             while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  cancellationToken.ThrowIfCancellationRequested();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  var batch = new List&lt;RecordMailArgs&gt;();&#xA;        &#xA;        &#xA;          &#xA;                  object val;&#xA;        &#xA;        &#xA;          &#xA;                  while (queue.TryTake(out document, millisecondsTimeout: 200))&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      cancellationToken.ThrowIfCancellationRequested();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      batch.Add(val);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      if (batch.Count &gt;= 256)&#xA;        &#xA;        &#xA;          &#xA;                          break;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if((batch.Count == 0) continue;&#xA;        &#xA;        &#xA;          &#xA;                  FlushBatch(batch);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          private void FlushBatch(List&lt;RecordMailArgs&gt; batch)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var json = JsonConvert.Serialize(batch);&#xA;        &#xA;        &#xA;          &#xA;              billingServiceClient.PostAsync(&quot;/record/mail-bulk&quot;, new StringContent(json))&#xA;        &#xA;        &#xA;          &#xA;                  .ContinueWith(async task =&gt;&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if(task.IsCancelled || task.IsFaulted)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          foreach(var item in batch)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              item.TaskCompletionSource.TrySetException(task.Exception);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if(task.Result.IsSuccessfulStatusCode == false)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          foreach(var item in batch)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              item.TaskCompletionSource.TrySetException(new InvalidOperationException(&quot;Status code from record mail &quot; &#x2B; task.Result.StatusCode));&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          return;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      var results = JsonConvert.Deserialize&lt;EmailBillingStatus[]&gt;(await task.Result.Content.ReadAsStringAsync());&#xA;        &#xA;        &#xA;          &#xA;                      for(var i = 0; i &lt; result.Length; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          batch[i].TaskCompletionSource.TrySetResult(results[i]);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;        &#xA;        &#xA;          &#xA;                  });&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          handle-queue-sends.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; What this ends up doing is to reduce the network costs. Instead of going to the server once for every request, we&#x2019;ll go to the server once per 200 ms or every 256 requests. That dramatically reduce network traffic. And the cost of actually sending 256 requests instead of just one isn&#x2019;t really that different. Note that this gives us a higher latency per request, since we may have to wait longer for the request to go out to the server, but it also gives me much better throughput, because I can process more requests in a shorter amount of time. A change like that can push your performance up by an order of magnitude or more. It also gives you economy of scale benefits on the other side. Instead of having to do a fixed amount of work around processing each request, we can now do it over a whole bunch of them. For example, if I need to load the customer entity, instead of doing it once per mail, I can do that once per batch, and it is likely that this customer will be in the batch more than once, reducing the amount of work I have to do.</p>
        </article>
        <article id="article-2852">
            <a href="https://ayende.com/blog/176228/the-performance-regression-in-the-optimization-part-ii" target="_blank">
                <h2 class="title mb-6" id="article-2852">The performance regression in the optimization</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 01, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In my previous post I showed a performance conundrum. A code that has been optimized to reduced heavy allocation usage that became over twice as slow. In particular, we had a problem here, the new code it 3.4 times slower than the new one, but how?  Now, the real scenario we had involved concurrent access, so it was much harder to figure out, but I cheated a bit when producing this image, I used sampling profiling, instead of tracing one. The major difference between the two is that tracing profiler will also give you the number of calls. This is called out as something that you would typically do because you want to analyze algorithmic complexity, but I find it incredibly useful to figure out what my code is actually doing.  And indeed, looking at the same code using tracing profiler gives us the following two calls:   And when looking at the diffs between those two, we have:  So for some reason we are making 54 million more calls to the Equals method in the optimized version, but why? Both of those are using the exact same dictionary, using the exact same key type and the same keys, even. In the real scenario we were facing, that wasn&#x2019;t the case, so that made it hard to analyze the issue. We started looking into whatever we were doing some sort of cache poisoning by having the buffer holder as the dictionary value, instead of the array directly, but that didn&#x2019;t pan out. We kept circling around the number of Equals calls. Note that the number of calls to TryGetValue is the same, as well as the number of calls to GetHashCode. So what is the diff? The diff, quite simple, is not here at all.  The problem is in the RemoveBefore method. In the old version, if we removed all the entries, we&#x2019;ll remove it completely from the dictionary. In the new version, we&#x2019;ll reset the buffer so it can be used again next time. The problem with that approach is that it means that the dictionary is pretty big, much bigger than it would be in the case of the old version of the code. And that means that we&#x2019;ll need to find the value (which is empty), then check its content. On the old version, we&#x2019;ll just do a GetHashCode, then find that the table entry is over, and exit. Indeed, all we had to do was change RemoveBefore to look like this: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;           public void RemoveBefore(long txId)&#xA;        &#xA;        &#xA;          &#xA;           {&#xA;        &#xA;        &#xA;          &#xA;               foreach (var kvp in _mapping)&#xA;        &#xA;        &#xA;          &#xA;               {&#xA;        &#xA;        &#xA;          &#xA;                   var bufferHolder = kvp.Value;&#xA;        &#xA;        &#xA;          &#xA;                   while (bufferHolder.Start &lt; bufferHolder.Buffer.Length)&#xA;        &#xA;        &#xA;          &#xA;                   {&#xA;        &#xA;        &#xA;          &#xA;                       var page = bufferHolder.Buffer[bufferHolder.Start];&#xA;        &#xA;        &#xA;          &#xA;                       if (page == null || page.TransactioId &gt; txId)&#xA;        &#xA;        &#xA;          &#xA;                       {&#xA;        &#xA;        &#xA;          &#xA;                           break;&#xA;        &#xA;        &#xA;          &#xA;                       }&#xA;        &#xA;        &#xA;          &#xA;                       bufferHolder.Start&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                   }&#xA;        &#xA;        &#xA;          &#xA;                   if (bufferHolder.Start == bufferHolder.End)&#xA;        &#xA;        &#xA;          &#xA;                           {&#xA;        &#xA;        &#xA;          &#xA;                       BufferHolder value;&#xA;        &#xA;        &#xA;          &#xA;                       _mapping.TryRemove(kvp.Key, out value);&#xA;        &#xA;        &#xA;          &#xA;                   }&#xA;        &#xA;        &#xA;          &#xA;               }&#xA;        &#xA;        &#xA;          &#xA;           }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          BetterRemoveBefore.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; And that gives us:  14.0 seconds &amp; 1.1 GB of memory for old version 12.8 seconds &amp; 0.4 GB of memory for new version Which is pretty good result overall. It gets better when you break it apart to its component parts.  This is actually surprising, since we didn&#x2019;t really set out to optimize this call very much, and it is pretty much unchanged in both versions. I think that this is likely because we keep the buffers around longer, so they are more likely to be in the cache.  This shows more than double the speed we previous had, which is pretty awesome, since this code is actually called per transactions, so anything that reduces that cost is golden.  This happens during a flush, and reducing its speed is important to reducing the time we hold the write lock, so this is pretty sweet.</p>
        </article>
        <article id="article-2853">
            <a href="https://ardalis.com/usestatuscodepages-middleware-problem-resolved/" target="_blank">
                <h2 class="title mb-6" id="article-2853">UseStatusCodePages Middleware Problem Resolved</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 01, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">If you&#x2019;re trying to get the ASP.NET Core Status Code Pages middleware to work, but it just is ignored no matter what, one thing to check is&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-2854">
            <a href="https://ayende.com/blog/176227/the-performance-regression-in-the-optimization-part-i" target="_blank">
                <h2 class="title mb-6" id="article-2854">The performance regression in the optimization</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 30, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">PageTable is a pretty critical piece of Voron. It is the component responsible for remapping modified pages in transactions and is the reason why we support MVCC and can avoid taking locks for the most part. It has been an incredibly stable part of our software, rarely changing and pretty much the same as it was when it was initially written in 2013. It has been the subject for multiple performance reviews in that time, but acceptable levels of performance from our code in 2013 is no longer acceptable today. PageTable came up recently in one of our performance reviews as a problematic component. It was responsible for too much CPU and far too many allocations. Here is a drastically simplified implementation, which retain the salient points: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public class PageTable_Old&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public struct TransactionPage&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  public long TransactioId;&#xA;        &#xA;        &#xA;          &#xA;                  public long PagePosition;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public ConcurrentDictionary&lt;long, TransactionPage[]&gt; _mapping = new ConcurrentDictionary&lt;long, TransactionPage[]&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void SetItems(long txId, Dictionary&lt;long, long&gt; mappingForTx)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  foreach (var page in mappingForTx)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var copy = page;&#xA;        &#xA;        &#xA;          &#xA;                      _mapping.AddOrUpdate(page.Key,&#xA;        &#xA;        &#xA;          &#xA;                          l =&gt; new[] { new TransactionPage { PagePosition = copy.Value, TransactioId = txId } },&#xA;        &#xA;        &#xA;          &#xA;                          (l, pages) =&gt;&#xA;        &#xA;        &#xA;          &#xA;                              new List&lt;TransactionPage&gt;(pages)&#xA;        &#xA;        &#xA;          &#xA;                              {&#xA;        &#xA;        &#xA;          &#xA;                          new TransactionPage {PagePosition = copy.Value, TransactioId = txId}&#xA;        &#xA;        &#xA;          &#xA;                              }.ToArray());&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void RemoveBefore(long txId)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  foreach (var pages in _mapping)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (pages.Value[0].TransactioId &gt; txId)&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var newVal = pages.Value.Where(x =&gt; x.TransactioId &gt; txId).ToArray();&#xA;        &#xA;        &#xA;          &#xA;                      if (newVal.Length == 0)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          _mapping.TryRemove(pages.Key, out newVal);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      else&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          _mapping.AddOrUpdate(pages.Key, newVal, (l, oldVal) =&gt; newVal);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public bool TryGetValue(long page, long tx, out long position)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  TransactionPage[] value;&#xA;        &#xA;        &#xA;          &#xA;                  if (_mapping.TryGetValue(page, out value) == false)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      position = -1;&#xA;        &#xA;        &#xA;          &#xA;                      return false;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = value.Length - 1; i &gt;= 0; i--)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (value[i].TransactioId &gt; tx)&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      position = value[i].PagePosition;&#xA;        &#xA;        &#xA;          &#xA;                      return true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  position = -1;&#xA;        &#xA;        &#xA;          &#xA;                  return false;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PageTable-1.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; Here is the sample workout for this class, which just simulates ten thousand transactions. This little scenario takes 15.3 seconds and allocates a total of 1.1GB of memory! That is a lot of allocations, and must have tremendous amount of time spent in GC. The most problematic issue here is the SetItems methods, which will allocate two different delegates for each modified page in the transaction. Then we have the total abandon in which we&#x2019;ll allocate additional memory in there. As you can imagine, we weren&#x2019;t very happy about this, so we set out to fix this issue. We can take advantage off the fact that SetItems and RemoveBefore are only called under lock, while TryGetValue is called concurrently with everything else. So I wrote the following code: &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          public class PageTable_New&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public class TransactionPage&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  public long TransactioId;&#xA;        &#xA;        &#xA;          &#xA;                  public long PagePosition;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private readonly ConcurrentDictionary&lt;long, BufferHolder&gt; _mapping = new ConcurrentDictionary&lt;long, BufferHolder&gt;();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private class BufferHolder&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  public TransactionPage[] Buffer;&#xA;        &#xA;        &#xA;          &#xA;                  public int Start;&#xA;        &#xA;        &#xA;          &#xA;                  public int End;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void SetItems(long txId, Dictionary&lt;long, long&gt; mappingForTx)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  foreach (var page in mappingForTx)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var bufferHolder = _mapping.GetOrAdd(page.Key, _ =&gt; new BufferHolder&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          Buffer = new TransactionPage[2]&#xA;        &#xA;        &#xA;          &#xA;                      });&#xA;        &#xA;        &#xA;          &#xA;                      if (bufferHolder.Buffer.Length == bufferHolder.End)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          var newBufferHolder = new BufferHolder&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              Buffer = new TransactionPage[bufferHolder.Buffer.Length * 2]&#xA;        &#xA;        &#xA;          &#xA;                          };&#xA;        &#xA;        &#xA;          &#xA;                          Array.Copy(bufferHolder.Buffer, bufferHolder.Start, newBufferHolder.Buffer, 0,&#xA;        &#xA;        &#xA;          &#xA;                              bufferHolder.End - bufferHolder.Start);&#xA;        &#xA;        &#xA;          &#xA;                          newBufferHolder.End = bufferHolder.End - bufferHolder.Start;&#xA;        &#xA;        &#xA;          &#xA;                          _mapping.TryUpdate(page.Key, newBufferHolder, bufferHolder); // no one else is writing here&#xA;        &#xA;        &#xA;          &#xA;                          bufferHolder = newBufferHolder;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      bufferHolder.Buffer[bufferHolder.End&#x2B;&#x2B;] = new TransactionPage&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          PagePosition = page.Value,&#xA;        &#xA;        &#xA;          &#xA;                          TransactioId = txId&#xA;        &#xA;        &#xA;          &#xA;                      };&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void RemoveBefore(long txId)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  foreach (var kvp in _mapping)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var bufferHolder = kvp.Value;&#xA;        &#xA;        &#xA;          &#xA;                      while (bufferHolder.Start &lt; bufferHolder.Buffer.Length)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          var page = bufferHolder.Buffer[bufferHolder.Start];&#xA;        &#xA;        &#xA;          &#xA;                          if (page == null || page.TransactioId &gt; txId)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          bufferHolder.Start&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (bufferHolder.Start == bufferHolder.Buffer.Length)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          bufferHolder.Start = bufferHolder.End = 0;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public bool TryGetValue(long page, long tx, out long position)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  BufferHolder value;&#xA;        &#xA;        &#xA;          &#xA;                  if (_mapping.TryGetValue(page, out value) == false)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      position = -1;&#xA;        &#xA;        &#xA;          &#xA;                      return false;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = value.End - 1; i &gt;= value.Start; i--)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var transactionPage = value.Buffer[i];&#xA;        &#xA;        &#xA;          &#xA;                      if (transactionPage == null)&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      if (transactionPage.TransactioId &gt; tx)&#xA;        &#xA;        &#xA;          &#xA;                          continue;&#xA;        &#xA;        &#xA;          &#xA;                      position = transactionPage.PagePosition;&#xA;        &#xA;        &#xA;          &#xA;                      return true;&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  position = -1;&#xA;        &#xA;        &#xA;          &#xA;                  return false;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          PageTable-2.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; This relies on allowing stale reads from concurrent readers, which we don&#x2019;t care about since they wouldn&#x2019;t be able to make use of the data anyway, and it was able to reduce the allocations to just 320 MB, but the runtime actually went up to 32 seconds. That is quite annoying, as you can imagine, and much cursing enthused as a result. I then pulled my trusty profiler ask it kindly to figure out what piece of code needs to be hit with a rolling pin and have a stern talk to about what is expected from code after it has been laboriously and carefully optimized. It is expected to sit nicely and be fast, or by Git I&#x2019;ll revert you. What the hell?! Here are the original implementation costs, and you can clearly see how much time we are spending on garbage collection.  And here is the optimized version, which is actually slower, and actually used more memory?!   There are a bunch of interesting things going on here. We can see that we are indeed using spending a little less time in GC, and that both RemoveBefore and SetItems methods are much cheaper, but the cost of TryGetValue is so much higher, in fact, if we compare the two, we have:  So we are 3.4 times higher, and somehow, the cost of calling the concurrent dictionary TryGetValue has risen by 88%. But the implementation is pretty much the same, and there isn&#x2019;t anything else that looks like it can cause that much of a performance gap. I&#x2019;ll leave this riddle for now, because it drove me crazy for two whole days and give you the details on what is going on in the next post.</p>
        </article>
        <article id="article-2855">
            <a href="https://ayende.com/blog/176225/reviewing-pull-requests-with-large-number-of-commits" target="_blank">
                <h2 class="title mb-6" id="article-2855">Reviewing pull requests with large number of commits</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 29, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I have to go over a fairly compress pull request, adding a pretty big feature. The feature, if you care, is compressing data in the leaf pages of a B&#x2B;Tree for use in Map/Reduce entries storage. The current and non final results are reducing storage costs from about 650MB to 32MB, so we are pretty happy with it, but this isn&#x2019;t the topic of this post. At this stage, the feature is not complete, but it is ready for initial review, so we created a temporary PR to review it, here is a partial view:  There are over 30 commits over a period of three weeks there, and they represent a lot of experimentation as we go along. This is fine &amp; proper as far as we are concerned, since we this represent quite a bit of work, and we certainly want to be able to track it. But since this isn&#x2019;t completed, the commit history is long, which means that reviewing it one commit at a time is not trivial. In particular, there are a lot of back and forth changes in the same place, and I don&#x2019;t want to review code that has been changed. Luckily, git make it easy to change that view.  I pull the changes to my local branch, then reset the log to the last commit before the merge, then I just squashed all those commit into a single one. You can check it out here.  The final result is:   Which is much nicer way to go about reviewing this, since I can look at all the changes in one shot, and more to the point, I can make comments on the changes using our normal workflow.</p>
        </article>
        <article id="article-2856">
            <a href="https://andrewlock.net/url-culture-provider-using-middleware-as-mvc-filter-in-asp-net-core-1-1-0/" target="_blank">
                <h2 class="title mb-6" id="article-2856">Url culture provider using middleware as filters in ASP.NET Core 1.1.0</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 29, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Adding a URL culture provider using middleware as filters - Part 2</p>
        </article>
        <article id="article-2857">
            <a href="https://enterprisecraftsmanship.com/posts/ocp-vs-yagni/" target="_blank">
                <h2 class="title mb-6" id="article-2857">OCP vs YAGNI</h2>
            </a>
            <p class="mb-2">by Vladimir Khorikov</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 28, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post, I want to cover the topic of OCP vs YAGNI - contradictions between the Open/Closed Principle and the You aren&#x2019;t gonna need it one.&#xA;OCP Let&#x2019;s start with a refresher for what OCP is. The Open/Closed principle states that:&#xA; Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.&#xA; It was first introduced by Bertrand Meyer in his canonical Object-Oriented Software Construction book.</p>
        </article>
        <article id="article-2858">
            <a href="https://ayende.com/blog/176193/talk-system-architecture-with-nosql-and-ravendb-docdb" target="_blank">
                <h2 class="title mb-6" id="article-2858">Talk</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 28, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">My Talk at InfoQ Brazil has been published. You can watch it here.</p>
        </article>
        <article id="article-2859">
            <a href="https://ayende.com/blog/176161/digging-into-the-coreclr-some-bashing-on-the-cost-of-hashing" target="_blank">
                <h2 class="title mb-6" id="article-2859">Digging into the CoreCLR</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 25, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Note: This post was written by Federico.  Recently at CoreFX there has been a proposal to deal with the typical case of everyone writing their own hash combining logic. I really like the framework to push that kind of functionality because hashing is one of those things that unless you really know what you are doing, it can backfire pretty bad (and even if you know, you can step over the cliff too).&#xA0; But this post is not about the issue itself, but it showcases a few little details that happen at JIT land (and that we usually abuse, of course J). This is the issue: https://github.com/dotnet/corefx/issues/8034#issuecomment-260733285  Let me illustrate with some examples.ValueTuple is a new type that is being introduced that is necessary for some of the new tuples functionality in C# 7. Because hashing is important, of course they implemented the ability to combine hashes. Now, let&#x2019;s suppose that we take the actual code hashing code that is being used for ValueTuple and use constants to call it.&#xA0; &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          internal static class HashHelpers&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public static int Combine(int h1, int h2)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // The jit optimizes this to use the ROL instruction on x86&#xA;        &#xA;        &#xA;          &#xA;                  // Related GitHub pull request: dotnet/coreclr#1830&#xA;        &#xA;        &#xA;          &#xA;                  uint shift5 = ((uint)h1 &lt;&lt; 5) | ((uint)h1 &gt;&gt; 27);&#xA;        &#xA;        &#xA;          &#xA;                  return ((int)shift5 &#x2B; h1) ^ h2;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.NoInlining)]&#xA;        &#xA;        &#xA;          &#xA;          public static int TryStaticCall()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return HashHelpers.Combine(10202, 2003);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.NoInlining)]&#xA;        &#xA;        &#xA;          &#xA;          public static int TryValueTuple()&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return ValueTuple.Create(10202, 2003).GetHashCode();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          hashing.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; Now under an optimizing compiler chances are that there shouldn&#x27;t be any difference, but in reality there is.  This is the actual machine code for ValueTuple:    So now what can be seen here? First we are creating an struct in the stack, then we are calling the actual hash code.  Now compare it with the use of HashHelper.Combine which for all purposes it could be the actual implementation of Hash.Combine    I know!!! How cool is that???But let&#x2019;s not stop there... let&#x2019;s use actual parameters:  &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.NoInlining)]&#xA;        &#xA;        &#xA;          &#xA;          public static int TryStaticCall(int h1, int h2)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return HashHelpers.Combine(h1, h2);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.NoInlining)]&#xA;        &#xA;        &#xA;          &#xA;          public static int TryValueTuple(int h1, int h2)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return ValueTuple.Create(h1, h2).GetHashCode();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          static unsafe void Main(string[] args)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var g = new Random();&#xA;        &#xA;        &#xA;          &#xA;              int h1 = g.Next();&#xA;        &#xA;        &#xA;          &#xA;              int h2 = g.Next();&#xA;        &#xA;        &#xA;          &#xA;              Console.WriteLine(TryStaticCall(h1, h2));&#xA;        &#xA;        &#xA;          &#xA;              Console.WriteLine(TryValueTuple(h1, h2));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          hasing-with-params.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; We use random values here to force the JIT to treat them as parameters and not being able to eliminate the code and convert it yet again into a constant.    The good thing, this is extremely stable. But let&#x2019;s compare it with the alternative:   The question that you may be asking yourselves is: Does that scale?. So, let&#x2019;s go overboard...  &#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          internal static class HashHelpers&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public static int Combine(int h1, int h2)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  // The jit optimizes this to use the ROL instruction on x86&#xA;        &#xA;        &#xA;          &#xA;                  // Related GitHub pull request: dotnet/coreclr#1830&#xA;        &#xA;        &#xA;          &#xA;                  uint shift5 = ((uint)h1 &lt;&lt; 5) | ((uint)h1 &gt;&gt; 27);&#xA;        &#xA;        &#xA;          &#xA;                  return ((int)shift5 &#x2B; h1) ^ h2;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;              public static int Combine(int h1, int h2, int h3, int h4)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  return Combine(Combine(h1, h2), Combine(h3, h4));&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          [MethodImpl(MethodImplOptions.NoInlining)]&#xA;        &#xA;        &#xA;          &#xA;          public static int TryStaticCall(int h1, int h2, int h3, int h4)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              return HashHelpers.Combine(h1, h2, h3, h4);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          plenty-of-hashes.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA; And the result is pretty illustrative:  The takeaway of the analysis is simple: even if the holding type is a struct, it doesn&#x27;t mean it is free :)</p>
        </article>
        <article id="article-2860">
            <a href="https://ayende.com/blog/176129/making-code-faster-micro-optimizations-and-parallel-work" target="_blank">
                <h2 class="title mb-6" id="article-2860">Making code faster</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: November 24, 2016
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I really wanted to leave this series of posts alone. Getting 135 times faster should be fast enough for everyone, just like 640KB was. Unfortunately, performance optimization is addictive. Last time, we left it at 283 ms per run. But we still left some performance on the table. I mean, we had inefficient code like this:  Just look at it. Analysis showed that it is always called with 2, 4 or 8 only. So we naturally simplified things:  Forcing the inlining of those methods also helped, and pushed us further toward 240 ms. Another cost that we had was date diff calculation, we optimized for the case where the day is the same, but in our dataset, we have about 2 million records that cross the day line. So we further optimized for the scenario where the year &amp; month are the same, and just the day is different. That pushed us further toward 220 ms. At this point the profiler was basically laughing at us, and we had no real avenues to move forward, so I made the code use 4 threads, each processing the file at different locations. That gave me: 73 ms and allocated 5,640 kb with peak working set of 300,580 kb  527 times faster than the original version. Allocate 1350 times less memory. 1/3 of the working set. Able to process 3.7 GB / sec. Note that at this point, we are relying on this being in the file system cache, because if I was reading it from disk, I wouldn&#x2019;t be able to do more than 100 &#x2013; 200 MB / sec. Here is the full code, write code like this at your peril.</p>
        </article>
        <div class="button flex justify-between">
            <a href="285.html"><span class="back arrow"></span></a>

            <a href="287.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>