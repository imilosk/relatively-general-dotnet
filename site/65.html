
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 65 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-641">
            <a href="https://www.stevejgordon.co.uk/creating-inspecting-decompiling-the-worlds-smallest-csharp-program" target="_blank">
                <h2 class="title mb-6" id="article-641">Creating, Inspecting and Decompiling the World&#x2019;s (Nearly) Smallest C# Program</h2>
            </a>
            <p class="mb-2">by Steve Gordon</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 15, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post, I thought it might be fun to create the world&#x2019;s (nearly) shortest C# program and then deep dive into some of the fine details of what happens behind the scenes. This post is not intended to solve a real-world problem but I hope it&#x2019;s well worth your time spent reading it. By [&#x2026;]</p>
        </article>
        <article id="article-642">
            <a href="https://ayende.com/blog/197506-C/the-value-of-self-contained-diagnostics" target="_blank">
                <h2 class="title mb-6" id="article-642">The value of self contained diagnostics</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 14, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x2019;m inordinately fond of the Fallacies of Distributed Computing, these are a set of common (false) assumptions that people make when building distributed systems, to their sorrow.&#xA;Today I want to talk about one of those fallacies:&#xA;&#xA;There is one administrator.&#xA;&#xA;I like to add the term competent in there as well.&#xA;A pretty significant amount of time in the development of RavenDB was dedicated to addressing that issue. For example, RavenDB has a lot of code and behavior around externalizing metrics. Both its own and the underlying system.&#xA;That is a duplication of effort, surely. Let&#x2019;s consider the simplest stuff, such as CPU, memory and I/O resource utilization. RavenDB makes sure to track those values, plot them in the user interface and expose that to external monitoring systems.&#xA;All of those have better metrics sources. You can ask the OS directly about those details, and it will likely give you far better answers (with more details) than RavenDB can.&#xA;There have been numerous times where detailed monitoring from the systems that RavenDB runs on was&#xA0;the thing that allowed us to figure out what is going on. Having the underlying hardware tell us in detail about its status is wonderful. Plug that into a monitoring system so you can see trends and I&#x2019;m overjoyed.&#xA;So why did we bother investing all this effort to add support for this to RavenDB? We would rather have the source data, not whatever we expose outside. RavenDB runs on a wide variety of hardware and software systems. By necessity, whatever we can provide is only a partial view.&#xA;The answer to that is that we cannot assume that the administrator has set up such monitoring. Nor can we assume that they are able to.&#xA;For example, the system may be running on a container in an environment where the people we talk to have no actual access to the host machine to pull production details.&#xA;Having a significant investment in self-contained set of diagnostics means that we aren&#x2019;t limited to whatever the admin has set up (and has the permissions to view) but have a consistent experience digging into issues.&#xA;And since we have our own self contained diagnostics, we can push them out to create a debug package for offline analysis or even take active actions in response to the state of the system.&#xA;If we were relying on external monitoring, we would need to integrate that, each and every time. The amount of work (and quality of the result) in such an endeavor is huge.&#xA;We build RavenDB to last in production, and part of that is that it needs to be able to survive even outside of the hothouse environment.</p>
        </article>
        <article id="article-643">
            <a href="https://andrewlock.net/a-brief-introduction-to-diagnostic-source/" target="_blank">
                <h2 class="title mb-6" id="article-643">A brief introduction to DiagnosticSource</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 14, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I describe the DiagnosticSource infrastructure, how it compares to other logging APIs, and how to use it to listen to framework events&#x2026;</p>
        </article>
        <article id="article-644">
            <a href="https://ayende.com/blog/197505-C/high-performance-net-building-a-redis-clone-separation-of-computation-i-o" target="_blank">
                <h2 class="title mb-6" id="article-644">High performance .NET</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 13, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">After achieving 1.25 million ops/sec, I decided to see what would happen if I would change the code to support pipelining. That ended up being quite involved, because I needed to both keep track of all the incoming work as well as send the work to multiple locations. The code itself is garbage, in my opinion. It is worth it only as far as it points me inthe right direction in terms of the overall architecture. You can read it below, but it is a bit complex. We read from the client as much as we are able, then we send it to each of the dedicated threads to run it.&#xA;In terms of performance, it is actually slower than the previous iteration (by about 20%!), but it serves a very important aspect, it makes it easy to tell where the costs are.&#xA;Take a look at the following profiler result:&#xA;&#xA;You can see that we are spending a lot of time in I/O and in string processing. The GC time is also quite significant.&#xA;Conversely, when we actually process the commands from the clients, we are spending most of the time simply idling.&#xA;&#xA;I want to tackle this in stages. The first part is to stop using strings all over the place. The next stage after that will likely be to change the I/O model.&#xA;For now, here is where we stand:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          using System.Collections.Concurrent;&#xA;        &#xA;        &#xA;          &#xA;          using System.Net.Sockets;&#xA;        &#xA;        &#xA;          &#xA;          using System.Text;&#xA;        &#xA;        &#xA;          &#xA;          using System.Threading.Channels;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var listener = new TcpListener(System.Net.IPAddress.Any, 6379);&#xA;        &#xA;        &#xA;          &#xA;          listener.Start();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          ShardedDictionary _state = new(Environment.ProcessorCount / 2);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          while (true)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var tcp = listener.AcceptTcpClient();&#xA;        &#xA;        &#xA;          &#xA;              var stream = tcp.GetStream();&#xA;        &#xA;        &#xA;          &#xA;              var client = new Client(tcp, new StreamReader(stream), new StreamWriter(stream)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  AutoFlush = true&#xA;        &#xA;        &#xA;          &#xA;              }, _state);&#xA;        &#xA;        &#xA;          &#xA;              var _ = client.ReadAsync();&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          class Client&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public readonly TcpClient Tcp;&#xA;        &#xA;        &#xA;          &#xA;              public readonly StreamReader Reader;&#xA;        &#xA;        &#xA;          &#xA;              public readonly StreamWriter Writer;&#xA;        &#xA;        &#xA;          &#xA;              public readonly ShardedDictionary Dic;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public struct Command&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  public string Key;&#xA;        &#xA;        &#xA;          &#xA;                  public string? Value;&#xA;        &#xA;        &#xA;          &#xA;                  public bool Completed;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private List&lt;string&gt; _args = new();&#xA;        &#xA;        &#xA;          &#xA;              private Task&lt;string?&gt; _nextLine;&#xA;        &#xA;        &#xA;          &#xA;              private Command[] _commands = Array.Empty&lt;Command&gt;();&#xA;        &#xA;        &#xA;          &#xA;              private int _commandsLength = 0;&#xA;        &#xA;        &#xA;          &#xA;              private StringBuilder _buffer = new();&#xA;        &#xA;        &#xA;          &#xA;              private int _shardFactor;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public Client(TcpClient tcp, StreamReader reader, StreamWriter writer, ShardedDictionary dic)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  Tcp = tcp;&#xA;        &#xA;        &#xA;          &#xA;                  Reader = reader;&#xA;        &#xA;        &#xA;          &#xA;                  Writer = writer;&#xA;        &#xA;        &#xA;          &#xA;                  Dic = dic;&#xA;        &#xA;        &#xA;          &#xA;                  _shardFactor = dic.Factor;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task ReadAsync()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  try&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      while (true)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          if (_buffer.Length != 0)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              await Writer.WriteAsync(_buffer);&#xA;        &#xA;        &#xA;          &#xA;                              _buffer.Length = 0;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          var lineTask = _nextLine ?? Reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                          if (lineTask.IsCompleted == false)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              if (_commandsLength != 0)&#xA;        &#xA;        &#xA;          &#xA;                              {&#xA;        &#xA;        &#xA;          &#xA;                                  _nextLine = lineTask;&#xA;        &#xA;        &#xA;          &#xA;                                  Dic.Enqueue(this, Math.Abs(_commands[0].Key.GetHashCode()) % _shardFactor);&#xA;        &#xA;        &#xA;          &#xA;                                  return;&#xA;        &#xA;        &#xA;          &#xA;                              }&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          var line = await lineTask;&#xA;        &#xA;        &#xA;          &#xA;                          _nextLine = null;&#xA;        &#xA;        &#xA;          &#xA;                          if (line == null)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              using (Tcp) // done reading...&#xA;        &#xA;        &#xA;          &#xA;                              {&#xA;        &#xA;        &#xA;          &#xA;                                  return;&#xA;        &#xA;        &#xA;          &#xA;                              }&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          await ReadCommand(line);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          AddCommand();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  catch (Exception e)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      await HandleError(e);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private async Task ReadCommand(string line)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _args.Clear();&#xA;        &#xA;        &#xA;          &#xA;                  if (line[0] != &#x27;*&#x27;)&#xA;        &#xA;        &#xA;          &#xA;                      throw new InvalidDataException(&quot;Cannot understand arg batch: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;                  var argsv = int.Parse(line.Substring(1));&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; argsv; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      line = await Reader.ReadLineAsync() ?? string.Empty;&#xA;        &#xA;        &#xA;          &#xA;                      if (line[0] != &#x27;$&#x27;)&#xA;        &#xA;        &#xA;          &#xA;                          throw new InvalidDataException(&quot;Cannot understand arg length: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;                      var argLen = int.Parse(line.Substring(1));&#xA;        &#xA;        &#xA;          &#xA;                      line = await Reader.ReadLineAsync() ?? string.Empty;&#xA;        &#xA;        &#xA;          &#xA;                      if (line.Length != argLen)&#xA;        &#xA;        &#xA;          &#xA;                          throw new InvalidDataException(&quot;Wrong arg length expected &quot; &#x2B; argLen &#x2B; &quot; got: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      _args.Add(line);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private void AddCommand()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  if (_commandsLength &gt;= _commands.Length)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      Array.Resize(ref _commands, _commands.Length &#x2B; 8);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  ref Command cmd = ref _commands[_commandsLength&#x2B;&#x2B;];&#xA;        &#xA;        &#xA;          &#xA;                  cmd.Completed = false;&#xA;        &#xA;        &#xA;          &#xA;                  switch (_args[0])&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      case &quot;GET&quot;:&#xA;        &#xA;        &#xA;          &#xA;                          cmd.Key = _args[1];&#xA;        &#xA;        &#xA;          &#xA;                          cmd.Value = null;&#xA;        &#xA;        &#xA;          &#xA;                          break;&#xA;        &#xA;        &#xA;          &#xA;                      case &quot;SET&quot;:&#xA;        &#xA;        &#xA;          &#xA;                          cmd.Key = _args[1];&#xA;        &#xA;        &#xA;          &#xA;                          cmd.Value = _args[2];&#xA;        &#xA;        &#xA;          &#xA;                          break;&#xA;        &#xA;        &#xA;          &#xA;                      default:&#xA;        &#xA;        &#xA;          &#xA;                          throw new ArgumentOutOfRangeException(&quot;Unknown command: &quot; &#x2B; _args[0]);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task NextAsync()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  try&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      WriteToBuffer();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      await ReadAsync();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  catch (Exception e)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      await HandleError(e);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private void WriteToBuffer()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; _commandsLength; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      ref Command cmd = ref _commands[i];&#xA;        &#xA;        &#xA;          &#xA;                      if (cmd.Value == null)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          _buffer.Append(&quot;$-1\r\n&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      else&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          _buffer.Append($&quot;${cmd.Value.Length}\r\n{cmd.Value}\r\n&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  _commandsLength = 0;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task HandleError(Exception e)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  using (Tcp)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      try&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          string? line;&#xA;        &#xA;        &#xA;          &#xA;                          var errReader = new StringReader(e.ToString());&#xA;        &#xA;        &#xA;          &#xA;                          while ((line = errReader.ReadLine()) != null)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              await Writer.WriteAsync(&quot;-&quot;);&#xA;        &#xA;        &#xA;          &#xA;                              await Writer.WriteLineAsync(line);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          await Writer.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      catch (Exception)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          // nothing we can do&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              internal void Execute(Dictionary&lt;string, string&gt; localDic, int index)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  int? next = null;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; _commandsLength; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      ref var cmd = ref _commands[i];&#xA;        &#xA;        &#xA;          &#xA;                      var cur = Math.Abs(cmd.Key.GetHashCode()) % _shardFactor;&#xA;        &#xA;        &#xA;          &#xA;                      if (cur == index) // match&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          cmd.Completed = true;&#xA;        &#xA;        &#xA;          &#xA;                          if (cmd.Value != null)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              localDic[cmd.Key] = cmd.Value;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          else&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              localDic.TryGetValue(cmd.Key, out cmd.Value);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      else if (cmd.Completed == false)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          next = cur;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  if (next != null)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      Dic.Enqueue(this, next.Value);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  else&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      _ = NextAsync();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          class ShardedDictionary&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Dictionary&lt;string, string&gt;[] _dics;&#xA;        &#xA;        &#xA;          &#xA;              BlockingCollection&lt;Client&gt;[] _workers;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public int Factor =&gt; _dics.Length;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public ShardedDictionary(int shardingFactor)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _dics = new Dictionary&lt;string, string&gt;[shardingFactor];&#xA;        &#xA;        &#xA;          &#xA;                  _workers = new BlockingCollection&lt;Client&gt;[shardingFactor];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; shardingFactor; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var dic = new Dictionary&lt;string, string&gt;();&#xA;        &#xA;        &#xA;          &#xA;                      var worker = new BlockingCollection&lt;Client&gt;();&#xA;        &#xA;        &#xA;          &#xA;                      _dics[i] = dic;&#xA;        &#xA;        &#xA;          &#xA;                      _workers[i] = worker;&#xA;        &#xA;        &#xA;          &#xA;                      var index = i;&#xA;        &#xA;        &#xA;          &#xA;                      // readers&#xA;        &#xA;        &#xA;          &#xA;                      new Thread(() =&gt;&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          ExecWorker(dic, index, worker);&#xA;        &#xA;        &#xA;          &#xA;                      })&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          IsBackground = true,&#xA;        &#xA;        &#xA;          &#xA;                      }.Start();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private static void ExecWorker(Dictionary&lt;string, string&gt; dic, int index, BlockingCollection&lt;Client&gt; worker)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  while (true)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      worker.Take().Execute(dic, index);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Enqueue(Client c, int index)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _workers[index].Add(c);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Redis.3.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub</p>
        </article>
        <article id="article-645">
            <a href="https://www.meziantou.net/using-avif-codec-for-images-to-reduce-web-page-size.htm" target="_blank">
                <h2 class="title mb-6" id="article-645">Using Avif codec for images to reduce web page size</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 13, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">This post is part of the series &#x27;Web Performance&#x27;. Be sure to check out the rest of the blog posts of the series!Website performance: Why and how to measure?Website performance: How I&#x27;ve improved the performance of this website?Using AV1 video codec to reduce web page sizeUsing Avif codec for image</p>
        </article>
        <article id="article-646">
            <a href="https://ayende.com/blog/197473-C/high-performance-net-building-a-redis-clone-architecture" target="_blank">
                <h2 class="title mb-6" id="article-646">High performance .NET</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 10, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">My previous attempts to write a Redis clone were done in about as straightforward a way as possible. Open a socket to listen on, have a separate Task for each client that reads from the network, parse the command and execute it. There are some smarts around supporting pipelining, but that is pretty much it.&#xA;Let&#x2019;s take a step back and build ourselves a Redis clone that matches the actual Redis architecture more closely. In order to do that, I&#x2019;ll need to do everything in a single thread. That is&#x2026; surprisingly hard to do in C#. There are no APIs for doing the kind of work that Redis is doing. To be rather more exact, there is the Socket.Select() method, but that requires building everything on top of that (meaning that we have to handle buffering, string handling, etc).&#xA;Given that this is a way station to the final proposed architecture, I decided to skip this entirely. Instead, I&#x2019;m going to focus first on removing the major bottleneck in the system, the ConcurrentDictionary.&#xA;The profiler results show that the biggest cost we have here is the scalability of the concurrent dictionary. Even when we tried to shard it across 1024 locks, it still took almost 50% of our runtime. The question is, can we do better? One good option that we can try is to shard things directly. Instead of using a single concurrent dictionary, we will split it to separate dictionaries, each one of them would be accessed without concurrency.&#xA;The idea goes like this, we&#x2019;ll have the usual read &amp; write for the clients. But instead of processing the command inline, we&#x2019;ll route it to a dedicated thread (with its own dictionary) to do the work. I set it so we&#x2019;ll have 10 such threads (assuming they will reside on individual cores and that I&#x2019;ll be able to process all I/O on the other 6 cores.&#xA;Here are the results after the change:&#xA;&#xA;============================================================================================================================&#xA;Type         Ops/sec     Hits/sec   Misses/sec    Avg. Latency     p50 Latency     p99 Latency   p99.9 Latency       KB/sec&#xA;----------------------------------------------------------------------------------------------------------------------------&#xA;Sets       113703.56          ---          ---         3.06261         0.95900        25.59900        39.93500     33743.38&#xA;Gets      1137015.79     19211.78   1117804.01         3.06109         0.95900        25.59900        39.93500     49150.52&#xA;Waits           0.00          ---          ---             ---             ---             ---             ---          ---&#xA;Totals    1250719.35     19211.78   1117804.01         3.06122         0.95900        25.59900        39.93500     82893.90&#xA;&#xA;Note that we are now at 1.25 million, almost 25% better than the previous run.&#xA;Here are some profiler results of running this code:&#xA;&#xA;So in this case, we are spending a lot of time doing string processing of various kinds, waiting for GC (almost 30%). The costs for collections went down a lot (but we&#x2019;ll see that it shifted somewhat).&#xA;There are some other things that pop to mind, take a look here:&#xA;&#xA;That is a surprising cost for a &#x201C;simple&#x201D; property lookup. The substrings calls are also expensive, over 6% of the overall runtime.&#xA;When looking at other parts of the system, we have:&#xA;&#xA;This is really interesting, because we spend a lot of time just waiting for items in the queue. We could probably do more things in there rather than just wait.&#xA;I also tried various other concurrency values. With a single ExecWorker running, we have 404,187 ops/sec and with two of them we are at 715,157 ops/sec. When running with four threads dedicated to processing the requests, we are at 1,060,622.24 ops/sec.&#xA;So it is obvious that we need to rethink this approach for concurrency. We aren&#x2019;t able to properly scale to bigger values.&#xA;Note that this approach also does not take advantage of pipelining. We process each command separately from all else. My next move is to add support for pipelining with this approach and measure that impact.&#xA;On the one hand, we are still at around the million mark, but given that I spent very little time (and not a lot of complexity) getting an extra 250,000 ops/second from that level of change is encouraging. The profiler is also telling us that there are more things that we can do, but I want to focus on fixing the approach we take first.&#xA;Here is the current state of the code, so you can compare it to the original one.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          using System.Collections.Concurrent;&#xA;        &#xA;        &#xA;          &#xA;          using System.Net.Sockets;&#xA;        &#xA;        &#xA;          &#xA;          using System.Threading.Channels;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var listener = new TcpListener(System.Net.IPAddress.Any, 6379);&#xA;        &#xA;        &#xA;          &#xA;          listener.Start();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var redisClone = new RedisClone();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          while (true)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var client = listener.AcceptTcpClient();&#xA;        &#xA;        &#xA;          &#xA;              var _ = redisClone.HandleConnection(client); // run async&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public class RedisClone&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              ShardedDictionary _state = new(Environment.ProcessorCount / 2);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task HandleConnection(TcpClient tcp)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var _ = tcp;&#xA;        &#xA;        &#xA;          &#xA;                  var stream = tcp.GetStream();&#xA;        &#xA;        &#xA;          &#xA;                  var client = new Client&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      Tcp = tcp,&#xA;        &#xA;        &#xA;          &#xA;                      Dic = _state,&#xA;        &#xA;        &#xA;          &#xA;                      Reader = new StreamReader(stream),&#xA;        &#xA;        &#xA;          &#xA;                      Writer = new StreamWriter(stream)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          NewLine = &quot;\r\n&quot;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;                  await client.ReadAsync();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          class Client&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              public TcpClient Tcp;&#xA;        &#xA;        &#xA;          &#xA;              public StreamReader Reader;&#xA;        &#xA;        &#xA;          &#xA;              public StreamWriter Writer;&#xA;        &#xA;        &#xA;          &#xA;              public string Key;&#xA;        &#xA;        &#xA;          &#xA;              public string? Value;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public ShardedDictionary Dic;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              List&lt;string&gt; Args = new();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task ReadAsync()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  try&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      Args.Clear();&#xA;        &#xA;        &#xA;          &#xA;                      var lineTask = Reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                      if (lineTask.IsCompleted == false)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          await Writer.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      var line = await lineTask;&#xA;        &#xA;        &#xA;          &#xA;                      if (line == null)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          using (Tcp)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              return;&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      if (line[0] != &#x27;*&#x27;)&#xA;        &#xA;        &#xA;          &#xA;                          throw new InvalidDataException(&quot;Cannot understand arg batch: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      var argsv = int.Parse(line.Substring(1));&#xA;        &#xA;        &#xA;          &#xA;                      for (int i = 0; i &lt; argsv; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          line = await Reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                          if (line == null || line[0] != &#x27;$&#x27;)&#xA;        &#xA;        &#xA;          &#xA;                              throw new InvalidDataException(&quot;Cannot understand arg length: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;                          var argLen = int.Parse(line.Substring(1));&#xA;        &#xA;        &#xA;          &#xA;                          line = await Reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                          if (line == null || line.Length != argLen)&#xA;        &#xA;        &#xA;          &#xA;                              throw new InvalidDataException(&quot;Wrong arg length expected &quot; &#x2B; argLen &#x2B; &quot; got: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          Args.Add(line);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                      switch (Args[0])&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          case &quot;GET&quot;:&#xA;        &#xA;        &#xA;          &#xA;                              Key = Args[1];&#xA;        &#xA;        &#xA;          &#xA;                              Value = null;&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                          case &quot;SET&quot;:&#xA;        &#xA;        &#xA;          &#xA;                              Key = Args[1];&#xA;        &#xA;        &#xA;          &#xA;                              Value = Args[2];&#xA;        &#xA;        &#xA;          &#xA;                              break;&#xA;        &#xA;        &#xA;          &#xA;                          default:&#xA;        &#xA;        &#xA;          &#xA;                              throw new ArgumentOutOfRangeException(&quot;Unknown command: &quot; &#x2B; Args[0]);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      Dic.Run(this);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  catch (Exception e)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      await HandleError(e);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task NextAsync()&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  try&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      if (Value == null)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          await Writer.WriteLineAsync(&quot;$-1&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      else&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          await Writer.WriteLineAsync($&quot;${Value.Length}\r\n{Value}&quot;);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      await ReadAsync();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  catch (Exception e)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      await HandleError(e);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task HandleError(Exception e)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  using (Tcp)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      try&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          string? line;&#xA;        &#xA;        &#xA;          &#xA;                          var errReader = new StringReader(e.ToString());&#xA;        &#xA;        &#xA;          &#xA;                          while ((line = errReader.ReadLine()) != null)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              await Writer.WriteAsync(&quot;-&quot;);&#xA;        &#xA;        &#xA;          &#xA;                              await Writer.WriteLineAsync(line);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          await Writer.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      catch (Exception)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          // nothing we can do&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          class ShardedDictionary&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              Dictionary&lt;string, string&gt;[] _dics;&#xA;        &#xA;        &#xA;          &#xA;              BlockingCollection&lt;Client&gt;[] _workers;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public ShardedDictionary(int shardingFactor)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  _dics = new Dictionary&lt;string, string&gt;[shardingFactor];&#xA;        &#xA;        &#xA;          &#xA;                  _workers = new BlockingCollection&lt;Client&gt;[shardingFactor];&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  for (int i = 0; i &lt; shardingFactor; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var dic = new Dictionary&lt;string, string&gt;();&#xA;        &#xA;        &#xA;          &#xA;                      var worker = new BlockingCollection&lt;Client&gt;();&#xA;        &#xA;        &#xA;          &#xA;                      _dics[i] = dic;&#xA;        &#xA;        &#xA;          &#xA;                      _workers[i] = worker;&#xA;        &#xA;        &#xA;          &#xA;                      // readers&#xA;        &#xA;        &#xA;          &#xA;                      new Thread(() =&gt;&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          ExecWorker(dic, worker);&#xA;        &#xA;        &#xA;          &#xA;                      })&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          IsBackground = true,&#xA;        &#xA;        &#xA;          &#xA;                      }.Start();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              private static void ExecWorker(Dictionary&lt;string, string&gt; dic, BlockingCollection&lt;Client&gt; worker)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  while (true)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var client = worker.Take();&#xA;        &#xA;        &#xA;          &#xA;                      if (client.Value != null)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          dic[client.Key] = client.Value;&#xA;        &#xA;        &#xA;          &#xA;                          client.Value = null;&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      else&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          dic.TryGetValue(client.Key, out client.Value);&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      var _ = client.NextAsync();&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public void Run(Client c)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  var reader = _workers[c.GetHashCode() % _workers.Length];&#xA;        &#xA;        &#xA;          &#xA;                  reader.Add(c);&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Redis.2.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub</p>
        </article>
        <article id="article-647">
            <a href="https://ayende.com/blog/197441-A/high-performance-net-building-a-redis-clone-analysis" target="_blank">
                <h2 class="title mb-6" id="article-647">High performance .NET</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 09, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In the previous post, I wrote a small Redis clone using the most na&#xEF;ve&#xA0;manner. It was able to hit nearly 1M queries per second on our test instance (c6g.4xlarge, using 16 cores and 64 GB of memory). Before we get any deeper into optimization, it is worth understanding where the time is actually being spent. I run the server under a profiler, to see the various costs.&#xA;I like using dotTrace as a profiler, while using the Tracing mode, since that gives me execution time as well as the number of calls. Often enough I can reason a lot about the system performance just from those details.&#xA;Take a look at the following stats, this is the breakdown of costs in the actual processing of the connection:&#xA;&#xA;And here it is when we break it up by&#xA;&#xA;You can see that the cost of FlushAsync() dominates. I&#x2019;m going to form a hypothesis here. When we call FlushAsync() on the StreamWriter, we&#x2019;ll also flush to the underlying stream. Looking deeper into the call stack that looks like we&#x2019;ll need a separate packet per command at the TCP level.&#xA;What will happen if we&#x2019;ll change the StreamWriter&#x2019;s  AutoFlush to true, which will cause it to write immediately to the underlying stream, but won&#x2019;t call the flush on the TCP stream. That will allow the TCP stream to buffer writes more efficiently.&#xA;The code change involved is removing the FlushAsync() calls and initializing the StreamWiter like so:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          using var writer = new StreamWriter(stream)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              NewLine = &quot;\r\n&quot;,&#xA;        &#xA;        &#xA;          &#xA;              AutoFlush = true,&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          AutoFlush.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Let&#x2019;s run the benchmark again, which will give us (on my development machine):&#xA;&#xA;138,979.57 QPS &#x2013; using AutoFlush = true&#xA;139,653.98 QPS &#x2013; using FlushAsync&#xA;&#xA;Either option is a wash, basically. But here is why:&#xA;&#xA;Basically, AutoFlush set to true will flush not just the current stream, but also the underlying stream, putting us in the same position.&#xA;The problem is that we need to flush, otherwise we may buffer results in memory that won&#x2019;t be sent to the client. Redis benchmarks rely heavily on pipelining (sending multiple commands at once), but it is entirely possible that you&#x2019;ll get a bunch of commands, write them (to the buffer) and then not send anything to the client since the output buffer isn&#x2019;t full. We can optimize this quite easily, using the following change:&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          34c34,39&#xA;        &#xA;        &#xA;          &#xA;          &lt;                 var line = await reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;          ---&#xA;        &#xA;        &#xA;          &#xA;          &gt;                 var lineTask = reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;          &gt;                 if(lineTask.IsCompleted == false)&#xA;        &#xA;        &#xA;          &#xA;          &gt;                 {&#xA;        &#xA;        &#xA;          &#xA;          &gt;                     await writer.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;          &gt;                 }&#xA;        &#xA;        &#xA;          &#xA;          &gt;                 var line = await lineTask;&#xA;        &#xA;        &#xA;          &#xA;          62d66&#xA;        &#xA;        &#xA;          &#xA;          &lt;                 await writer.FlushAsync();&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          diff.patch&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;What I&#x2019;m doing here is writing to the StreamWriter directly, and I&#x2019;ll only flush the buffer if there is no more input waiting. That should reduce the number of packets we send significantly, and it does. Running the benchmark again gives us:&#xA;&#xA;229,783.30 QPS &#x2013; using delayed flushing&#xA;&#xA;That is almost twice as fast, which is impressive, for such a small change. The idea is that we are able to buffer our writes far more, but not delay them too much. If we write enough to the StreamWriter buffer, it will flush itself automatically, and we&#x2019;ll only actually flush the StreamWriter manually when we have nothing further to read, which we do in parallel with the reading itself.&#xA;Here is the new cost structure:&#xA;&#xA;And the actual methods called:&#xA;&#xA;If we&#x2019;ll compare this to the first profiling results, we can find some really interesting numbers. Before, we have called FlushAsync per command (see the ExecuteCommand &amp; FlushAsync), now we call this a lot less often).&#xA;You can see that most of the time is now in the &#x201C;business logic&#x201D; for this system, and from the subsystems breakdown, a lot of the cost is now in the collections.&#xA;The GC costs here also went down significantly (~5%). I&#x2019;m fairly certain that this is because we flush to the TCP stream, but I didn&#x2019;t check too much.&#xA;Note that string processing and GC take a lot of time, but the Collections / ExecuteCommand is taking the vast majority of the costs.&#xA;If we look into that, we&#x2019;ll see:&#xA;&#xA;And that is&#x2026; interesting.&#xA;Mostly because the major costs are in TryAddInternal. We know that there is high contention in this scenario, but 92% of the time spent in the method directly? What is it doing? Looking at the code, it becomes obvious:&#xA;&#xA;The ConcurrentDictionary is sharding the calls between the locks. And the number of locks is defined by the number of the cores we have by default. The more concurrency we have, the more we can benefit from increasing the amount. I tried setting this to 1024 and running it under the profiler, and this gave me a few percentage points improvements, but not much more. Valuable, but not at the level we are playing with.&#xA;Even so, we managed to get some interesting details from this exploration. We know that we&#x2019;ll have to deal with the dictionary implementation, since it takes roughly 50% of our time. I also want to pay some attention to these numbers:&#xA;&#xA;Right now, we need to figure out how to make it faster in terms of collections, but we also have to consider overall GC costs as well as the string processing details. More on that in the next post.</p>
        </article>
        <article id="article-648">
            <a href="https://ayende.com/blog/197412-B/high-performance-net-building-a-redis-clone-naively" target="_blank">
                <h2 class="title mb-6" id="article-648">High performance .NET</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 08, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I run into this project, which aims to be a Redis clone with better performance and ease of use. I found it interesting because one of the main selling points there was that it is able to run in a multi threaded mode (instead of Redis&#x2019; single thread per process model). They use memtier_benchmark (part of Redis) to test their performance. I got curious about how much performance I could get out of the system if I built my own Redis clone in C#.&#xA;The first version I built was done pretty naively. The idea is to write it in a high level manner, and see where that puts us. To make things interesting, here are the test scenarios:&#xA;&#xA;The memtier_benchmark is going to run on c6g.2xlarge instance, using 8 cores and 32 GB of memory.&#xA;The tested instance is going to run on c6g.4xlarge, using 16 cores and 64 GB of memory.&#xA;&#xA;Both of those instances are running on the same availability zone.&#xA;The command I&#x2019;m going to run is:&#xA;&#xA;memtier_benchmark &#x2013;s $SERVER_IP -t 8 -c 16 --test-time=30 --distinct-client-seed -d 256 --pipeline=30&#xA;&#xA;What this says is that we&#x2019;ll use 8 threads (number of cores on the client instance) with 32 connections per thread, we&#x2019;ll use 20% writes &amp; 80% reads with data size that is 256 bytes in size. In total, we&#x2019;ll have 256 clients and out tests are going to continuously push more data into the system.&#xA;The server is being run using:&#xA;&#xA;dotnet run &#x2013;c Release&#xA;&#xA;Here is an example of the server while under this test:&#xA;&#xA;I chose 30 seconds for the test duration to balance doing enough work to feel what is going on (multiple GC cycles, etc) while keeping the test duration short enough that I won&#x2019;t get bored.&#xA;Here are the na&#xEF;ve version results:&#xA;&#xA;============================================================================================================================&#xA;Type         Ops/sec     Hits/sec   Misses/sec    Avg. Latency     p50 Latency     p99 Latency   p99.9 Latency       KB/sec&#xA;----------------------------------------------------------------------------------------------------------------------------&#xA;Sets        86300.19          ---          ---         8.14044         0.92700        99.83900       196.60700     25610.97&#xA;Gets       862870.15     36255.57    826614.58         8.10119         0.91900        99.32700       196.60700     42782.42&#xA;Waits           0.00          ---          ---             ---             ---             ---             ---          ---&#xA;Totals     949170.34     36255.57    826614.58         8.10476         0.91900        99.32700       196.60700     68393.39&#xA;&#xA;So the na&#xEF;ve version, using C#, doing almost nothing, is almost touching the 1 million queries / sec. The latency, on the other hand, isn&#x2019;t that good. With the p99 at almost 100ms.&#xA;Now that I got your attention with the numbers and pretty graphs, let me show you the actual code that I&#x27;m running. This is a &#x201C;Redis Clone&#x201D; in under 100 lines of code.&#xA;&#xA;&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          using System.Collections.Concurrent;&#xA;        &#xA;        &#xA;          &#xA;          using System.Net.Sockets;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          var listener = new TcpListener(System.Net.IPAddress.Any, 6379);&#xA;        &#xA;        &#xA;          &#xA;          listener.Start();&#xA;        &#xA;        &#xA;          &#xA;          var redisClone = new RedisClone();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          while (true)&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var client = listener.AcceptTcpClient();&#xA;        &#xA;        &#xA;          &#xA;              var _ = redisClone.HandleConnection(client); // run async&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          public class RedisClone&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              ConcurrentDictionary&lt;string, string&gt; _state = new();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              public async Task HandleConnection(TcpClient client)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  using var _ = client;&#xA;        &#xA;        &#xA;          &#xA;                  using var stream = client.GetStream();&#xA;        &#xA;        &#xA;          &#xA;                  using var reader = new StreamReader(stream);&#xA;        &#xA;        &#xA;          &#xA;                  using var writer = new StreamWriter(stream)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      NewLine = &quot;\r\n&quot;&#xA;        &#xA;        &#xA;          &#xA;                  };&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                  try&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      var args = new List&lt;string&gt;();&#xA;        &#xA;        &#xA;          &#xA;                      while (true)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          args.Clear();&#xA;        &#xA;        &#xA;          &#xA;                          var line = await reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                          if (line == null) break;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          if (line[0] != &#x27;*&#x27;)&#xA;        &#xA;        &#xA;          &#xA;                              throw new InvalidDataException(&quot;Cannot understand arg batch: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                          var argsv = int.Parse(line.Substring(1));&#xA;        &#xA;        &#xA;          &#xA;                          for (int i = 0; i &lt; argsv; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              line = await reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                              if (line == null || line[0] != &#x27;$&#x27;)&#xA;        &#xA;        &#xA;          &#xA;                                  throw new InvalidDataException(&quot;Cannot understand arg length: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;                              var argLen = int.Parse(line.Substring(1));&#xA;        &#xA;        &#xA;          &#xA;                              line = await reader.ReadLineAsync();&#xA;        &#xA;        &#xA;          &#xA;                              if (line == null || line.Length != argLen)&#xA;        &#xA;        &#xA;          &#xA;                                  throw new InvalidDataException(&quot;Wrong arg length expected &quot; &#x2B; argLen &#x2B; &quot; got: &quot; &#x2B; line);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;                              args.Add(line);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          var reply = ExecuteCommand(args);&#xA;        &#xA;        &#xA;          &#xA;                          if(reply == null)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              await writer.WriteLineAsync(&quot;$-1&quot;);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          else&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              await writer.WriteLineAsync($&quot;${reply.Length}\r\n{reply}&quot;);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          await writer.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;                  catch (Exception e)&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      try&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          string? line;&#xA;        &#xA;        &#xA;          &#xA;                          var errReader = new StringReader(e.ToString());&#xA;        &#xA;        &#xA;          &#xA;                          while ((line = errReader.ReadLine()) != null)&#xA;        &#xA;        &#xA;          &#xA;                          {&#xA;        &#xA;        &#xA;          &#xA;                              await writer.WriteAsync(&quot;-&quot;);&#xA;        &#xA;        &#xA;          &#xA;                              await writer.WriteLineAsync(line);&#xA;        &#xA;        &#xA;          &#xA;                          }&#xA;        &#xA;        &#xA;          &#xA;                          await writer.FlushAsync();&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                      catch (Exception)&#xA;        &#xA;        &#xA;          &#xA;                      {&#xA;        &#xA;        &#xA;          &#xA;                          // nothing we can do&#xA;        &#xA;        &#xA;          &#xA;                      }&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              string? ExecuteCommand(List&lt;string&gt; args)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  switch (args[0])&#xA;        &#xA;        &#xA;          &#xA;                  {&#xA;        &#xA;        &#xA;          &#xA;                      case &quot;GET&quot;:&#xA;        &#xA;        &#xA;          &#xA;                          return _state.GetValueOrDefault(args[1]);&#xA;        &#xA;        &#xA;          &#xA;                      case &quot;SET&quot;:&#xA;        &#xA;        &#xA;          &#xA;                          _state[args[1]] = args[2];&#xA;        &#xA;        &#xA;          &#xA;                          return null;&#xA;        &#xA;        &#xA;          &#xA;                      default:&#xA;        &#xA;        &#xA;          &#xA;                          throw new ArgumentOutOfRangeException(&quot;Unknown command: &quot; &#x2B; args[0]);&#xA;        &#xA;        &#xA;          &#xA;                  }&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          Redis.Naive.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;&#xA;&#xA;Just a few notes on the implementation. I&#x2019;m not actually doing much. Most of the code is there to parse the Redis protocol. And the code is full of allocations. Each command parsing is done using multiple string splits and concats. Replies to the client require even more concats. The &#x201C;store&#x201D; for the system is actually just a simple ConcurrentDictionary, without anything to avoid contention or high costs.&#xA;The manner in which we handle I/O is pretty horrible, and&#x2026; I think you get where I&#x2019;m going here, right? My goal is to see how I can use this (pretty simple) example to get more performance without having to deal with a lot of extra fluff.&#xA;Given my initial attempt is already at nearly 1M QPS, that is a pretty good start, even if I say so myself.&#xA;The next step that I want to take it to handle the allocations that are going on here. We can probably do better here, and I aim to try. But I&#x2019;ll do that in the next post.</p>
        </article>
        <article id="article-649">
            <a href="https://ayende.com/blog/197411-B/unit-testing-ravendb" target="_blank">
                <h2 class="title mb-6" id="article-649">Unit testing RavenDB</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 07, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Steven has written a post about unit testing RavenDB which shows how easy it is to just write the code you&#x2019;ll do anyway, and be able to seamlessly and easily test that without any hassles whatsoever.</p>
        </article>
        <article id="article-650">
            <a href="https://ardalis.com/quickly-trimming-video-files/" target="_blank">
                <h2 class="title mb-6" id="article-650">Quickly Trimming Video Files</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: June 07, 2022
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I do a fair bit of video editing as part of producing content for Pluralsight, clients, and YouTube. Recently I took on the task of editing&#x2026;Keep Reading &#x2192;</p>
        </article>
        <div class="button flex justify-between">
            <a href="64.html"><span class="back arrow"></span></a>

            <a href="66.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2024<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>
</body>
</html>