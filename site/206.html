
<!DOCTYPE html>
<html class="scroll-smooth" lang="en-US" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, shrink-to-fit=no" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <title>Page 206 â€¢ Relatively General .NET</title>
    <link href="favicon.ico" rel="icon" sizes="any">
    <link href="images/apple-touch-icon.png" rel="apple-touch-icon">
    <meta content="hsl()" name="theme-color">
    <meta content="website" property="og:type">
    <meta content="Home" property="og:title">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="pagefind/pagefind-ui.css">
    <!-- Google Analytics -->
    <script>
        // Only load GA if consent is given
        function loadGA() {
            const script = document.createElement('script');
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-MDFXJY3FCY';
            script.async = true;
            document.head.appendChild(script);

            window.dataLayer = window.dataLayer || [];

            function gtag() {
                dataLayer.push(arguments);
            }

            gtag('js', new Date());
            gtag('config', 'G-MDFXJY3FCY');
        }

        // Check if consent was previously given
        if (localStorage.getItem('cookieConsent') === 'accepted') {
            loadGA();
        }
    </script>
    <!-- End Google Analytics -->
</head>
<body class="mx-auto flex min-h-screen max-w-3xl flex-col bg-bgColor px-4 pt-16 font-mono text-sm font-normal text-textColor antialiased sm:px-8">

<a class="sr-only focus:not-sr-only focus:fixed focus:start-1 focus:top-1.5" href="#main">
    skip to content
</a>
<header class="group relative mb-28 flex items-center sm:ps-[4.5rem]" id="main-header">
    <div class="flex sm:flex-col">
        <a aria-current="page" class="inline-flex items-center hover:filter-none sm:relative sm:inline-block"
           href="index.html">
            <img class="me-3 sm:absolute sm:start-[-4.5rem] sm:me-0 sm:h-16 sm:w-16 w-16" src="images/giphy.gif"
                 alt=""/>
            <span class="text-xl font-bold sm:text-2xl">Relatively General .NET</span>
        </a>
        <nav aria-label="Main menu"
             class="absolute -inset-x-4 top-14 hidden flex-col items-end gap-y-4 rounded-md bg-bgColor/[.85] py-4 text-accent shadow backdrop-blur group-[.menu-open]:z-50 group-[.menu-open]:flex sm:static sm:z-auto sm:-ms-4 sm:mt-1 sm:flex sm:flex-row sm:items-center sm:divide-x sm:divide-dashed sm:divide-accent sm:rounded-none sm:bg-transparent sm:py-0 sm:shadow-none sm:backdrop-blur-none"
             id="navigation-menu">
            <a aria-current="page" class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline"
               href="index.html"> Home </a><a
                class="px-4 py-4 underline-offset-2 sm:py-0 sm:hover:underline" href="/about/">
                About </a>
        </nav>
    </div>
    <site-search class="ms-auto" id="search">
        <button id="open-search"
                class="flex h-9 w-9 items-center justify-center rounded-md ring-zinc-400 transition-all hover:ring-2"
                data-open-modal="">
            <svg aria-label="search" class="h-7 w-7" fill="none" height="16" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="16"
                 xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" stroke="none"></path>
                <path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path>
            </svg>
        </button>
        <dialog aria-label="search"
                class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-bgColor shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md">
            <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6">
                <button id="close-search"
                        class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700"
                        data-close-modal="">Close
                </button>
                <div class="search-container">
                    <div id="cactus__search"/>
                </div>
            </div>
        </dialog>
    </site-search>
    <theme-toggle class="ms-2 sm:ms-4">
        <button id="theme-toggle" class="relative h-9 w-9 rounded-md p-2 ring-zinc-400 transition-all hover:ring-2"
                type="button">
            <span class="sr-only">Dark Theme</span>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-100 opacity-100 transition-all dark:scale-0 dark:opacity-0"
                 fill="none" focusable="false" id="sun-svg" stroke-width="1.5" viewBox="0 0 24 24"
                 xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18Z"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M22 12L23 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 2V1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M12 23V22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 20L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M20 4L19 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 20L5 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M4 4L5 5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
                <path d="M1 12L2 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-7 w-7 -translate-x-1/2 -translate-y-1/2 scale-0 opacity-0 transition-all dark:scale-100 dark:opacity-100"
                 fill="none" focusable="false" id="moon-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
                <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
                <path d="M19 11h2m-1 -1v2"></path>
            </svg>
        </button>
    </theme-toggle>
    <mobile-button>
        <button aria-expanded="false" aria-haspopup="menu" aria-label="Open main menu"
                class="group relative ms-4 h-7 w-7 sm:invisible sm:hidden" id="toggle-navigation-menu" type="button">
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 transition-all group-aria-expanded:scale-0 group-aria-expanded:opacity-0"
                 fill="none" focusable="false" id="line-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3.75 9h16.5m-16.5 6.75h16.5" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
            <svg aria-hidden="true"
                 class="absolute start-1/2 top-1/2 h-full w-full -translate-x-1/2 -translate-y-1/2 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100"
                 fill="none" focusable="false" id="cross-svg" stroke="currentColor" stroke-width="1.5"
                 viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
    </mobile-button>
</header>
<main id="main" data-pagefind-body>
    <section aria-label="Blog post list">
        <article id="article-2051">
            <a href="https://ayende.com/blog/185441-A/using-openssl-with-libuv" target="_blank">
                <h2 class="title mb-6" id="article-2051">Using OpenSSL with libuv</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I want to move my simple blocking socket based code to use libuv, so to allow more than a single connection per thread. The catch is that I also want to do that with TLS, and that seems to be much harder. There are a bunch of GitHub projects that talks about this, but as I know nothing about libuv (and very little about OpenSSL) I decided to write own TLS echo server with libuv to get better understanding of how it all play together. Sit tight, this might take a while to explain. This is a complex topic and it took me a couple of nights of hacking to get it work, and then a lot of thinking into simplifying this to something that I actually like. There seems to be great documentation for libuv, which is awesome. I went over the simple echo server sample and it seems relatively straightforward. Making the jump to using TLS is a bit harder. OpenSSL make it really easy to setup SSL on a socket file descriptor and read/write to it. There is even support for non blocking operations, but I didn&#x2019;t want to be forced to write my own select()/poll() code, so how can I integrate these two libraries?OpenSSL has the notion of a BIO abstraction, which stands for Basic I/O.&#xA0; Basically, this is a stream abstraction. One of the options that OpenSSL has available is the memory BIO. So the overall idea is to:Setup libuv to accept a connectionSetup OpenSSL with the server side configurationWhen a new connection comes through, setup a new SSL instance from SSLRead data from the socket and pass it to the SSL instance and vice versaEnjoy encrypted communicationThe devil is in the details, naturally. The most complex part, after getting the initial handshake to work, in my experience, is the fact that you can get re-negotiation at any time which mean that a write request will fail with need more read data. That really complicate the amount of state that you have to manage.Basically, on every SSL_write when managing your own state, you may need to do SSL_read and then retry to previous write. The simplest scenario that we have here is when SSL_accept() on the connection, which results in the following code to manage this state:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void complete_accept_ssl_flush(int socket, write_req_t* req, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(req-&gt;buf);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(req);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(socket, status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;async_read(socket, cb);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void maybe_flush_ssl_buffer(int socket) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = BIO_pending(state-&gt;write);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;write_req_t * req = calloc(1, sizeof(write_req_t));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;req-&gt;buf = malloc(rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;req-&gt;len = BIO_read(state-&gt;write, buf.base, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;async_write(socket &amp;buf, 1, complete_accept_ssl_flush);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;async_read(socket, complete_accept_ssl_flush);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void accept_ssl(int socket, void* buf, ssize_t nread) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (nread &lt;= 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(socket, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_write(state-&gt;read, buf-&gt;base, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(buf);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = SSL_accept(state-&gt;ssl);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc == 1) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;on_tls_connection_established(client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc == SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;maybe_flush_ssl_buffer(client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;abort_connection_on_error(client, rc);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          async_accept.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;To handle a read, we need to check, after every read if the act of reading caused us to need to write (client wants to renegotiate the connection, so OpenSSL needs to send data on the connection, which we need to orchestrate) before we can do the actual read. For writes, we need to remember what we are writing, read and write from the network and then repeat our read. This is awkward to do when using synchronous calls, but the amount of state that we have to keep in async and callback driven programming is a lot. I got it working, but it was really hard and mostly a big house of cards.I really didn&#x2019;t like that approach, and decided that I should go about it in a very different way. I realized that I had a very conceptual error in how I approach libuv. Unlike standard async programming in C#, for example, libuv is based on the idea of a loop. In other words, unlike in the code above, you aren&#x2019;t going to setup the next read from the network after each one. That is already done for you. You just call un_read_start() and you&#x2019;ll get served the data from the network whenever it is available. You can also inject your own behaviors into the loop, which make things really interesting for ourselves. Here is the logic, we continuously read from the network and pass the buffer to OpenSSL. We then try to read the decrypted data from SSL_read(). This can fail because we are waiting for more data, and that is fine. We&#x2019;ll be called again when there is such data. However, we&#x2019;ll also add a step at the end of the I/O loop to check if there are any pending buffers that needs to be flushed to the network. For writes, if we fail to do the write because we need to read, we&#x2019;ll register the write to be executed later and wait for the network to send us the read operation.Given that C isn&#x2019;t an OO language, I think that I&#x2019;ll start explaining what is going on from the structs that hold the system together and then the operations that are invoked on them:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          typedef struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* (*create_connection)(uv_tcp_t* connection);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int (*connection_established)(tls_uv_connection_state_t* connection);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;void (*connection_closed)(tls_uv_connection_state_t* connection, int status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int (*read)(tls_uv_connection_state_t* connection, void* buf, ssize_t nread);&#xA;        &#xA;        &#xA;          &#xA;          } connection_handler_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          int connection_write(tls_uv_connection_state_t* state, void* buf, int size);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          typedef struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL_CTX *ctx;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_loop_t* loop;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;connection_handler_t protocol;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          } tls_uv_server_state_t;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          typedef struct tls_uv_connection_state {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_server_state_t* server;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_t* handle;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL *ssl;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO *read, *write;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;struct {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t** prev_holder;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t* next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int in_queue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;size_t pending_writes_count;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_buf_t* pending_writes_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;} pending;&#xA;        &#xA;        &#xA;          &#xA;          } tls_uv_connection_state_t;&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          dtos.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;The first thing to note here is that we have clear layers in the code. We have the connection_handler_t in here, which is a bunch of function pointers that allow higher level code to work with a connection abstraction. The first portion of the code defines the interface that I expect callers to use. As you can see, we have a few functions that deal with creating, establishing and tearing down a connection. We also have the most common operations, reads and writes.The write method is pretty obvious, I think. You give it a buffer and it takes care of writing it to the other side. Note that this is an asynchronous process, and if there are any errors in the process, you&#x2019;ll get them in the connection_closed callback. Reading, on the other hand, is completely out of your hands and will be invoked directly by the lower level code whenever it feels like it. This inversion of control may feel strange for people who are used to invoking I/O directly, but it likely allow you better overall performance.Now that we have the interface, let&#x2019;s build a TLS echo server with it. Here is how that looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          tls_uv_connection_state_t* on_create_connection(uv_tcp_t* connection) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return calloc(1, sizeof(tls_uv_connection_state_t));&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          int on_connection_established(tls_uv_connection_state_t* connection) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return connection_write(connection, &quot;OK\r\n&quot;, 4);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void on_connection_closed(tls_uv_connection_state_t* connection, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;report_connection_failure(status);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          int on_read(tls_uv_connection_state_t* connection, void* buf, ssize_t nread) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return connection_write(connection, buf, nread);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Basic SSL setup&#xA;        &#xA;        &#xA;          &#xA;          const SSL_METHOD* method = TLSv1_2_server_method();&#xA;        &#xA;        &#xA;          &#xA;          SSL_CTX* ctx = SSL_CTX_new(method);&#xA;        &#xA;        &#xA;          &#xA;          SSL_CTX_use_certificate_file(ctx, cert, SSL_FILETYPE_PEM);&#xA;        &#xA;        &#xA;          &#xA;          SSL_CTX_use_PrivateKey_file(ctx, key, SSL_FILETYPE_PEM);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Basic libuv setup&#xA;        &#xA;        &#xA;          &#xA;          uv_loop_t* loop = uv_default_loop();&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          // Define the actual behavior of the server&#xA;        &#xA;        &#xA;          &#xA;          tls_uv_server_state_t server_state = {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;.ctx = ctx,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;.loop = loop,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;.protocol = {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.create_connection = on_create_connection,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.connection_closed = on_connection_closed,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.read = on_read,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;.connection_established = on_connection_established&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          };&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          tls_echo_server.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;You can see that there isn&#x2019;t really much done here. On connection creation, we simply allocate a space for tls_uv_connection_state_t. This is a callback because your code might want to allocate more space for whatever stuff you want to do in the per connection structure. When the connection is established (after the SSL negotiation, etc), you get a chance to initiate things from the server side. In the code above, we simply let the client know that the connection has been successful. From that point on, we simply echo back to the client anything that they send us.The SSL and libuv initialization are the bare bones stuff and not really interesting. The nice bits happen in the end of the snippet, where we define the overall server state and wire together the protocol definition.That is great, but where the part where stuff actually gets done? A note about this code. I&#x2019;m writing this primarily for ease of reading / understanding. I&#x2019;m ignoring a lot of potential errors that in production code I would be obliged to handle. That would significantly complicate the code, but must be done if you want to use this code for anything but understanding the overall concept.Let&#x2019;s finish setting up the libuv machinery before we jump to any other code, shall we. Here is what this looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          uv_tcp_t server;&#xA;        &#xA;        &#xA;          &#xA;          uv_tcp_init(loop, &amp;server);&#xA;        &#xA;        &#xA;          &#xA;          server.data = &amp;server_state;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          struct sockaddr_in addr;&#xA;        &#xA;        &#xA;          &#xA;          uv_ip4_addr(&quot;0.0.0.0&quot;, DEFAULT_PORT, &amp;addr);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uv_tcp_bind(&amp;server, (const struct sockaddr*)&amp;addr, 0);&#xA;        &#xA;        &#xA;          &#xA;          int r = uv_listen((uv_stream_t*)&amp;server, DEFAULT_BACKLOG, on_new_connection);&#xA;        &#xA;        &#xA;          &#xA;          if (r) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;fprintf(stderr, &quot;Listen error %s\n&quot;, uv_strerror(r));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          uv_prepare_t after_io;&#xA;        &#xA;        &#xA;          &#xA;          after_io.data = &amp;server_state;&#xA;        &#xA;        &#xA;          &#xA;          uv_prepare_init(loop, &amp;after_io);&#xA;        &#xA;        &#xA;          &#xA;          uv_prepare_start(&amp;after_io, check_if_need_to_flush_ssl_state);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          uv_run(loop, UV_RUN_DEFAULT);&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          eventloop.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is fairly straightforward. We are listening to a socket and binding any incoming connection to the on_new_connection() callback. There is also the after_io preparation stuff, which we use to handle delayed operations (I&#x2019;ll talk about this later). For now, I want to focus on accepting new connections and processing them.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void on_new_connection(uv_stream_t *server, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;report_connection_failure(status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_server_state_t* server_state = server-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_t *client = (uv_tcp_t*)malloc(sizeof(uv_tcp_t));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_tcp_init(server_state-&gt;loop, client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;status = uv_accept(server, (uv_stream_t*)client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status != 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_close((uv_handle_t*)client, NULL);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;report_connection_failure(status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = server_state-&gt;protocol.create_connection(client);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;ssl = SSL_new(server_state-&gt;ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL_set_accept_state(state-&gt;ssl);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;server = server_state;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;handle = client;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;read = BIO_new(BIO_s_mem());&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;write = BIO_new(BIO_s_mem());&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_set_nbio(state-&gt;read, 1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_set_nbio(state-&gt;write, 1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;SSL_set_bio(state-&gt;ssl, state-&gt;read, state-&gt;write);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;client-&gt;data = state;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (server_state-&gt;protocol.connection_established(state) == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_read_start((uv_stream_t*)client, alloc_buffer, handle_read);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          on_new_connection.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is quite a lot that is going on this method, and not all of it is obvious. First, we handle accepting the connection and binding its input to the libuv event loop. Then we create a connection and setup some of the SSL details.We create an SSL instance for this connection and create two Basic I/O instances that reside in memory. One for the incoming stream and one for the outgoing stream. We&#x2019;ll be using them to pass data through the OpenSSL encryption, negotiation, etc. We also mark this as a server instance. Once that is done, we invoke the connection_established() callback and then tell the libuv event loop to start pumping data from this socket to the handle_read() callback. For now, I want to ignore the connection_established() callback, it isn&#x2019;t important to understand the flow of the code at this point (but we&#x2019;ll circle back to it). It is important to understand that by the time we call to this callback, the connection is ready to use and can receive and send data. Well, not receive, because we don&#x2019;t provide a way to pull data from the connection, we&#x2019;ll be pushing that data to the provided callback. This will happen by libuv calling to the handle_read() method whenever there is data on the socket. Here is how we handle this:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void handle_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = client-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;BIO_write(state-&gt;read, buf-&gt;base, nread);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (1)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int rc = SSL_read(state-&gt;ssl, buf-&gt;base, buf-&gt;len);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc &lt;= 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;state-&gt;server-&gt;protocol.connection_closed(state, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// need to read more, we&#x27;ll let libuv handle this&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (state-&gt;server-&gt;protocol.read(state, buf-&gt;base, rc) == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// protocol asked to close the socket&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(buf-&gt;base);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          handle_read.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;When libuv calls us with some data, we write this data into the read buffer for OpenSSL and then call SSL_read() to get the unencrypted data that was sent to us. There are some issues here. First, the SSL/TLS has framing, and the amount of data that your read from the network isn&#x2019;t going to be the amount of unencrypted bytes that you get in the end. Another issue is that we need to be careful about re-negotiations, which are generally permitted at any point, but can cause a read to do a write (and may require a write to read).You might have noticed that this code contains absolutely no indication of this. Instead, we call SSL_read() to get the plaintext data from OpenSSL. We continue to do this until we get an error from SSL_read(). This can be either a real error or an indication that we need to read more from the network. Whenever I get some bytes from OpenSSL, I pass them directly to the read() callback that was provided to us. If you examine the code carefully, you&#x2019;ll see that when we run out of data to read, we try to flush the SSL state of the connection. Let&#x2019;s look at what that method do:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void maybe_flush_ssl(tls_uv_connection_state_t* state) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (state-&gt;pending.in_queue)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (BIO_pending(state-&gt;write) == 0 &amp;&amp; state-&gt;pending.pending_writes_count &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.next = state-&gt;server-&gt;pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (state-&gt;pending.next != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;pending.next-&gt;pending.prev_holder = &amp;state-&gt;pending.next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.prev_holder = &amp;state-&gt;server-&gt;pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.in_queue = 1;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;server-&gt;pending_writes = state;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          maybe_flush_ssl.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;We check if the connection is already in the queue and if it isn&#x2019;t we check whatever it should be added. There are two reasons why a connection should be added to the pending_writes queue. First, we may have data buffered in the write buffer of the SSL connection, which needs to be sent over the network. Or, we may have failed writes that we need to retry after we read more data into the SSL connection.You might notice that we are doing some pointer hopping in the process of registering the connection in the queue. This is basically using a double linked list and will be important later. If we are putting stuff into a queue, what is going to be reading from this queue?Remember that when we setup the libuv stuff, we used the after_io prepare handle? This is called as the first step in the loop, just before we check if there is any I/O to process. This give us the chance to deal with the confusing read on write and write on read nature of OpenSSL in a more structure manner. Let&#x2019;s first look at the code, and then see how this all play together.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void complete_write(uv_write_t* r, int status) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t* state = r-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(r-&gt;write_buffer.base);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;free(r);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (status &lt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;server-&gt;protocol.connection_closed(state, status);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          void flush_ssl_buffer(tls_uv_connection_state_t* cur) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = BIO_pending(cur-&gt;write);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_buf_t buf = uv_buf_init(malloc(rc), rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;BIO_read(cur-&gt;write, buf.base, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_write_t* r = calloc(1, sizeof(uv_write_t));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;r-&gt;data = cur;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;uv_write(r, (uv_stream_t*)cur-&gt;handle, &amp;buf, 1, complete_write);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          write.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is what actually handle writing to the network. We take data from the SSL write buffer and send it to the network. Once the write is done, we free buffers that were held for this operation and check if there was any issue with the write (if so, we abort the connection). This is all being driven by this method, which is called before we check for available I/O.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          void check_if_need_to_flush_ssl_state(uv_prepare_t* handle) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_server_state_t* server_state = handle-&gt;data;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;tls_uv_connection_state_t** head = &amp;server_state-&gt;pending_writes;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (*head != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;tls_uv_connection_state_t* cur = *head;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;flush_ssl_buffer(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (cur-&gt;pending.pending_writes_count == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;remove_connection_from_queue(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// here we have pending writes to deal with, so we&#x27;ll try stuffing them&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// into the SSL buffer&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;int used = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;for (size_t i = 0; i &lt; cur-&gt;pending.pending_writes_count; i&#x2B;&#x2B;)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;int rc = SSL_write(cur-&gt;ssl,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_buffer[i].base,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_buffer[i].len);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;used&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;rc = SSL_get_error(cur-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc == SSL_ERROR_WANT_WRITE) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;flush_ssl_buffer(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;i--;// retry&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;continue;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;server_state-&gt;protocol.connection_closed(cur, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;abort_connection_on_error(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.in_queue = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// we are waiting for reads from the network&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// we can&#x27;t remove this instance, so we play&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// with the pointer and start the scan/remove &#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;// from this position&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;head = &amp;cur-&gt;pending.next;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;flush_ssl_buffer(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (used == cur-&gt;pending.pending_writes_count) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;remove_connection_from_queue(cur);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;else {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_count -= used;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;memmove(cur-&gt;pending.pending_writes_buffer,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;cur-&gt;pending.pending_writes_buffer &#x2B; sizeof(uv_buf_t)*used,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;sizeof(uv_buf_t) * cur-&gt;pending.pending_writes_count);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          check_if_need_to_flush_ssl_state.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is quite a lot that is going on in here. First, we iterate through the pending writes for all the connections we have. For each of the connections, we flush the SSL buffer and then check if we have pending writes to process. If we don&#x2019;t, we can remove the connection from the queue, our work is done. If we do have any pending writes, we need to handle them.I do that by using SSL_write(), which will write them into in memory buffer. I continue doing so until one of the following happens:I run out of pending writes.I run out of buffer space and need to flush.I need to re-negotiate and need to read from the networkIn the first case, I&#x2019;ve successfully pushed the data to the SSL buffer, so I can call flush_ssl_buffer() and then remove the connection from the queue. In the second case, I&#x2019;ll flush the SSL write buffer and try again.However, in the last case, I&#x2019;m just aborting the writes. I need to do a read, and that will be handled on the next iteration of the libuv loop. There is some bookkeeping there to make sure that if we successfully wrote data into the SSL buffer, we won&#x2019;t be writing that again, but this is pretty much it. You&#x2019;ll note that I&#x2019;m playing games with pointers to pointers there to get clean code on the code that consumes the queue but allow me to skip one of the steps in the linked list without removing it from the list. This is pretty much it, I have to say. We now have a system where both writes and reads work in conjunction to get the proper SSL behavior, even when we have renegotiation going on.One thing you&#x2019;ll not find in this code is a call to SSL_accept(), or indeed any behavior related to explicitly managing the SSL state. I&#x2019;m letting OpenSSL handle all of that are rely on the fact that I SSL_write() and SSL_read() will handle renegotiations on their own for me.Let&#x2019;s do a simple walk through of what is going on with the connection of the TLS echo server.On connection established (and before we read anything from the network), we call to connection_write():&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          int connection_write(tls_uv_connection_state_t* state, void* buf, int size) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc = SSL_write(state-&gt;ssl, buf, size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;rc = SSL_get_error(state-&gt;ssl, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc == SSL_ERROR_WANT_WRITE) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;flush_ssl_buffer(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;rc = SSL_write(state-&gt;ssl, buf, size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc &gt; 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (rc != SSL_ERROR_WANT_READ) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;state-&gt;server-&gt;protocol.connection_closed(state, rc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;abort_connection_on_error(state);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;return 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;// we need to re negotiate with the client, so we can&#x27;t accept the write yet&#xA;        &#xA;        &#xA;          &#xA;          &#x9;// we&#x27;ll copy it to the side for now and retry after the next read&#xA;        &#xA;        &#xA;          &#xA;          &#x9;uv_buf_t copy = uv_buf_init(malloc(size), size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;memcpy(copy.base, buf, size);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.pending_writes_count&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.pending_writes_buffer = realloc(state-&gt;pending.pending_writes_buffer,&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;sizeof(uv_buf_t) * state-&gt;pending.pending_writes_count);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;state-&gt;pending.pending_writes_buffer[state-&gt;pending.pending_writes_count - 1] = copy;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;maybe_flush_ssl(state);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return 1;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          connection_write.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;This is fairly straightforward. We try to write to the buffer, and if we are successful, great. The check_if_need_to_flush_ssl_state() will take care of actually sending that to the client.If the write buffer is full, we empty it and try again. The interesting thing happen when we need to read in order to complete this write. In this case, we copy the data to write and store it on the side, then we proceed normally and wait or the libuv to deliver the next read buffer for this connection. When that is done, we&#x2019;ll be sending the deferred write to the client.It may be easier to explain the flow with a real example. When a new connection comes into the server, we create a new SSL context and then we call:connection_write(connection, &quot;OK\r\n&quot;, 4);This is the very first time that we actually interacts with the SSL instance and the call to SSL_write() is going to fail (because we haven&#x2019;t established the SSL connection) with a SSL_ERROR_WANT_READ message. In response for this, we&#x2019;ll copy the buffer we got and place it into the pending_writes of this connection. We also start listening to new data on the connection. The client will send the ClientHello message, which we&#x2019;ll read and then feed into the SSL instance. That will cause us to write the SeverHello to the in memory buffer. When the check_if_need_to_flush_ssl_state() will be called, it will flush that message to the client. Eventually, we&#x2019;ll get the connection established and at this point we&#x2019;ll be sending the deferred write to the client.There are a bunch of other details, but they aren&#x2019;t crucial to understanding this approaching. You can find the whole code sample here. I&#x2019;ll reiterate again that it doesn&#x2019;t have proper error handling, but it is less than 350 lines of C code that does something that is quite nice and expose an API that should be quite interesting to consume. I&#x2019;m really interested in feedback on this blog post, both on whatever this approach make any sense and what do you think about the code.</p>
        </article>
        <article id="article-2052">
            <a href="https://ardalis.com/analyzing-404s-with-google-analytics/" target="_blank">
                <h2 class="title mb-6" id="article-2052">Analyzing 404s with Google Analytics</h2>
            </a>
            <p class="mb-2">by Ardalis</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I&#x27;ve been wanting to analyze broken links coming into my site so that I could add 301 redirects if necessary. I figured I could probably use&#x2026;Keep Reading &#x2192;</p>
        </article>
        <article id="article-2053">
            <a href="https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/" target="_blank">
                <h2 class="title mb-6" id="article-2053">Why is string.GetHashCode() different each time I run my program in .NET Core?</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 11, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I discuss string.GetHashCode(), why it&#x27;s randomised, and hash-attacks. I also provide a deterministic implementation you can use when it&#x27;s safe.&#x2026;</p>
        </article>
        <article id="article-2054">
            <a href="https://ayende.com/blog/185409-B/refactoring-c-code-do-we-need-a-security-review" target="_blank">
                <h2 class="title mb-6" id="article-2054">Refactoring C Code</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 10, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">Now that I&#x2019;m actually doing real work with input from the network, I thought it would be a good time to stop and take a look at whatever I&#x2019;m exposing stuff. C is known for buffer overruns and security issues, and compounding that with network software that accepts untrusted input, that is something that we should take a look at.The first line of defense is to use Valgrind and see if it reports any errors. It reported a memory leak (I didn&#x2019;t free the command&#x2019;s buffer, it seemed), which was easy to fix. But it also reported a much more serious issue:Conditional jump or move depends on uninitialised value(s)&#xA;This is not something that I wanted to see. The nice thing about Valgrind is that it prints a nice stack trace, even if in this case, it didn&#x2019;t make any sense. It was deep inside the strcmp() function, which I assume is fine. I dug around on how this warning in implemented before I got what was going on. Basically, I was handing strcmp memory that was never initialized, which caused this warning.Here is the relevant piece of the code:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          struct cmd* read_message(struct connection * c) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc, to_read, to_scan = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;do&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (c-&gt;used_buffer &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;printf(&quot;scan: %i, used: %i&quot;, to_scan, c-&gt;used_buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;char* final = strnstr(c-&gt;buffer &#x2B; to_scan, &quot;\r\n\r\n&quot;, c-&gt;used_buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (final != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;struct cmd* cmd = parse_command(c, c-&gt;buffer, final - c-&gt;buffer &#x2B; 2/*include one \r\n*/);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;c-&gt;used_buffer -= (final &#x2B; 4) - c-&gt;buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;memmove(c-&gt;buffer, final &#x2B; 4, c-&gt;used_buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;return cmd;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;to_scan = c-&gt;used_buffer - 3 &lt; 0 ? 0 : c-&gt;used_buffer - 3;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;to_read = MSG_SIZE - c-&gt;used_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (to_read == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;push_error(EINVAL, &quot;Message size is too large, after 8KB, &quot;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;&quot;couldn&#x27;t find \r\n separator, aborting connection.&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return NULL;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;rc = connection_read(c, c-&gt;buffer &#x2B; c-&gt;used_buffer, to_read);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return NULL; // broken connection, probably&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;c-&gt;used_buffer &#x2B;= rc;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;} while (1);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          read_message.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;Take a look and see if you can see the error. It might be helpful if I told you that this is an error that would only be raised if I&#x2019;m writing to the stream manually, not via any client API.It took me a while to figure out what was going on. This piece of code is meant to be called multiple times, building a single buffer (of up to 8KB in size) from potentially multiple network reads. I had a small optimization there to avoid scanning from the beginning of the string and just scan from where we already scanned. This is the to_scan variable. As it turned out, this darling had nasty consequences.Look at line 7 in the code sample, I&#x2019;m telling strnstr() to start reading from the string from the specified position, but I pass the original size. I read past the end of the buffer. Likely still in my own memory, but that would almost certainly have caused issues down the road, and it is easy to construct a sequence of operations that would cause me to thing that a message is over when I haven&#x2019;t finished actually sending it (reading the \r\n\r\n divider from a previous message).Once that was fixed, it was green across the board. But I&#x2019;m not a C programmer, and I&#x2019;m not sure if there are other stuff that I should be looking at. I&#x2019;m using string functions with explicit length, doing proper error checking, etc. Code review for this hasn&#x2019;t show any issue, but I&#x2019;m sure that there are more stuff there. The actual code is about 100 lines of C code that I think is fairly straightforward. I would be very happy to hear what else I can do to this piece of code to increase my confidence in it.</p>
        </article>
        <article id="article-2055">
            <a href="https://www.meziantou.net/inlining-a-stylesheet-using-a-taghelper-in-asp-net-core.htm" target="_blank">
                <h2 class="title mb-6" id="article-2055">Inlining a stylesheet using a TagHelper in ASP.NET Core</h2>
            </a>
            <p class="mb-2">by G&#xE9;rald Barr&#xE9;</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 10, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">When you have a very tiny stylesheet, it may be more performant to inline it directly in the page. Indeed, it will avoid one network call, and the layout may be blocked until the browser gets the response of this call. If the stylesheet is very small you may not care about caching the file on the c</p>
        </article>
        <article id="article-2056">
            <a href="https://ayende.com/blog/185378-C/refactoring-c-code-implementing-parsing" target="_blank">
                <h2 class="title mb-6" id="article-2056">Refactoring C Code</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 07, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">So far, I did a whole lot of work around building the basic infrastructure of just building a trivial echo server with SSL. But the protocol I have in mind is a lot more complex, let&#x2019;s get started with actually implementing the parsing of messages.To start with, we need to implement parsing of lines. In C, this is actually a decidedly non trivial operation, because you need to read the data from the network into someplace and parse it. This area is rife with errors, so that is going to be fun. Here is a simple raw message:GET employees/1-A employees/2-BTimeout: 30Sequence: 293Include: ReportsToThe structure goes:CMD args1 argN\r\nAnd then header lines with:Name: value\r\nThe final end of the message is \r\n\r\n.To make things simple for myself, I&#x2019;m going to define the maximum size of a message as 8KB (this is the common size in HTTP as well). Here is how I decided to represent it in memory:The key here is that I want to minimize the amount of work and complexity that I need to do. That is why the entire message is limited to 8KB. I&#x2019;m also simplifying how I&#x2019;m going to be handling things from an API perspective. All the strings are actually C strings, null terminated, and I&#x2019;m using the argv, argc convention for naming, just like in the main function. This means that I can simply read from the network until I find a &#x201C;\r\n\r\n&#x201D; in there. Here is how I do this:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          struct cmd* read_message(struct connection * c) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;int rc, to_read, to_scan = 0;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;do&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// first, need to check if we already&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;// read the value from the network&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (c-&gt;used_buffer &gt; 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;char* final = strnstr(c-&gt;buffer &#x2B; to_scan, &quot;\r\n\r\n&quot;, c-&gt;used_buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;if (final != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;struct cmd* cmd = parse_command(c, c-&gt;buffer, final - c-&gt;buffer &#x2B; 2/*include one \r\n*/);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;// now move the rest of the buffer that doesn&#x27;t belong to this command &#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;// adding 4 for the length of the msg separator (\r\n\r\n)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;c-&gt;used_buffer -= (final &#x2B; 4) - c-&gt;buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;memmove(c-&gt;buffer, final &#x2B; 4, c-&gt;used_buffer);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;return cmd;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;to_scan = max(c-&gt;used_buffer - 3, 0);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;to_read = MSG_SIZE - c-&gt;used_buffer;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (to_read == 0) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;push_error(EINVAL, &quot;Message size is too large, after 8KB, &quot;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;&#x9;&quot;couldn&#x27;t find \r\n separator, aborting connection.&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return NULL;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;rc = connection_read(c, c-&gt;buffer &#x2B; c-&gt;used_buffer, to_read);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (rc == 0)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;return NULL; // broken connection, probably&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;c-&gt;used_buffer &#x2B;= rc;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;} while (1);&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          read_message.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;There is a bit of code here, but the gist of it is pretty simple. The problem is that I need to handle partial state. That is, a single message may come in two separate packets, or multiple messages may come in a single packet. I don&#x2019;t have a way to control that, so I need to be careful about tracking past state. The connection has a buffer that is used to hold the state in memory, whose size is large enough to hold the largest possible message. I&#x2019;m reading from the network to a buffer and then scanning to find the message separator.If I couldn&#x2019;t find it, I&#x2019;m recording the last location where it could be starting, and then issuing another network read and will try searching for \r\n\r\n again. Once that is found, the code will call to the parse_commnad() method that operates over the entire command in memory (which is much easier). With that done, my message parsing is actually quite easy, from a conceptual point of view, although I&#x2019;ll admit that C make it a bit long.&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          static struct cmd* parse_command(struct connection* c, char* buffer, size_t len) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char* line_ctx = NULL, *ws_ctx = NULL, *line, *arg;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;struct cmd* cmd = NULL;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;char* copy = malloc(len&#x2B;1);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (copy == NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;push_error(ENOMEM, &quot;Unable to allocate command memroy&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;goto error_cleanup;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;// now we need to have our own private copy of this&#xA;        &#xA;        &#xA;          &#xA;          &#x9;memcpy(copy, buffer, len);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;copy[len] = 0; // ensure null terminator!&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;cmd = calloc(1, sizeof(struct cmd));&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (cmd == NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;push_error(ENOMEM, &quot;Unable to allocate command memroy&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;goto error_cleanup;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;line = strtok_s(copy, &quot;\r\n&quot;, &amp;line_ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (line == NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;push_error(EINVAL, &quot;Unable to find \r\n in the provided buffer&quot;);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;goto error_cleanup;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;arg = strtok_s(line, &quot; &quot;, &amp;ws_ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (arg == NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;push_error(EINVAL, &quot;Invalid message command line: %s&quot;, line);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;goto error_cleanup;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;do&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;argc&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;argv = realloc(cmd-&gt;argv, sizeof(char*) * cmd-&gt;argc);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;argv[cmd-&gt;argc - 1] = arg;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;arg = strtok_s(NULL, &quot; &quot;, &amp;ws_ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;} while (arg != NULL);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;while (1)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;{&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;line = strtok_s(NULL, &quot;\r\n&quot;, &amp;line_ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (line == NULL)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;break;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;arg = strtok_s(line, &quot;:&quot;, &amp;ws_ctx);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;if (arg == NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;push_error(EINVAL, &quot;Header line does not contain &#x27;:&#x27; separator: %s&quot;, line);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;goto error_cleanup;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;while (*ws_ctx != 0 &amp;&amp; *ws_ctx == &#x27; &#x27;)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;&#x9;ws_ctx&#x2B;&#x2B;; // skip initial space&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;headers_count&#x2B;&#x2B;;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;headers = realloc(cmd-&gt;headers, sizeof(struct header) *cmd-&gt;headers_count);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;headers[cmd-&gt;headers_count - 1].key = arg;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd-&gt;headers[cmd-&gt;headers_count - 1].value = ws_ctx;&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return cmd;&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;          error_cleanup:&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (copy != NULL)&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;free(copy);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;if (cmd != NULL) {&#xA;        &#xA;        &#xA;          &#xA;          &#x9;&#x9;cmd_drop(cmd);&#xA;        &#xA;        &#xA;          &#xA;          &#x9;}&#xA;        &#xA;        &#xA;          &#xA;          &#x9;return NULL;&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          parse_command.c&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I&#x2019;m copying the memory from the network buffer to my own location, this is important because the read_message() function will overwrite it in a bit, and it also allow me to modify the memory more easily, which is required for using strtok(). This basically allow me to tokenize the message into its component parts. First on a line by line basis (with splitting on space for the first line and then treating this as headers lines).I added the ability to reply to a command, which means that we are pretty much almost done. You can see the current state of the code here.</p>
        </article>
        <article id="article-2057">
            <a href="https://ayende.com/blog/185249-C/cost-oriented-programming-in-the-cloud" target="_blank">
                <h2 class="title mb-6" id="article-2057">Cost oriented programming in the cloud</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 06, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">You might be familiar with Moore&#x2019;s law, which states that the number of transistors in a dense integrated circuit doubles about every two years. In effect, that performance doubles every 24 months. For many years, that has certainly held true. But that hasn&#x2019;t been the case for the past 10 years or so. Even when Moore&#x2019;s law held true, there was a snag. Wirth&#x2019;s law is also in effect (as an aside, read his article &#x201C;A Plea for Lean Software&#x201D;, 23 years, and it holds true today) and Wirth&#x2019;s law states that software is slower quicker than hardware is becoming faster. It&#x2019;s good to be a software developer, because even when the CPU clock speed doesn&#x2019;t jump all the time, we still get more CPUs to play with. A common approach to handle performance issues today is just to throw more parallelism at the problem until it shuts up. To a certain extent, this make a perfect economic sense. In the calculus between developers&#x2019; salaries and the cost of hardware, you&#x2019;ll usually find that buying a couple extra servers is drastically cheaper than spending another 6 months improving the performance of the system. Jeff Atwood wrote about the topic a decade ago and I think that he is still very much correct, to a degree. There are other factors to consider, which is the overhead over time and in particular in the cloud. One of the major factors to take into account here is that when you are running in the cloud, you aren&#x2019;t running on your servers and you are charged on usage. That can change the math by quite a bit.For example, if I bought a couple of servers, the number of IO operations that I make is pretty much meaningless to me. If I hitting the disk ten times a second or ten thousands times a second, I&#x2019;m paying the same cost. Oh, sure, I might need to buy a better hard disk to get 10,000 IOPS, but that is a one time cost, and usually not that meaningful in the grand scheme of things. But when you are on the cloud, getting higher IOPS cost more, and it cost more over time. In the same sense, in my data center, the cost of querying a database is zero. In the cloud, you will typically be charged some (miniscule) amount on a per query basis. Nothing to worry about, except that your software still work according to Wirth&#x2019;s law, so you are making more queries than you should, which means that you are charged for each and every one of them. I used to make my living by being a database performance consultant. I would go to a customer, look at how they are using their database and optimize the access pattern. It was common to see 90%&#x2B; savings in the number of queries for common operations. I was doing that because that directly translated to better responsiveness of the application. Applications that respond faster are more pleasant to use and there are numerous studies about faster applications generating higher revenues. I remember talking to clients and explaining to them why they should invest in the overall performance of the application before they hit the total resource depletion that would take them down.Today, in the cloud, I would have a much simpler task. Let&#x2019;s assume a simple application using CosmosDB, as an example. With 200 page views / sec on the site, and each page view generating 80 requests to the database, that gives us a total of 16,000 requests a second, which translates to an end of the month bill of about 10,000$. I&#x2019;m using the 80 queries / page view as a reasonable low ball estimate, mind. Drupal, for example, does 300 &#x2013; 400 queries per page view and it is easy to get to these numbers without paying attention. Dropping the number of queries per page to 10 (which is usually pretty easy to do with proper queries, attention to details and some caching) gives you a database bill that is around than 1,000$.Over the span of a year, that is enough to pay a full time developer that can go and find other places where your software can be improved. And unlike before, you don&#x2019;t need to justify with studies or any indirect causation. You can point directly to the bottom line in an invoice and show how much money is saved.</p>
        </article>
        <article id="article-2058">
            <a href="https://andrewlock.net/secure-secrets-storage-for-asp-net-core-with-aws-secrets-manager-part-2/" target="_blank">
                <h2 class="title mb-6" id="article-2058">Secure secrets storage for ASP.NET Core with AWS Secrets Manager (Part 2)</h2>
            </a>
            <p class="mb-2">by Andrew Lock</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 06, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">In this post I show how to control which secrets are loaded from AWS Secrets Manager when your ASP.NET Core app start.&#x2026;</p>
        </article>
        <article id="article-2059">
            <a href="https://ayende.com/blog/185377-C/debugging-security-errors" target="_blank">
                <h2 class="title mb-6" id="article-2059">Debugging security errors</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 05, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">&#x201C;I&#x2019;m getting a 403 Forbidden error&#x201D; is one of the more annoying things to debug. Something, somewhere, in a distributed system, has decided that a request is not authorized and blocked it.In RavenDB 3.5, we supported OAuth and Windows Authentication to authenticate clients talking to RavenDB. That meant that we had to field support questions exactly like the one above. That was not fun. First of all, there seem to be an inclination in the security community to hide errors really well. &#x201C;I don&#x2019;t like you because the difference between our clocks, let&#x2019;s send an EPERM to this socket and close it, and if I&#x2019;m feeling nice, log it to /var/logs/obscure/dev/null&#x201D;. I have scars from trying to work out &#x201C;Why doesn&#x2019;t Windows Auth work for this user&#x201D; that involved talking to a DBA who wasn&#x2019;t neither the domain admin nor even aware of the domain topology in the organization (Fallacies: There is one administrator). At one point, we had a production issue that had RavenDB refusing all access because Windows couldn&#x2019;t validate credentials because of a disconnect in a linked domain that was down for scheduled maintenance and the credential cache expired.When we designed RavenDB 4.0, we decided that for security, we need something that would be debuggable. That means:Secured &#x2013; that goes without saying, if it is security measure that is debuggable but isn&#x2019;t actually secured&#x2026;Rely only on two parties &#x2013; the client &amp; server in each connection. Provide enough information to solve the problemWe selected TLS / SSL for this, with client certificate as the authentication mechanism. This answers the first requirement, because TLS has been analyzed enough that I&#x2019;m certain that it is secured. It is also well known and familiar to administrators. TLS uses PKI, so it isn&#x2019;t technically a two parties solution, you may have to deal with certificates revocation, trust chains, etc. But those are well understood and you have really good errors on those. On the client certificate authentication side, however, we require that we&#x2019;ll have the actual list of trusted certificates, so there is no need to check anywhere else.We have also taken debuggable security a couple of steps further. For example, we&#x2019;ll accept an unsecured connection and let it establish itself. Then send a single message down the line, explaining why we aren&#x2019;t going to use it.In practice, this works great. Take a look at this stack overflow question, which shows the following error:Given just the information in the post and the error from RavenDB, it was easy to figure out that the client certificate hasn&#x2019;t been registered and that this is why RavenDB is refusing access.I consider this a major success.</p>
        </article>
        <article id="article-2060">
            <a href="https://ayende.com/blog/185345-C/refactoring-c-code-multi-platform-and-valgrind" target="_blank">
                <h2 class="title mb-6" id="article-2060">Refactoring C Code</h2>
            </a>
            <p class="mb-2">by Oren Eini</p>
            <p class="mb-6 flex gap-1.5">
                    <span>
                        <svg width="1.25rem" fill="currentColor" viewBox="0 0 24 24"
                             xmlns="http://www.w3.org/2000/svg"><path
                                xmlns="http://www.w3.org/2000/svg"
                                d="M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V11.5858L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3166 16.0976 14.6834 16.0976 14.2929 15.7071L11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12V7C11 6.44772 11.4477 6 12 6Z"></path></svg>
                    </span>
                posted on: December 04, 2018
            </p>
            <p class="max-w-full w-full line-clamp-5 text-justify mb-20">I decided that this is time to take my network protocol and make it cross platform, so I tried to compile it on the Linux subsystem for Windows. As an aside, the fact that I could edit everything in Visual Studio while compiling using GCC and having immediate feedback is amazing, given the usual workflow that this entails. And I would very much like to hear about an IDE that is comparable to Visual Studio out there.I got to say, the situation for dependencies on C/C&#x2B;&#x2B; is flat out horrible. I&#x2019;m depending on OpenSSL for this code, and I have used VCPkg for actually setting up the dependency. On WSL, on the other hand, the OpenSSL packages are from 2014(!), so they were incompatible. I re-compiled the lastest stable on WSL and tried to get it to work. It didn&#x2019;t, first it didn&#x2019;t put the new code in the right place and when I forced it to use the right paths, it failed with missing methods. It looks like I&#x2019;m spoiled from the point of backward compatibility, but several methods has been deprecated or flat our removed.I fixed that stuff only to find out that what the WSL version requires is actually newer than what the OpenSSL version I have on the Winodws machine has. I could compile the latest on Windows as well but for now it was just easier to conditional compile the stuff that I needed. I find it sad, but I want to get things done.After a lot of grunt work, I&#x2019;m happy to say that this looks like it is actually working. You can find the code for that in this link. I also wrote a small C# code to connect to the server, which looks like:&#xA;    &#xA;      &#xA;        &#xA;  &#xA;    &#xA;    &#xA;&#xA;        &#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;    &#xA;&#xA;    &#xA;      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.&#xA;      Learn more about bidirectional Unicode characters&#xA;    &#xA;&#xA;&#xA;              Show hidden characters&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;    &#xA;&#xA;&#xA;&#xA;  &#xA;        &#xA;          &#xA;          var tcpClient = new TcpClient();&#xA;        &#xA;        &#xA;          &#xA;          await tcpClient.ConnectAsync(IPAddress.Loopback, 4433);&#xA;        &#xA;        &#xA;          &#xA;          using (var stream = tcpClient.GetStream())&#xA;        &#xA;        &#xA;          &#xA;          using (var ssl = new SslStream(stream, leaveInnerStreamOpen: false,&#xA;        &#xA;        &#xA;          &#xA;              userCertificateValidationCallback: &#xA;        &#xA;        &#xA;          &#xA;                  (object sender, X509Certificate certificate, &#xA;        &#xA;        &#xA;          &#xA;                   X509Chain chain, SslPolicyErrors sslPolicyErrors) =&gt; true&#xA;        &#xA;        &#xA;          &#xA;                   ))&#xA;        &#xA;        &#xA;          &#xA;          {&#xA;        &#xA;        &#xA;          &#xA;              var cert = new X509CertificateCollection();&#xA;        &#xA;        &#xA;          &#xA;              cert.Add(new X509Certificate2(@&quot;example.p12&quot;));&#xA;        &#xA;        &#xA;          &#xA;              await ssl.AuthenticateAsClientAsync(&quot;example.com&quot;, cert, checkCertificateRevocation: false);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              var writer = new StreamWriter(ssl);&#xA;        &#xA;        &#xA;          &#xA;              var reader = new StreamReader(ssl);&#xA;        &#xA;        &#xA;          &#xA;          &#xA;&#xA;        &#xA;        &#xA;          &#xA;              while (true)&#xA;        &#xA;        &#xA;          &#xA;              {&#xA;        &#xA;        &#xA;          &#xA;                  Console.WriteLine(reader.ReadLine());&#xA;        &#xA;        &#xA;          &#xA;                  var str = Console.ReadLine();&#xA;        &#xA;        &#xA;          &#xA;                  writer.WriteLine(str);&#xA;        &#xA;        &#xA;          &#xA;                  writer.Flush();&#xA;        &#xA;        &#xA;          &#xA;              }&#xA;        &#xA;        &#xA;          &#xA;          }&#xA;        &#xA;  &#xA;&#xA;&#xA;&#xA;    &#xA;&#xA;  &#xA;&#xA;&#xA;      &#xA;      &#xA;        view raw&#xA;        &#xA;          network-client.cs&#xA;        &#xA;        hosted with &#x2764; by GitHub&#xA;      &#xA;    &#xA;&#xA;I gotta admit, the difference in the lines of code and complexity between the two code bases is pretty staggering. I have to admit, I had an ulterior motive behind wanting to run on Linux, I wanted to see just how badly I managed to manage memory in this short bit of C code, and Valgrind is one of the more common tools to do that. Of course, Valgrind doesn&#x2019;t run on WSL, so I had to build that from source as well. I have to say, I was really careful about the actual memory usage and freeing everything. Valgrind was still able to find an issue within the first two minutes of me running it. I got to say, I&#x2019;m really impressed. Here is the leak:As you can see, this is happening because I&#x2019;m using client certificates and it is deep inside OpenSSL (narrator voice: it wasn&#x2019;t a problem with OpenSSL).This was a bit of a problem to try to figure out, because I was really careful and properly match each allocation call with the call to release it (in this case, SSL_new() with SSL_free()). I went over the code to establish and tear down a connection many times, but couldn&#x2019;t see any problem.The issue here is that Valgrind, in this case, shows me where the memory was allocate, but the leaks is actually elsewhere. OpenSSL implements reference counting for many objects, and as part of the client certificate usage I&#x2019;m getting the client&#x2019;s certificate an examining it. The act of getting the certificate increment the ref count on that certificate. I have to explicitly release that certificate once I&#x2019;m done with it. Naturally Valgrind wasn&#x2019;t able to figure all of that and just told me that I actually have a leak.Lesson learned, look at the allocation stack, but don&#x2019;t marry it or assume it is known correct. Here is the latest drop of code, which is able to pass Valgrind with no leaks detected.</p>
        </article>
        <div class="button flex justify-between">
            <a href="205.html"><span class="back arrow"></span></a>

            <a href="207.html"><span class="next arrow"></span></a>
        </div>
    </section>
</main>
<footer
    class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold text-gray-600 dark:text-gray-400 sm:flex-row sm:justify-between sm:text-xs">
    <div class="me-0 sm:me-4">
        <div class="flex flex-wrap items-end gap-x-2">
            <ul class="flex flex-1 items-center gap-x-2 sm:flex-initial">
                <li class="flex">
                    <p class="flex items-end gap-2 justify-center flex-wrap	">Â© Relatively General
                        .NET 2025<span
                            class="inline-block">&nbsp;ðŸš€&nbsp;Theme: Astro Cactus</span>

                        <a class="inline-block sm:hover:text-link" href="https://github.com/chrismwilliams/astro-cactus"
                           rel="noopener noreferrer " target="_blank">
                            <svg width="1em" height="1em" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6"
                                 focusable="false" data-icon="mdi:github">
                                <symbol id="ai:mdi:github">
                                    <path fill="currentColor"
                                          d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"></path>
                                </symbol>
                                <use xlink:href="#ai:mdi:github"></use>
                            </svg>
                            <span class="sr-only">Github</span>
                        </a>
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <nav aria-label="More on this site" class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500">
        <a class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="index.html"> Home </a><a
            class="px-4 py-2 sm:py-0 sm:hover:text-textColor sm:hover:underline" href="/about/"> About </a>
    </nav>
</footer>
<script src="js/script.js?id=af8f4559935e7bf5bf6015373793411d"></script>
<script src="pagefind/pagefind-ui.js"></script>

<!-- Cookie Consent Banner -->
<div class="cookie-consent" id="cookieConsent">
    <div>
        <p class="text-sm">We use cookies to analyze our website traffic and provide a better browsing experience. By
            continuing to use our site, you agree to our use of cookies.</p>
    </div>
    <div class="cookie-consent-buttons">
        <button class="cookie-consent-decline" onclick="declineCookies()">Decline</button>
        <button class="cookie-consent-accept" onclick="acceptCookies()">Accept</button>
    </div>
</div>

<script>
    // Cookie consent management
    function showCookieConsent() {
        const consent = localStorage.getItem('cookieConsent');
        if (!consent) {
            document.getElementById('cookieConsent').classList.add('show');
        }
    }

    function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookieConsent').classList.remove('show');
        loadGA(); // Load Google Analytics after consent
    }

    function declineCookies() {
        localStorage.setItem('cookieConsent', 'declined');
        document.getElementById('cookieConsent').classList.remove('show');
    }

    // Show the consent banner only for EU visitors (you can add more country codes as needed)
    fetch('https://ipapi.co/json/')
            .then(response => response.json())
            .then(data => {
                const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
                if (euCountries.includes(data.country_code)) {
                    showCookieConsent();
                } else {
                    // For non-EU visitors, automatically load GA
                    if (!localStorage.getItem('cookieConsent')) {
                        localStorage.setItem('cookieConsent', 'accepted');
                        loadGA();
                    }
                }
            })
            .catch(() => {
                // If we can't determine location, show the consent banner to be safe
                showCookieConsent();
            });
</script>
</body>
</html>